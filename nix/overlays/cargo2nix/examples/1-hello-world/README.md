# Hello World

This is very simple `bin` crate generated by `cargo new`, with no additional
modification. It is built using the latest stable Rust, as provided by
[nixpkgs-mozilla](https://github.com/mozilla/nixpkgs-mozilla).

## Introduction

This guide will explain how to build your first Cargo crate with `cargo2nix`. We
assume that you already have the [Nix package manager] installed on your machine
before we get started.

[Nix package manager]: https://nixos.org/nix/

As described in the official README, `cargo2nix` itself is made up of two
distinct components:

1. A command-line tool which processes a given `Cargo.toml` and `Cargo.lock` and
   produces an equivalent `Cargo.nix` file.
2. A [Nixpkgs overlay] which provides functions for building the `Cargo.nix`
   using a specified version of the Rust toolchain.

[Nixpkgs overlay]: https://nixos.wiki/wiki/Overlays

Let's take a look at how to build a minimal `bin` crate generated by `cargo new`
using `cargo2nix`.

## Getting started

The first step is to install the `cargo2nix` command-line tool on your system,
if it's not already present. This can be done by executing the following
one-liner in your shell:

```bash
nix-env -iA package -f https://github.com/tenx-tech/cargo2nix/tarball/master
```

Once it's installed, we can move on to creating the Cargo project we wish to
build.

## Generating the Cargo project

The canonical way to generate a new binary crate project with Cargo is to run
`cargo new <name>`. However, this requires us to have some version of the Rust
toolchain installed on our system. If Cargo isn't present on your machine, you
can use `nix-shell` to drop into a temporary shell with Cargo present, like so:

```bash
nix-shell -p cargo
```

Now that we're inside this shell, let's create the `hello-world` crate we wish
to build:

```bash
cargo new hello-world
```

Since [Cargo 0.26.0](https://github.com/rust-lang/cargo/pull/5029), the default
project type should be `--bin` if unspecified. You should see the following
output in your terminal:

```text
     Created binary (application) `hello-world` package
```

This should create a new directory called `hello-world` containing a mostly
empty `Cargo.toml` and `src/main.rs` file. Change into that directory with `cd`,
and we should be ready to start using `cargo2nix` proper.

## Wrapping with cargo2nix

So far, so standard. We have been dealing mostly with standard Nix and Cargo
commands up until this point. Now we are ready to begin wrapping up our
`hello-world` crate with `cargo2nix`.

### Generating a Cargo.nix

As mentioned in the above [introduction](#introduction), we need to generate a
`Cargo.nix` file from our crate's `Cargo.toml` and `Cargo.lock` in order to use
`cargo2nix`. While our project contains a `Cargo.toml`, it doesn't have a
`Cargo.lock` file yet.

While you could make one appear by building your project with `cargo build` for
the first time, you can also generate one with this command:

```bash
cargo generate-lockfile
```

Next, run the following command in the project root to make a `Cargo.nix` file:

```bash
cargo2nix -f
```

If you check the current directory with `ls`, you should see that there is now a
`Cargo.nix` file residing alongside the `Cargo.toml` and `Cargo.lock` from
earlier. This Nix expression describes the dependency graph of your Cargo crate
or [crate workspace] in a way that Nix can understand.

[crate workspace]: https://doc.rust-lang.org/edition-guide/rust-2018/cargo-and-crates-io/cargo-workspaces-for-multi-package-projects.html

> Any time that you modify the `Cargo.toml` or `Cargo.lock` file for your
> project, you should always remember to re-run `cargo2nix -f` to update the
> `Cargo.nix` as well.

The final step is to create a `default.nix` file capable of compiling this Rust
crate with Nix.

### Creating a default.nix

In order to build our project with `nix-build`, we need to have a `default.nix`
present at the project root. Let's create one!

To start, let's create a new file called [`default.nix`] and declare a function
with the following arguments:

[`default.nix`]: ./default.nix

```nix
{
  system ? builtins.currentSystem,
  nixpkgsMozilla ? builtins.fetchGit {
    url = https://github.com/mozilla/nixpkgs-mozilla;
    rev = "50bae918794d3c283aeb335b209efd71e75e3954";
  },
  cargo2nix ? builtins.fetchGit {
    url = https://github.com/tenx-tech/cargo2nix;
    ref = "v0.8.3";
  },
}:
```

Let's break down what these function arguments mean one by one.

The first argument, `system`, is a string which declares what platform Nix
should build this project for. This is _not_ a [Rust target triple], but rather
a [Nix system parameter] such as `"x86_64-linux"` or `"x86_64-darwin"`. By
default, we want this string to be set to `builtins.currentSystem` if left
unspecified by the user, so we use the `?` operator to set a default.

[Rust target triple]: https://forge.rust-lang.org/release/platform-support.html
[Nix system parameter]: https://nixos.org/nixos/nix-pills/nixpkgs-parameters.html#idm140737319760528

The second argument, `nixpkgsMozilla`, fetches [nixpkgs-mozilla] from GitHub.
This repository contains a [handy Nixpkgs overlay for Rust] which allows you to
fetch a version of Rust using [release channels] similar to Rustup, e.g.
`"stable"`, `"nightly"`, or `"1.41.0"`.

[nixpkgs-mozilla]: https://github.com/mozilla/nixpkgs-mozilla
[handy Nixpkgs overlay for Rust]: https://github.com/mozilla/nixpkgs-mozilla#rust-overlay
[release channels]: https://doc.rust-lang.org/edition-guide/rust-2018/rustup-for-managing-rust-versions.html

The final argument, `cargo2nix`, fetches the [cargo2nix] repository from GitHub.
To build our project, we need to fetch a fixed release of `cargo2nix` so we can
use the provided Nixpkgs overlay from it to build our Rust project. By default,
we fetch from the Git tag `v0.8.3`.

Next, we need to write the body of our function. To do this, we declare a `let`
block and import [Nixpkgs] using our three function arguments from earlier:

[cargo2nix]: https://github.com/tenx-tech/cargo2nix
[Nixpkgs]: https://github.com/NixOS/nixpkgs

```nix
let
  rustOverlay = import "${nixpkgsMozilla}/rust-overlay.nix";
  cargo2nixOverlay = import "${cargo2nix}/overlay";

  pkgs = import <nixpkgs> {
    inherit system;
    overlays = [ rustOverlay cargo2nixOverlay ];
  };
in
  # TODO
```

Now that Nixpkgs is imported with our two overlays, we now have a few extra
functions available to us, courtesy of the `cargo2nix` overlay. Specifically, we
have the entry point to `cargo2nix` called `rustBuilder`. Inside of
`rustBuilder`, we have a function called `makePackageSet'` (note the single
quote in the name) which can be used to build our project's `Cargo.nix` file.

To build our `hello-world` project, we change our `let` block from earlier to
look like this:

```nix
let
  rustOverlay = import "${nixpkgsMozilla}/rust-overlay.nix";
  cargo2nixOverlay = import "${cargo2nix}/overlay";

  pkgs = import <nixpkgs> {
    inherit system;
    overlays = [ rustOverlay cargo2nixOverlay ];
  };

  rustPkgs = pkgs.rustBuilder.makePackageSet' {
    rustChannel = "stable";
    packageFun = import ./Cargo.nix;
  };
in
  rustPkgs.workspace.hello-world {}
```

There's a bit to unpack in the changes shown above. We use `makePackageSet'` to
import our `Cargo.nix` file and build it using the `"stable"` release channel of
Rust. The output of this function is a tree structure containing the entire
dependency graph from our `Cargo.nix`, which we call `rustPkgs`.

The structure of `rustPkgs` is organized as follows:

```nix
             rustPkgs."unknown".hello-world."0.1.0" { }
#                     ^^^^^^^^^ ^^^^^^^^^^^ ^^^^^^^ ^^^
#                         |          |         |     |
# Source -----------------+          |         |     |
#  - Crates.io URL                   |         |     |
#  - Git repository URL              |         |     |
#  - Alterative registry URL         |         |     |
#  - `unknown` for path deps         |         |     |
#                                    |         |     |
#                Name ---------------+         |     |
#                                              |     |
#                           Version -----------+     |
#                                                    |
#                    Optional build arguments -------+
#                     - `compileMode = "test"`
#                     - `compileMode = "bench"`
#                     - `buildInputs`, `nativeBuildInputs`, etc.
```

We can refer to any crate present in our `Cargo.lock` file using this notation,
and build it if we want. However, if we would like to simply refer to the crates
inside of our local workspace, we can use the shorthand form:

```nix
rustPkgs.workspace.hello-world {}
```

This is the final output of our `let` block in our function, a compiled version
of `hello-world` crate, built with the latest stable version of Rust, containing
our final binary. The finished version of the `default.nix` file can be viewed
[here](./default.nix), if you would like to see the whole thing.

Save the `default.nix` file and quit. Your `cargo2nix` project is ready for
building!

## Building

To compile the `hello-world` binary with Nix, simply run:

```bash
nix-build
```

This will create a `result` symlink in the current directory with the following
structure:

```text
/nix/store/kqrja6mqa7mdwn6iybyilipg29m4vb5f-crate-hello-world-0.1.0
├── .cargo-info
├── bin
│   └── hello-world
└── lib
    └── .link-flags
```

Running the `hello-world` binary will print the following message to the screen:

```text
$ ./result/bin/hello-world
Hello, world!
```

Awesome! You've just built your first Rust project with Nix using `cargo2nix`.
:tada:

In the next example, we'll take a look at building a more complex Cargo project
with some Crates.io dependencies.
