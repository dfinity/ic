# Strip debug_info off every target for determinism
# (https://github.com/ziglang/zig/issues/23821, https://github.com/ziglang/zig/issues/23823).
diff --git a/MODULE.bazel b/MODULE.bazel
index 1265298..15b70b3 100644
--- a/MODULE.bazel
+++ b/MODULE.bazel
@@ -54,3 +54,20 @@ register_toolchains(
     # These toolchains are only registered locally.
     dev_dependency = True,
 )
+
+bazel_dep(name = "bazel_skylib", version = "1.7.1")
+
+new_local_repository = use_repo_rule("@bazel_tools//tools/build_defs/repo:local.bzl", "new_local_repository")
+new_local_repository(
+    name = "strip",
+    build_file_content = """
+load("@bazel_skylib//rules:native_binary.bzl", "native_binary")
+
+native_binary(
+name = "strip_bin",
+src = ":strip",
+visibility = ["//visibility:public"],
+)
+""",
+    path = "/usr/bin",
+)
diff --git a/toolchain/defs.bzl b/toolchain/defs.bzl
index bac9464..25b905c 100644
--- a/toolchain/defs.bzl
+++ b/toolchain/defs.bzl
@@ -276,6 +276,7 @@ def declare_files(os):
                 ":zig",
                 ":{}_includes".format(target_config.zigtarget),
                 cxx_tool_label,
+                "@strip//:strip_bin",
             ],
         )

@@ -285,6 +286,7 @@ def declare_files(os):
                 ":zig",
                 ":{}_includes".format(target_config.zigtarget),
                 cxx_tool_label,
+                "@strip//:strip_bin",
             ] + native.glob([
                 "lib/libc/{}/**".format(target_config.libc),
                 "lib/libcxx/**",
diff --git a/toolchain/zig-wrapper.zig b/toolchain/zig-wrapper.zig
index 3ea3964..4f471ee 100644
--- a/toolchain/zig-wrapper.zig
+++ b/toolchain/zig-wrapper.zig
@@ -132,7 +132,7 @@ pub fn main() u8 {
             if (builtin.os.tag == .windows)
                 return spawnWindows(arena, params)
             else
-                return execUnix(arena, params);
+                return spawnAndStripUnix(arena, params);
         },
     }
 }
@@ -177,6 +177,54 @@ fn makeSuffix(allocator: std.mem.Allocator, pwd: []const u8) ![]const u8 {
     return std.fmt.allocPrint(allocator, "config-catchall", .{});
 }

+fn spawnAndStripUnix(arena: mem.Allocator, params: ExecParams) u8 {
+    // Build a strip command
+    const strip_cmd = blk: {
+        var list = ArrayListUnmanaged([]const u8){};
+        list.appendSlice(arena, &[_][]const u8{ "strip", "-S" }) catch |err| {
+            return fatal("error building strip cmd: {s}\n", .{@errorName(err)});
+        };
+
+        // Find any output targets
+        var next = false;
+        for (params.args.items) |param| {
+            if (mem.eql(u8, param, "-o")) {
+                next = true;
+            } else if (next) {
+                list.append(arena, param) catch |err| {
+                    return fatal("error adding output target: {s}\n", .{@errorName(err)});
+                };
+                break;
+            }
+        }
+        break :blk list;
+    };
+
+    // Run the intended zig process
+    var proc = ChildProcess.init(params.args.items, arena);
+    proc.env_map = &params.env;
+
+    const ret = proc.spawnAndWait() catch |err| {
+        return fatal("error spawning {s}: {s}\n", .{ params.args.items[0], @errorName(err) });
+    };
+
+    const code = switch (ret) {
+        .Exited => |code| code,
+        else => |other| return fatal("abnormal exit: {any}\n", .{other}),
+    };
+
+    // Run strip command, ignore output
+    var strip_proc = ChildProcess.init(strip_cmd.items, arena);
+    strip_proc.env_map = &params.env;
+    strip_proc.stdout_behavior = .Ignore;
+    strip_proc.stderr_behavior = .Ignore;
+
+    _ = strip_proc.spawnAndWait() catch |err| {
+        return fatal("running strip: {s}\n", .{@errorName(err)});
+    };
+
+    return code;
+}

 // argv_it is an object that has such method:
 //     fn next(self: *Self) ?[]const u8
