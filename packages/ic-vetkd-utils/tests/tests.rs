use ic_bls12_381::*;
use ic_vetkd_utils::*;
use rand::{Rng, SeedableRng};

mod test_utils;

#[test]
fn test_xmd_test_vector() {
    let dst = "QUUX-V01-CS02-with-expander-SHA256-128";
    let test_vectors = [
        ("", "68a985b87eb6b46952128911f2a4412bbc302a9d759667f87f7a21d803f07235"),
        ("616263", "d8ccab23b5985ccea865c6c97b6e5b8350e794e603b4b97902f53a8a0d605615"),
        ("61626364656630313233343536373839", "eff31487c770a893cfb36f912fbfcbff40d5661771ca4b2cb4eafe524333f5c1"),
        ("713132385f7171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171717171", "b23a1d2b4d97b2ef7785562a7e8bac7eed54ed6e97e29aa51bfe3f12ddad1ff9"),
        ("987db5406ce297e729c8564a106dc896943b00216a095fe9c5d32a16a330c02eb80e6f468ede83cde5462b5145b58f65", "4e91306f72d20c58379ddf86e40869706c8c533d40c277cd808abaf6ac623fc1"),
    ];

    for (input, expected) in &test_vectors {
        let computed = derive_symmetric_key(&hex::decode(input).unwrap(), dst, expected.len() / 2);
        assert_eq!(hex::encode(computed), *expected);
    }
}

#[test]
fn protocol_flow_with_emulated_server_side() {
    use test_utils::*;

    let seed = rand::thread_rng().gen::<u64>();
    println!("seed {:?}", seed);

    let mut rng = rand_chacha::ChaCha20Rng::seed_from_u64(seed);

    let derivation_path = DerivationPath::new(b"canister-id", b"context");
    let context = rng.gen::<[u8; 32]>();

    let tsk_seed = rng.gen::<[u8; 32]>().to_vec();
    let tsk = TransportSecretKey::from_seed(tsk_seed).unwrap();

    let tpk_bytes: [u8; 48] = tsk.public_key().try_into().unwrap();
    let tpk = G1Affine::from_compressed(&tpk_bytes).unwrap();

    // Ordinarily the master secret key would be held as shares by
    // independent notes, with the encrypted key created by combining
    // shares. Here we simply create the master secret key and create
    // the combined encrypted key directly.

    let master_sk = random_scalar(&mut rng);
    let master_pk = G2Affine::from(G2Affine::generator() * master_sk);

    let derived_public_key =
        G2Affine::from(master_pk + G2Affine::generator() * derivation_path.delta());

    let ek_bytes = create_encrypted_key(
        &mut rng,
        &master_pk,
        &master_sk,
        &tpk,
        &derivation_path,
        &context,
    );

    let ek = EncryptedKey::deserialize(&ek_bytes).unwrap();

    let dpk_bytes = derived_public_key.to_compressed().to_vec();

    let dpk = DerivedPublicKey::deserialize(&dpk_bytes).unwrap();

    let vetkey = ek.decrypt_and_verify(&tsk, &dpk, &context).unwrap();

    let msg = rng.gen::<[u8; 32]>().to_vec();
    let seed = rng.gen::<[u8; 32]>().to_vec();
    let ctext = IBECiphertext::encrypt(&dpk, &context, &msg, &seed).unwrap();

    let ptext = ctext.decrypt(&vetkey).expect("IBE decryption failed");
    assert_eq!(ptext, msg);
}

#[test]
fn protocol_flow_with_fixed_rng_has_expected_outputs() {
    let tsk = TransportSecretKey::from_seed(vec![0x42; 32]).unwrap();

    let tpk = tsk.public_key();

    assert_eq!(hex::encode(tpk),
               "911969d56f42875d37a92d7eaa5d43293eff9f9a20ba4c60523e70a695eaeadeb721659b52a49d74e67841ad19033a12");

    // generated by internal library:

    let dpk = DerivedPublicKey::deserialize(&hex::decode("972c4c6cc184b56121a1d27ef1ca3a2334d1a51be93573bd18e168f78f8fe15ce44fb029ffe8e9c3ee6bea2660f4f35e0774a35a80d6236c050fd8f831475b5e145116d3e83d26c533545f64b08464e4bcc755f990a381efa89804212d4eef5f").unwrap()).unwrap();

    let ek = EncryptedKey::deserialize(&hex::decode("b1a13757eaae15a3c8884fc1a3453f8a29b88984418e65f1bd21042ce1d6809b2f8a49f7326c1327f2a3921e8ff1d6c3adde2a801f1f88de98ccb40c62e366a279e7aec5875a0ce2f2a9f3e109d9cb193f0197eadb2c5f5568ee4d6a87e115910662e01e604087246be8b081fc6b8a06b4b0100ed1935d8c8d18d9f70d61718c5dba23a641487e72b3b25884eeede8feb3c71599bfbcebe60d29408795c85b4bdf19588c034d898e7fc513be8dbd04cac702a1672f5625f5833d063b05df7503").unwrap()).unwrap();

    let context = hex::decode("6d657373616765").unwrap();

    let vetkey = ek.decrypt_and_verify(&tsk, &dpk, &context).unwrap();

    assert_eq!(hex::encode(vetkey.signature_bytes()),
               "987db5406ce297e729c8564a106dc896943b00216a095fe9c5d32a16a330c02eb80e6f468ede83cde5462b5145b58f65");

    let msg = hex::decode("f00f11").unwrap();
    let seed: [u8; 32] = [0u8; 32];
    let ctext = IBECiphertext::encrypt(&dpk, &context, &msg, &seed).unwrap();

    let ctext_bytes = ctext.serialize();

    assert_eq!(hex::encode(&ctext_bytes),
               "a2e6596cec446ce55d4d566cc6664abcf899cf824d420e55bd6177ffc2085388767a10a922a5f2e2d06835fc11f291a6053aa861acd577add1465ff50d218d814ff18c22dc27363c412a4d53133fe23eff8595a77f01c90e5c3e83562e5bf575e6ae99799fab790d08fb7e81c855377bbe60e8854ba70a4d8181ef35f3be69250fdaa2");

    assert_eq!(
        ctext,
        IBECiphertext::deserialize(&ctext_bytes).expect("Deserializing IBECiphertext failed")
    );

    let ptext = ctext.decrypt(&vetkey).expect("IBE decryption failed");
    assert_eq!(ptext, msg);
}
