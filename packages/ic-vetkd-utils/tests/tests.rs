use ic_bls12_381::*;
use ic_vetkd_utils::*;
use rand::{Rng, SeedableRng};

mod test_utils;

#[test]
fn protocol_flow_with_emulated_server_side() {
    use test_utils::*;

    let seed = rand::thread_rng().gen::<u64>();
    println!("seed {:?}", seed);

    let mut rng = rand_chacha::ChaCha20Rng::seed_from_u64(seed);

    let derivation_path = DerivationPath::new(b"canister-id", &[b"1", b"2"]);
    let did = rng.gen::<[u8; 32]>();

    let tsk_seed = rng.gen::<[u8; 32]>().to_vec();
    let tsk = TransportSecretKey::from_seed(tsk_seed).unwrap();

    let tpk_bytes: [u8; 48] = tsk.public_key().try_into().unwrap();
    let tpk = G1Affine::from_compressed(&tpk_bytes).unwrap();

    // Ordinarily the master secret key would be held as shares by
    // independent notes, with the encrypted key created by combining
    // shares. Here we simply create the master secret key and create
    // the combined encrypted key directly.

    let master_sk = random_scalar(&mut rng);
    let master_pk = G2Affine::from(G2Affine::generator() * master_sk);

    let derived_public_key =
        G2Affine::from(master_pk + G2Affine::generator() * derivation_path.delta());

    let ek = create_encrypted_key(
        &mut rng,
        &master_pk,
        &master_sk,
        &tpk,
        &derivation_path,
        &did,
    );

    let dpk_bytes = derived_public_key.to_compressed().to_vec();

    let ibe_key = tsk.decrypt(&ek, &dpk_bytes, &did).unwrap();

    let msg = rng.gen::<[u8; 32]>().to_vec();
    let seed = rng.gen::<[u8; 32]>().to_vec();
    let ctext = IBECiphertext::encrypt(&dpk_bytes, &did, &msg, &seed).unwrap();

    let ptext = ctext.decrypt(&ibe_key).expect("IBE decryption failed");
    assert_eq!(ptext, msg);
}

#[test]
fn protocol_flow_with_fixed_rng_has_expected_outputs() {
    let tsk = TransportSecretKey::from_seed(vec![0x42; 32]).unwrap();

    let tpk = tsk.public_key();

    assert_eq!(hex::encode(tpk),
               "911969d56f42875d37a92d7eaa5d43293eff9f9a20ba4c60523e70a695eaeadeb721659b52a49d74e67841ad19033a12");

    // generated by internal library:

    let dpk_bytes = hex::decode("972c4c6cc184b56121a1d27ef1ca3a2334d1a51be93573bd18e168f78f8fe15ce44fb029ffe8e9c3ee6bea2660f4f35e0774a35a80d6236c050fd8f831475b5e145116d3e83d26c533545f64b08464e4bcc755f990a381efa89804212d4eef5f").unwrap();

    let ek_bytes = hex::decode("b1a13757eaae15a3c8884fc1a3453f8a29b88984418e65f1bd21042ce1d6809b2f8a49f7326c1327f2a3921e8ff1d6c3adde2a801f1f88de98ccb40c62e366a279e7aec5875a0ce2f2a9f3e109d9cb193f0197eadb2c5f5568ee4d6a87e115910662e01e604087246be8b081fc6b8a06b4b0100ed1935d8c8d18d9f70d61718c5dba23a641487e72b3b25884eeede8feb3c71599bfbcebe60d29408795c85b4bdf19588c034d898e7fc513be8dbd04cac702a1672f5625f5833d063b05df7503").unwrap();

    let did = b"message";
    let ad = b"aes-256-gcm-siv";
    let key = tsk
        .decrypt_and_hash(&ek_bytes, &dpk_bytes, did, 32, ad)
        .unwrap();

    assert_eq!(
        hex::encode(key),
        "e4e8c37bbc2ec30be431edea85551f5d4161da1dcd9bc76c854cc1d6a9a28a89"
    );

    let ibe_key = tsk.decrypt(&ek_bytes, &dpk_bytes, did).unwrap();

    let msg = b"is this thing on?";
    let seed: [u8; 32] =
        hex::decode("f6a12ca8ffc30a66ca140ccc7276336115819361186d3f535dd99f8eaaca8fce")
            .unwrap()
            .try_into()
            .expect("Correct len");
    let ctext = IBECiphertext::encrypt(&dpk_bytes, did, msg, &seed).unwrap();

    let ctext_bytes = ctext.serialize();

    assert_eq!(hex::encode(&ctext_bytes),
               "8ad4cc0bbdc1966e9704e65af55a03d5c8790de2eae8d62dc4f48ccb90b3687f16e64d8227ade2f57b17d2044fde2c2d0f8089721f1f5a9e099653de59f787476a8337196e0b071505c36f96c7197a2de8d011ef761fc813701f4b2ea5c3a6a140aacad00e5e69a8d91c024da9af89983ffa91d81464963643139db986c69c9dabc48d4b624640fc9e0ab01c1e41c68e76");

    assert_eq!(
        ctext,
        IBECiphertext::deserialize(&ctext_bytes).expect("Deserializing IBECiphertext failed")
    );

    let ptext = ctext.decrypt(&ibe_key).expect("IBE decryption failed");
    assert_eq!(ptext, msg);
}
