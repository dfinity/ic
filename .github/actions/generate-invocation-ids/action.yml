name: 'Generate invocation IDs for bazel'
description: |
    An action for generating uuids for bazel invocations in to provider easier way to find the
    links to BuildBuddy.

inputs:
  targets:
    description: |
      YAML list of targets to generate UUIDs for. Each item must have:
        name: display name (e.g. Build, Test)
        output_id: GitHub Actions output variable
      Example:
        - name: Build
          output_id: build_id
        - name: Test
          output_id: test_id
    required: true

outputs:
  output:
    description: "JSON object containing all generated UUIDs"
    value: ${{ steps.gen-uuids.outputs.output }}

runs:
  using: "composite"
  steps:
    - name: Generate Bazel invocation IDs
      id: gen-uuids
      shell: bash
      run: |
        set -euo pipefail

        generate_uuid() {
          case "$(uname -s)" in
              Linux)
                  if [[ -f /proc/sys/kernel/random/uuid ]]; then
                      cat /proc/sys/kernel/random/uuid
                  else
                      # fallback if /proc/sys/kernel/random/uuid is missing
                      uuidgen
                  fi
                  ;;
              Darwin)
                  uuidgen
                  ;;
              MINGW*|MSYS*|CYGWIN*)
                  # Windows Git Bash / MSYS
                  if command -v uuidgen &> /dev/null; then
                      uuidgen
                  else
                      # TODO: how to do it properly on a windows???
                      # fallback: use PowerShell to generate a GUID
                      powershell.exe -Command "[guid]::NewGuid().ToString()"
                  fi
                  ;;
              *)
                  echo "Unsupported OS: $(uname -s)" >&2
                  exit 1
                  ;;
          esac
        }

        targets="${{ inputs.targets }}"

        # panic if empty
        if [[ -z "$targets" ]]; then
          echo "Error: 'targets' input must contain at least one target" >&2
          exit 1
        fi

        # Detect architecture and download yq if missing
        # TODO: find a better alternative longterm
        downloaded=false
        yq_cmd=yq
        if ! command -v yq &> /dev/null; then
            echo "yq not found, downloading..."
            ARCH=$(uname -m)
            YQ_URL=""
            case "$ARCH" in
                x86_64) YQ_URL="https://github.com/mikefarah/yq/releases/download/v4.47.2/yq_linux_amd64" ;;
                i386|i686) YQ_URL="https://github.com/mikefarah/yq/releases/download/v4.47.2/yq_linux_386" ;;
                armv7l) YQ_URL="https://github.com/mikefarah/yq/releases/download/v4.47.2/yq_linux_arm" ;;
                aarch64) YQ_URL="https://github.com/mikefarah/yq/releases/download/v4.47.2/yq_linux_arm64" ;;
                *) echo "Unsupported architecture: $ARCH" >&2; exit 1 ;;
            esac

            curl -L "$YQ_URL" -o ./yq
            chmod +x ./yq
            downloaded=true
            yq_cmd=./yq
        fi

        # TODO: find a way to programatically get bes upload url
        build_buddy="https://dash.idx.dfinity.network"
        invocations_base="$build_buddy/invocation"


        # initialize summary table
        summary="### Bazel Invocation IDs\n\n"
        summary+="_These links may not be immediately available; invocation details will eventually populate once the build/test completes._\n\n"
        summary+="| Job type | Invocation ID | Link |\n"
        summary+="|----------|---------------|------|\n"

        output_yaml=""

        while IFS=$'\t' read -r name output_id; do
            uuid=$(generate_uuid)
            link="$invocations_base/$uuid"
            summary+="| $name | \`$uuid\` | [BuildBuddy link to $uuid]($link) |\n"

            # Cannot have dynamic variables so hack it with yq.
            if [[ -z "$output_yaml" ]]; then
                output_yaml="$output_id: \"$uuid\""
            else
                output_yaml="$output_yaml"$'\n'"$output_id: \"$uuid\""
            fi
        done < <(echo "$targets" | $yq_cmd -r '.[] | [.name, .output_id] | @tsv')

        # Convert YAML to JSON using yq and set as output
        # but unescaped.
        output_json=$(echo "$output_yaml" | $yq_cmd -o=json -I=0 '.')
        echo "output=$output_json" >> "$GITHUB_OUTPUT"

        # cleanup if we downloaded yq locally
        if [[ "$downloaded" == true ]]; then
            rm -f "$yq_cmd"
        fi

        echo "Output:"
        echo -e "$(cat $GITHUB_OUTPUT)"

        echo "Summary:"
        # write summary
        echo -e "$summary" >> "$GITHUB_STEP_SUMMARY"
        # write it to stdout so that the job also has it
        echo -e "$summary"


