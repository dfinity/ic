name: Container IC Build Image

on:
  pull_request:
    paths:
      - '.github/workflows/container-autobuild.yml'
      - '.bazelversion'
      - 'rust-toolchain.toml'
      - 'ci/container/**'
  push:
    branches:
      - 'dev-gh-*'
    paths:
      - '.github/workflows/container-autobuild.yml'
      - '.bazelversion'
      - 'rust-toolchain.toml'
      - 'ci/container/**'
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: write
  packages: write
  pull-requests: write

jobs:
  build-image-prep:
    name: Build Image Prep
    runs-on: ubuntu-latest
    outputs:
      build_image: ${{ steps.set-output.outputs.build_image }}
      image_tag: ${{ steps.set-output.outputs.image_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set Build Output
        shell: bash
        id: set-output
        run: |
          # Check if we've previously already built ic-build image
          set -eExuo pipefail
          image_tag="$(ci/container/get-image-tag.sh)"
          if grep $image_tag ci/container/TAG; then
            echo "build_image=false" >> "$GITHUB_OUTPUT"
            echo "Update with this image already in this PR!"
            echo "Modify ci/container/TAG with random string to trigger new build."
          else
            echo "build_image=true" >> "$GITHUB_OUTPUT"
            echo "image_tag=$image_tag" >> "$GITHUB_OUTPUT"
          fi

  ic-build-image:
    name: Build Container Image ${{ matrix.image }}
    runs-on: ubuntu-latest
    needs: [build-image-prep]
    if: ${{ needs.build-image-prep.outputs.build_image == 'true' }}
    timeout-minutes: 60
    strategy:
      matrix:
        include:
          - image: ic-build
            target: build
          - image: ic-dev
            target: dev
    outputs:
      imageid: ${{ steps.set-imageid.outputs.imageid }} # both images share the same imageid
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@a530e948adbeb357dbca95a7f8845d385edf4438 # v3

      - name: Login to GHCR
        uses: docker/login-action@9780b0c442fbb1117ed29e0efdff1e18412f7567 # v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Container Image ${{ matrix.image }}
        # this sets the output 'imageid' to the sha256 of the output image
        uses: docker/build-push-action@eb539f44b153603ccbfbd98e2ab9d4d0dcaf23a4 # v5
        id: build
        with:
          context: .
          file: ci/container/Dockerfile
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/${{ matrix.image }}:${{ needs.build-image-prep.outputs.image_tag }}
          target: ${{ matrix.target }}
          build-args: |
            CI_USER=1001
      - name: Set imageid output
        id: set-imageid
        if: matrix.image == 'ic-build'
        run: echo "imageid=${{ steps.build.outputs.imageid }}" >> $GITHUB_OUTPUT

  update-image-references:
    name: Update Image References in Repo
    runs-on: ubuntu-latest
    needs: [build-image-prep, ic-build-image]
    if: ${{ needs.build-image-prep.outputs.build_image == 'true' }}
    steps:
      - name: Create GitHub App Token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ vars.PR_CREATION_BOT_APP_ID }}
          private-key: ${{ secrets.PR_CREATION_BOT_PRIVATE_KEY }}

      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          token: ${{ steps.app-token.outputs.token }}

      - name: Update Image References
        shell: bash
        run: |
          # Update container image references
          set -xeuo pipefail

          IMG_NAME=${{ github.repository_owner }}/ic-build
          IMG_NAME_FULL="ghcr.io/${IMG_NAME}@${{ needs.ic-build-image.outputs.imageid }}"

          echo '${{ needs.build-image-prep.outputs.image_tag }}' > ci/container/TAG
          pushd .devcontainer
          sed -i -E "s|(ghcr.io/)?$IMG_NAME(:\|@)[^\"]{5,}|$IMG_NAME_FULL|g" -- *
          popd
          pushd .github
          sed -i -E "s|(ghcr.io/)?$IMG_NAME(:\|@)[^\"]{5,}|$IMG_NAME_FULL|g" -- workflow*/*
          popd

          git config --global user.name "IDX GitHub Automation"
          git config --global user.email "<>"
          git add .
          git commit -m 'Updating container image to ${{ needs.ic-build-image.outputs.imageid }}' -m 'Image tag: ${{ needs.build-image-prep.outputs.image_tag }}'
          git push

      - name: Add PR Comment
        uses: actions/github-script@v7
        if: ${{ github.event_name == 'pull_request' }}
        with:
          script: |
            let message = 'Run URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\n\n'
            message += 'New container image: `${{ needs.ic-build-image.outputs.imageid }}`\n'
            message += 'New container tag: `${{ needs.build-image-prep.outputs.image_tag }}`'

            // Find existing comment from this workflow
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.data.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('New container image:')
            );

            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: message
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: message
              });
            }
