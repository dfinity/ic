too-many-arguments-threshold = 12
allow-expect-in-tests = true
allow-unwrap-in-tests = true
disallowed-methods = [
    { path = "bincode::deserialize_from", reason = "bincode::deserialize_from() is not safe to use on untrusted data, since the method will read a u64 length value from the first 8 bytes of the serialized payload and will then attempt to allocate this number of bytes without any validation." },
    { path = "std::io::Write::write", reason = "`Write::write()` may not write the entire buffer. Use `Write::write_all()` instead. Or, if you are intentionally using `Write::write()`, use `#[allow(clippy::disallowed_methods)]` to locally disable this check." },
    { path = "tokio::io::AsyncWriteExt::write", reason = "`AsyncWriteExt::write()` may not write the entire buffer. Use `AsyncWriteExt::write_all()` instead. Or, if you are intentionally using `Write::write()`, use `#[allow(clippy::disallowed_methods)]` to locally disable this check." },
    { path = "tokio::task::block_in_place", reason = "`block_in_place()` almost always signals that there is an issue with the overall design. Furthermore, `block_in_place()` panics unless the Tokio scheduler has enough available threads to move tasks. If you are intentionally using `block_in_place()`, use `#[allow(clippy::disallowed_methods)]` to locally disable this check." },
    # unbounded channels are for expert use only
    { path = "tokio::sync::mpsc::unbounded_channel", reason = "Using an unbounded channel can lead to unbounded memory growth. Please use a bounded channel instead. If you are intentionally using an unbounded channel, use `#[allow(clippy::disallowed_methods)]` to locally disable this check." },
    { path = "futures::channel::mpsc::unbounded", reason = "Using an unbounded channel most likely will read to unbounded memory growth. Please use a bounded channel instead. If you are intentionally using unbounded channel, use `#[allow(clippy::disallowed_methods)]` to locally disable this check." },
    { path = "futures_channel::mpsc::unbounded", reason = "Using an unbounded channel most likely will read to unbounded memory growth. Please use a bounded channel instead. If you are intentionally using unbounded channel, use `#[allow(clippy::disallowed_methods)]` to locally disable this check." },
    { path = "crossbeam::channel::unbounded", reason = "Using an unbounded channel most likely will read to unbounded memory growth. Please use a bounded channel instead. If you are intentionally using unbounded channel, use `#[allow(clippy::disallowed_methods)]` to locally disable this check." },
    { path = "crossbeam_channel::unbounded", reason = "Using an unbounded channel most likely will read to unbounded memory growth. Please use a bounded channel instead. If you are intentionally using unbounded channel, use `#[allow(clippy::disallowed_methods)]` to locally disable this check." },
    { path = "ic_cdk::futures::spawn", reason = "This method doesn't poll immediately. For safe migration from `ic_cdk::spawn`, use `ic_cdk::futures::spawn_017_compat`. Use `#[allow(clippy::disallowed_methods)]` to locally disable this check if you understand the semantics." },
]
disallowed-types = [
    { path = "tokio::sync::Mutex", reason = "You should only use an asynchronous lock if you need to .await something while the lock is locked. Usually, this is not necessary, and you should avoid using an asynchronous lock when you can. Asynchronous locks are a lot slower than blocking locks. Please read how to share state effectively across async tasks https://tokio.rs/tokio/tutorial/shared-state. If you are intentionally using an async Mutex, use `#[allow(clippy::disallowed_types)]` to locally disable this check." },
    { path = "tokio::sync::RwLock", reason = "You should only use an asynchronous lock if you need to .await something while the lock is locked. Usually, this is not necessary, and you should avoid using an asynchronous lock when you can. Asynchronous locks are a lot slower than blocking locks. Please read how to share state effectively across async tasks https://tokio.rs/tokio/tutorial/shared-state. If you are intentionally using an async RwLock, use `#[allow(clippy::disallowed_types)]` to locally disable this check." },
    { path = "protobuf::coded_input_stream::CodedInputStream", reason = "The type allows uncontrolled recursion while parsing unknown fields via `skip_group`. Please refer to RUSTSEC-2024-0437 for more details."},
]
