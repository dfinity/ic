#!/bin/bash
# Limited Console Shell provides restricted access to select commands

source /opt/ic/bin/config.sh

# Restricted PATH for rbash commands
# IMPORTANT: /opt/ic/bin/rbash must come FIRST so 'bash' resolves to /opt/ic/bin/rbash/bash (rbash)
# instead of /bin/bash, preventing shell escape. Standard commands still work via /bin.
RESTRICTED_PATH="/opt/ic/bin/rbash:/opt/ic/bin:/bin:/usr/bin"

# Show available commands
show_menu() {
    echo "=== HostOS Limited Console ==="
    echo "Available commands:"
    echo "  system-status           - Show system status"
    echo "  service-status          - Show service status (usage: service-status <service-name>)" 
    echo "  view-logs               - View service logs (usage: view-logs <service-name>)"
    echo "  config-json             - Show /boot/config/config.json"
    echo "  guestos-console-logs    - Show GuestOS Serial Console Logs"
    echo "  network-config-settings - Show network settings from config"
    echo "  network-interfaces      - Show network interface status"
    echo "  ip-addresses            - Show all IP addresses"
    echo "  ping-gateway            - Test connectivity to IPv6 gateway"
    echo "  routes                  - Show routing table"
    echo "  manual-recovery         - Manual node recovery (ONLY FOR EMERGENCY USE)"
    echo "  system-stats            - Show system stats"
    echo "  rbash-console           - Drop into restricted bash console"
    echo "  clear                   - Clear the console"
    echo "  exit                    - Exit console"
    echo ""
}

# Command dispatcher
execute_command() {
    case "$1" in
        "system-status")
            echo "=== System Status ==="
            echo "Hostname: $(hostname)"
            echo "Uptime: $(uptime)"
            echo "Memory: $(free -h | grep '^Mem')"
            echo "Disk Usage: $(df -h / | tail -1)"
            ;;
        "service-status")
            if [ -n "${2:-}" ]; then
                # Only allow sane unit names, e.g. letters, digits, `-_.@`
                if [[ "$2" =~ ^[a-zA-Z0-9_.@-]+$ ]]; then
                    systemctl status "$2"
                else
                    echo "Invalid service name"
                fi
            else
                echo "Usage: service-status <service-name>"
                echo "Example: service-status guestos"
            fi
            ;;
        "view-logs")
            if [ -n "${2:-}" ]; then
                # Only allow sane unit names, e.g. letters, digits, `-_.@`
                if [[ "$2" =~ ^[a-zA-Z0-9_.@-]+$ ]]; then
                    journalctl -u "$2" --no-pager -n 50
                else
                    echo "Invalid service name"
                fi
            else
                echo "Usage: view-logs <service-name>"
                echo "Example: view-logs guestos"
            fi
            ;;
        "config-json")
            echo "=== /boot/config/config.json ==="
            env -i \
                TERM="$TERM" \
                LESSSECURE=1 \
                PATH="$RESTRICTED_PATH" \
                /usr/bin/less /boot/config/config.json
            ;;
        "guestos-console-logs")
            echo "=== GuestOS Serial Console Logs ==="
            env -i \
                TERM="$TERM" \
                LESSSECURE=1 \
                PATH="$RESTRICTED_PATH" \
                /usr/bin/less -f /var/log/libvirt/qemu/guestos-serial.log
            ;;
        "network-config-settings")
            echo "=== Network Settings from Config ==="
            local network_settings=$(get_config_value '.network_settings' 2>/dev/null)
            if [ -n "$network_settings" ]; then
                echo "$network_settings" | jq . 2>/dev/null || echo "$network_settings"
            else
                echo "No network settings found in config"
            fi
            ;;
        "network-interfaces")
            echo "=== Network Interface Status ==="
            /bin/ip link show
            ;;
        "ip-addresses")
            echo "=== IP Addresses ==="
            /bin/ip addr show
            ;;
        "ping-gateway")
            echo "=== Testing IPv6 Gateway Connectivity ==="
            local gateway=$(/bin/ip -6 route show | awk '/^default/ {print $3}' | head -1)
            if [ -n "$gateway" ]; then
                echo "Gateway: $gateway"
                echo ""
                /bin/ping6 -c 4 "$gateway" 2>&1
            else
                echo "No IPv6 gateway found in routing table"
                echo "IPv6 routes:"
                /bin/ip -6 route show
            fi
            ;;
        "routes")
            echo "=== Routing Table ==="
            echo "IPv4 routes:"
            /bin/ip -4 route show
            echo ""
            echo "IPv6 routes:"
            /bin/ip -6 route show
            ;;
        "manual-recovery")
            echo "=== Manual Node Recovery ==="
            echo "This will perform a manual node recovery. Do not attempt this unless you are certain it is appropriate."
            echo "Manual node recovery should only occur in the event of a critical IC failure."
            echo "In such cases, the process will be coordinated by reputable IC community leaders"
            echo "and actively discussed publicly with node providers."
            echo ""
            echo "Are you sure you want to proceed? (y/n)"
            read -r confirm
            if [ "$confirm" == "y" ]; then
                # Launch the NNS recovery TUI tool via hostos_tool

                # Fix for serial/remote consoles where window size may be missing or tiny
                if ! size=$(stty size 2>/dev/null); then
                    echo "Error: could not determine terminal size. The manual-recovery TUI requires a TTY."
                    echo "Please see \"Manual Recovery Fallback\" in the Manual Node Recovery Guide for further direction."
                    exit 1
                fi

                read -r rows cols <<< "$size"
                # Treat anything smaller than the Manual Recovery TUI minimum as unusable
                min_rows=15
                min_cols=10
                if [ "${rows:-0}" -lt "$min_rows" ] || [ "${cols:-0}" -lt "$min_cols" ]; then
                    echo "Terminal size (${rows}x${cols}) is too small or invalid, setting to 24x80"
                    stty rows 24 cols 80
                    sleep 5 # Give the user a chance to see the message
                fi

                /opt/ic/bin/hostos_tool manual-recovery
            fi
            ;;
        "system-stats")
            echo "=== System Stats ==="
            /opt/ic/bin/system_stats_tui
            ;;
        "rbash-console")
            echo "=== Dropping into Restricted Bash Console ==="
            echo "You are now in a restricted bash shell with limited commands."
            echo "Type 'exit' to return to the limited console menu."
            echo ""
            # Start rbash with restricted environment and PATH
            PATH="$RESTRICTED_PATH" /bin/rbash
            ;;
        "clear")
            clear
            ;;
        "exit")
            echo "Exiting limited console..."
            exit 0
            ;;
        "help")
            show_menu
            ;;
        *)
            echo "Unknown command: $1"
            show_menu
            ;;
    esac
}

echo "Welcome to HostOS Limited Console"
echo "Type 'help' for available commands or 'exit' to quit"
echo ""

while true; do
    echo -n "limited-console> "
    read -r command

    # Skip empty input
    if [ -z "$command" ]; then
        continue
    fi

    # Parse command and arguments safely using array to prevent command injection
    # This safely splits the input while preserving quoted arguments
    read -ra cmd_array <<< "$command"

    # If parsing produced no tokens, skip
    if [ "${#cmd_array[@]}" -eq 0 ]; then
        continue
    fi

    cmd="${cmd_array[0]}"
    # Pass remaining arguments as separate array elements to prevent injection
    execute_command "$cmd" "${cmd_array[@]:1}"

done