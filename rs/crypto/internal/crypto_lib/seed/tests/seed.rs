use ic_crypto_internal_seed::Seed;
use rand::RngCore;

#[test]
fn seed_fixed_output() {
    fn test_seed_output(seed: Seed, expected: &str) {
        let mut rng = seed.into_rng();

        let mut rng_output = vec![0u8; expected.len() / 2];
        rng.fill_bytes(&mut rng_output);
        assert_eq!(hex::encode(rng_output), expected);
    }

    /*
    These test outputs were generated by our own implementation of Seed, without
    any crosschecking. The main purpose is to guarantee that the behavior of
    Seed cannot silently change over time, for example due to a change in a
    dependency such as rand_chacha.
    */

    test_seed_output(
        Seed::from_bytes(&[42; 32]),
        "21b03e2c906a3c20d8159b65a459991238fd3bfb8a36c0af904cd1b12a109853",
    );

    test_seed_output(
        Seed::from_bytes(&[42; 32]).derive("label1"),
        "6f3377835641b9ea865e077ae3d09806fa7cd77af4ad7a6674400d8e0683517a",
    );

    test_seed_output(
        Seed::from_bytes(&[42; 32])
            .derive("label1")
            .derive("label2"),
        "545e10f21a984c7f33a03ffb1be596ae967f7b397fd086d76ccf71b3f2a43ef3",
    );

    let mut rng = Seed::from_bytes(&[42; 32]).into_rng();

    test_seed_output(
        Seed::from_rng(&mut rng),
        "2e7af894bb91c48e2b72be9627dbc960d7800ef7569c8f6f0f3d9873c7337c9a",
    );

    // This reads the next bytes from the RNG and so has a different
    // output than the previous test
    test_seed_output(
        Seed::from_rng(&mut rng),
        "2bb9a6469fff531083abd8f85c3d7ffa78090f725546a9633a35c0c4582c9b5c",
    );
}
