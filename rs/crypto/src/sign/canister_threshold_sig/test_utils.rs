use ic_base_types::NodeId;
use ic_types::crypto::canister_threshold_sig::idkg::BatchSignedIDkgDealing;
use ic_types::crypto::canister_threshold_sig::idkg::IDkgDealing;
use ic_types::crypto::canister_threshold_sig::idkg::{IDkgTranscriptId, SignedIDkgDealing};
use ic_types::crypto::{BasicSig, BasicSigOf};
use ic_types::signature::{BasicSignature, BasicSignatureBatch};
use ic_types::Height;
use ic_types_test_utils::ids::SUBNET_42;
use std::collections::BTreeMap;
use std::collections::BTreeSet;

pub(crate) fn batch_signed_dealing_with(
    internal_dealing_raw: Vec<u8>,
    dealer_id: NodeId,
) -> BatchSignedIDkgDealing {
    let dealing = IDkgDealing {
        transcript_id: IDkgTranscriptId::new(SUBNET_42, 1234, Height::new(123)),
        internal_dealing_raw,
    };
    let signed_dealing = SignedIDkgDealing {
        content: dealing,
        signature: BasicSignature {
            signature: BasicSigOf::new(BasicSig(vec![1, 2, 3])),
            signer: dealer_id,
        },
    };
    BatchSignedIDkgDealing {
        content: signed_dealing,
        signature: BasicSignatureBatch {
            signatures_map: BTreeMap::new(),
        },
    }
}

pub(crate) fn node_set(nodes: &[NodeId]) -> BTreeSet<NodeId> {
    nodes.iter().copied().collect()
}

/// Generated by running an integration test that produces a valid dealing
/// in a transcript `t` using
/// `println!("{:?}", hex::encode(&t. ... .internal_dealing_raw));`
const VALID_INTERNAL_DEALING_HEX: &str =
    "a36a63697068657274657874a1655061697273a46d657068656d6572616c5f6b657958\
     220102337d807963a57619ae7d1137f0f5938cca8e2a3047b28201c81b152508e33be2\
     6e706f705f7075626c69635f6b6579582201029739379e980a267ada615a5c5fed62ff\
     60d9cd0832a46a8738695e9f4e7d232269706f705f70726f6f66a2696368616c6c656e\
     6765582101e2c7c262a759796ecbfb3141dd4e5734de5b683e8100dbc6f8b1d226016a\
     20e168726573706f6e73655821016f45f744b83594bbbd0f883066ae6fa624ccf0d9a5\
     f37e24fe912c1cea0acdfa666374657874738a82582101c7879cfcb44557d933d649d1\
     d4a03d1281a72a44d36a4c8dee8309be8ad28c10582101822f40b19676052447a809aa\
     924d5bb7ad5850cd3999ef9ca9e4595adfc7bdfe82582101ec473c4aa28d12b91fa601\
     37a23331a05d6b6d5c8bebb73d1f1fb276f626bee85821014f44ecebebeaeee6593f8e\
     98bdfb5d49483e1d22e60f408412b7309fb75dcc7682582101e285561b28f8972ae8d6\
     244d50bb601dc2316421071ddb5b5a89ec6e296aff2e582101e37de40b83826d03fe7b\
     7575ec6b06545295043c9bc75a51c7b3f280dcbe3bfd825821017f7899cc8de5f627d0\
     fe468e4f7ea380957c21a809d421ed803c585d1ae550c8582101a68a5e0fedc0504e1b\
     0f8a344420295d1eff750a73808e5cfedb9685c762866d825821013ede272aa74b169f\
     6ed7ef2f470c8adf73c9942d6bb9bdacfe753f7f65bcdad0582101780de821e2679401\
     540a334a6133b3fc93550a93c5131eb5d7a6ba7941122a1f825821015e69f240987dfe\
     ed8064328f43fbdd4e7b03703fb331bcb10c7721543ad028d258210173fbb6b0fc7928\
     198c7df5343d2096c1a6c0f9ed68fb2a8d9d927e9d872f552d82582101a6a699a8c609\
     f8842425caea0fd78dad64306669ac1e1fbcab1d36898cd1c0b55821014a4ab6907d11\
     a9f32d5cbdb466646e139aba1427b34025683464b133cfdf249e825821011ccc7ed54e\
     3619913710b0c8233f741a86a420abbed431ea9da915d55c5d5973582101e7b3f19bbc\
     ad6f8febd6c59cd1b4e7d67169d2a966922b13035f6c781fbb3a8e825821013a6dc6e0\
     754647d6565feafa21443576053cb76bb8404c6b5e11187f3fa3a6ae58210130a70215\
     209438f8fc3178f4594810565d49335073b6cf6de1ee803cf579aa5682582101a5564e\
     ce831f10c08fea839822c0bc774bd1cf92df1d5dae1dc36fbb9aaec6065821015b7c53\
     edb993e701cb7776f166be25057bdfe53e5787002f7a5dc4abb3148f866a636f6d6d69\
     746d656e74a168506564657273656ea166706f696e747383582201027ddf9bb3320a0c\
     5d0513c2aa2a032757443ea81b27d1a6617bf8d18bd3d2bde4582201023e4b0cf646d0\
     bc988209a81c1757a4a7343275ce8d31e112a0feb415c761eb1758220102580d79438d\
     0fc38a249dc14a918f94fbe1756b8bfaad2a5f77314f97c3059c6a6570726f6f66f6";

pub(crate) fn valid_internal_dealing_raw() -> Vec<u8> {
    hex::decode(VALID_INTERNAL_DEALING_HEX).expect("failed to hex-decode")
}
