// This file is @generated by prost-build.
/// Message corresponding to an error while performing
/// an operation on the registry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegistryError {
    #[prost(enumeration = "registry_error::Code", tag = "1")]
    pub code: i32,
    /// The reason for the error.
    /// This is optional.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    /// The key on which the error occurred.
    /// This is optional and only present for by-key errors.
    #[prost(bytes = "vec", tag = "3")]
    pub key: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `RegistryError`.
pub mod registry_error {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Code {
        /// The message had a problem like a missing field
        /// or a field that was set when it shouldn't.
        MalformedMessage = 0,
        /// The 'key' specified on the request was not present
        /// in the registry.
        KeyNotPresent = 1,
        /// The 'key' specified on the request was already present.
        KeyAlreadyPresent = 2,
        /// The 'version' specified in a precondition for a mutation
        /// was not the latest version.
        VersionNotLatest = 3,
        /// The 'version' specified in a precondition for a mutation
        /// is beyond the latest version in the registry.
        VersionBeyondLatest = 4,
        /// The caller is not authorized.
        Authorization = 5,
        /// A generic internal error occurred in the registry.
        InternalError = 999,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MalformedMessage => "MALFORMED_MESSAGE",
                Self::KeyNotPresent => "KEY_NOT_PRESENT",
                Self::KeyAlreadyPresent => "KEY_ALREADY_PRESENT",
                Self::VersionNotLatest => "VERSION_NOT_LATEST",
                Self::VersionBeyondLatest => "VERSION_BEYOND_LATEST",
                Self::Authorization => "AUTHORIZATION",
                Self::InternalError => "INTERNAL_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MALFORMED_MESSAGE" => Some(Self::MalformedMessage),
                "KEY_NOT_PRESENT" => Some(Self::KeyNotPresent),
                "KEY_ALREADY_PRESENT" => Some(Self::KeyAlreadyPresent),
                "VERSION_NOT_LATEST" => Some(Self::VersionNotLatest),
                "VERSION_BEYOND_LATEST" => Some(Self::VersionBeyondLatest),
                "AUTHORIZATION" => Some(Self::Authorization),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                _ => None,
            }
        }
    }
}
/// When a "monolithic" blob is too large to fit in a single response, this is
/// used instead (in the ICP, messages can be at most 2 MiB in size). The
/// `get_chunk` canister method can then be called to fetch the original
/// monolithic blob in chunks (which can then be cancatenated to reconstitute the
/// original monolithic blob).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LargeValueChunkKeys {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub chunk_content_sha256s: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// In the not so distant future, this will be used instead of RegistryValue. See
/// the "Migrating to Large Values/High-Capacity Types" section in the file-level
/// comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighCapacityRegistryValue {
    /// The version at which this mutation happened.
    #[prost(uint64, tag = "2")]
    pub version: u64,
    /// The timestamp at which the registry mutation happened.
    #[prost(uint64, tag = "5")]
    pub timestamp_nanoseconds: u64,
    #[prost(oneof = "high_capacity_registry_value::Content", tags = "1, 3, 4")]
    pub content: ::core::option::Option<high_capacity_registry_value::Content>,
}
/// Nested message and enum types in `HighCapacityRegistryValue`.
pub mod high_capacity_registry_value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// The value that was set in this mutation.
        #[prost(bytes, tag = "1")]
        Value(::prost::alloc::vec::Vec<u8>),
        /// If true, this change represents a deletion.
        #[prost(bool, tag = "3")]
        DeletionMarker(bool),
        /// If the value is too large, this is used instead of the `value` field.
        #[prost(message, tag = "4")]
        LargeValueChunkKeys(super::LargeValueChunkKeys),
    }
}
/// In the not so distant future, this will be used instead of RegistryDelta. See
/// the "Migrating to Large Values/High-Capacity Types" section in the file-level
/// comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighCapacityRegistryDelta {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub values: ::prost::alloc::vec::Vec<HighCapacityRegistryValue>,
}
/// In the not too distant future, this will be used instead of
/// RegistryGetChangesSinceResponse. See the "Migrating to Large
/// Values/High-Capacity Types" section in the file-level comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighCapacityRegistryGetChangesSinceResponse {
    /// If anything went wrong, the registry canister
    /// will set this error.
    #[prost(message, optional, tag = "1")]
    pub error: ::core::option::Option<RegistryError>,
    /// The last version of the registry.
    #[prost(uint64, tag = "2")]
    pub version: u64,
    /// A list of all the keys and all the values that change
    /// and all the intermediate changes since the version
    /// requested.
    #[prost(message, repeated, tag = "3")]
    pub deltas: ::prost::alloc::vec::Vec<HighCapacityRegistryDelta>,
}
/// Message to retrieve all the changes from the registry
/// since 'version'.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegistryGetChangesSinceRequest {
    #[prost(uint64, tag = "1")]
    pub version: u64,
}
/// Message to retrieve a version of some registry key
/// from the registry canister.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegistryGetValueRequest {
    /// The version of the registry key to retrieve.
    /// Optional: If not set (or set to the default value, 0), the method
    /// will return the last version.
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<u64>,
    /// The byte array corresponding to the key to retrieve
    /// from the registry.
    /// Required.
    #[prost(bytes = "vec", tag = "2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
}
/// In the not too distant future, this will be used instead of
/// RegistryGetValueResponse. See the "Migrating to Large Values/High-Capacity
/// Types" section in the file-level comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighCapacityRegistryGetValueResponse {
    /// If anything went wrong, the registry canister
    /// will set this error.
    #[prost(message, optional, tag = "1")]
    pub error: ::core::option::Option<RegistryError>,
    /// the version at which the value corresponding to the queried
    /// key was last mutated (inserted, updated, or deleted)
    /// before at or at the version specified
    /// in the RegistryGetValueRequest.
    #[prost(uint64, tag = "2")]
    pub version: u64,
    /// The timestamp at which the registry mutation happened.
    #[prost(uint64, tag = "5")]
    pub timestamp_nanoseconds: u64,
    #[prost(
        oneof = "high_capacity_registry_get_value_response::Content",
        tags = "3, 4"
    )]
    pub content: ::core::option::Option<high_capacity_registry_get_value_response::Content>,
}
/// Nested message and enum types in `HighCapacityRegistryGetValueResponse`.
pub mod high_capacity_registry_get_value_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// The value retrieved from the registry.
        #[prost(bytes, tag = "3")]
        Value(::prost::alloc::vec::Vec<u8>),
        /// If the value is too large, this will be used instead of the `value`
        /// field.
        #[prost(message, tag = "4")]
        LargeValueChunkKeys(super::LargeValueChunkKeys),
    }
}
/// Message corresponding to the response from the canister
/// to a get_latest_version() request.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegistryGetLatestVersionResponse {
    /// the latest registry version
    #[prost(uint64, tag = "1")]
    pub version: u64,
}
/// In the not too distant future, the `get_certified_changes_since` canister
/// method will use this instead of RegistryMutation. However, there is no
/// intention for the `atomic_mutate` canister method to ever use this. See the
/// "Migrating to Large Values/High-Capacity Types" section in the file-level
/// comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighCapacityRegistryMutation {
    /// The type of the mutation to apply to the registry.
    /// Always required.
    #[prost(enumeration = "registry_mutation::Type", tag = "1")]
    pub mutation_type: i32,
    /// The key of the entry to mutate in the registry.
    /// Always required.
    #[prost(bytes = "vec", tag = "2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "high_capacity_registry_mutation::Content", tags = "3, 4")]
    pub content: ::core::option::Option<high_capacity_registry_mutation::Content>,
}
/// Nested message and enum types in `HighCapacityRegistryMutation`.
pub mod high_capacity_registry_mutation {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// The value to mutate in the registry.
        /// Required for insert, update, but not for delete.
        #[prost(bytes, tag = "3")]
        Value(::prost::alloc::vec::Vec<u8>),
        /// If the value is too large, this will be used instead of the `value`
        /// field.
        #[prost(message, tag = "4")]
        LargeValueChunkKeys(super::LargeValueChunkKeys),
    }
}
/// In the not too distant future, the `get_certified_changes_since` canister
/// method will use this instead of RegistryAtomicMutateRequest. However, there
/// is no intention for the `atomic_mutate` canister method to ever use this. See
/// the "Migrating to Large Values/High-Capacity Types" section in the file-level
/// comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HighCapacityRegistryAtomicMutateRequest {
    /// The set of mutations to apply to the registry.
    #[prost(message, repeated, tag = "1")]
    pub mutations: ::prost::alloc::vec::Vec<HighCapacityRegistryMutation>,
    /// Preconditions at the key level.
    #[prost(message, repeated, tag = "5")]
    pub preconditions: ::prost::alloc::vec::Vec<Precondition>,
    /// The timestamp at which the registry atomic mutate request happened.
    #[prost(uint64, tag = "6")]
    pub timestamp_nanoseconds: u64,
}
/// A single mutation in the registry.
#[derive(candid::CandidType, candid::Deserialize, Eq, Clone, PartialEq, ::prost::Message)]
pub struct RegistryMutation {
    /// The type of the mutation to apply to the registry.
    /// Always required.
    #[prost(enumeration = "registry_mutation::Type", tag = "1")]
    pub mutation_type: i32,
    /// The key of the entry to mutate in the registry.
    /// Always required.
    #[prost(bytes = "vec", tag = "2")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// The value to mutate in the registry.
    /// Required for insert, update, but not for delete.
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `RegistryMutation`.
pub mod registry_mutation {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Type {
        /// Key is expected to not exist in the registry at the current version.
        /// (This includes the case of a key that has existed in the past and
        /// later got deleted).
        /// The mutation will fail otherwise.
        Insert = 0,
        /// Key is expected to exist in the registry at the current version.
        /// The mutation will fail otherwise.
        Update = 1,
        /// Key is expected to exist in the registry at the current version.
        /// The mutation will fail otherwise.
        Delete = 2,
        /// If the key does not exist at the current version, it will be created.
        /// Otherwise, the value will be updated. The name is common in the
        /// database world, and means Update or Insert.
        Upsert = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Insert => "INSERT",
                Self::Update => "UPDATE",
                Self::Delete => "DELETE",
                Self::Upsert => "UPSERT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INSERT" => Some(Self::Insert),
                "UPDATE" => Some(Self::Update),
                "DELETE" => Some(Self::Delete),
                "UPSERT" => Some(Self::Upsert),
                _ => None,
            }
        }
    }
}
/// A precondition on the version at which the value of a given key was
/// last mutated.
#[derive(candid::CandidType, candid::Deserialize, Eq, Clone, PartialEq, ::prost::Message)]
pub struct Precondition {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// The precondition is satisfied if and only is the version in the
    /// RegistryValue for the key is equal to this.
    #[prost(uint64, tag = "2")]
    pub expected_version: u64,
}
/// Deprecated for `get_certified_changes_since` responses; instead, use
/// HighCapacityRegistryAtomicMutateRequest. See the "Migrating to Large
/// Values/High-Capacity Types" section in the file-level comments.
///
/// This is NOT deprecated for `atomic_mutate` requests though!
///
/// Message corresponding to a list of mutations to apply, atomically, to the
/// registry canister. If any of the mutations fails, the whole operation will fail.
#[derive(candid::CandidType, candid::Deserialize, Eq, Clone, PartialEq, ::prost::Message)]
pub struct RegistryAtomicMutateRequest {
    /// The set of mutations to apply to the registry.
    #[prost(message, repeated, tag = "1")]
    pub mutations: ::prost::alloc::vec::Vec<RegistryMutation>,
    /// Preconditions at the key level.
    #[prost(message, repeated, tag = "5")]
    pub preconditions: ::prost::alloc::vec::Vec<Precondition>,
}
/// Message corresponding to the response of an atomic_mutate request. If any of
/// mutations failed the corresponding errors will be reflected in 'errors'.
/// Otherwise 'version' will contain the version under which all the mutations
/// were applied.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegistryAtomicMutateResponse {
    /// If anything went wrong, the registry canister
    /// will set this error.
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<RegistryError>,
    /// The last version of the registry.
    #[prost(uint64, tag = "2")]
    pub version: u64,
}
/// Message encoding a response to any *_certified method call.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CertifiedResponse {
    /// The hash tree encoding both the response and the intermediate
    /// nodes required to recompute the root hash stored in
    /// "certified_data" of the canister.
    ///
    /// Note that the contents of the tree depends on the type of request
    /// issued.
    #[prost(message, optional, tag = "1")]
    pub hash_tree: ::core::option::Option<::ic_protobuf::messaging::xnet::v1::MixedHashTree>,
    /// The certificate obtained from the system using
    /// ic0.data_certificate_copy.
    #[prost(bytes = "vec", tag = "2")]
    pub certificate: ::prost::alloc::vec::Vec<u8>,
}
