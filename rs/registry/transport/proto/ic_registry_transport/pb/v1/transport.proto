syntax = "proto3";

// Set of messages used to interact with the registry canister.
//
// The registry canister implements the following three methods:
//
// get_latest_version(RegistryGetLatestVersionRequest) ->
// RegistryGetLatestVersionResponse
//
// get_value(RegistryGetValueRequest) -> RegistryGetValueResponse
//
// atomic_mutate(RegistryAtomicMutateRequest) -> RegistryAtomicMutateResponse
//
// get_latest_version() returns the latest version of the registry, i.e. the
// version of the last update made to the registry.
//
// get_value() returns the a value for specified version of a specified key from
// the registry, or the latest version if a version was not specified.
// get_value() returns a RegistryError if the key was not present.
//
// atomic_mutate() inserts, updates or deletes a set of keys in the registry.
// Mutations are atomic, meaning either all mutations are applied, or none
// are applied.
//
// Note that registry versions are always strictly >= 0, a -1 value is used
// to signal that no version was assigned.
//
// # High-Capacity Types
//
// At some point we introduced various HighCapacity${T} types, based on existing
// ${T} types. In this section, we call the former "high-capacity" types, and
// the latter "legacy" types. For example, this file used to define
// RegistryValue, and later, HighCapacityRegistryValue was added. High-capacity
// and legacy types existed side by side for a while in order to let clients to
// migrate. That migration has now been completed. See earlier versions of this
// file for a detailed description of the migraiton plan.
//
// As indicated by the name, the difference between these is that HighCapacity
// types allow clients to fetch "large" values from the Registry. Large values
// requrie follow up calls to the Registry's get_chunk method.
//
// Most of the original legacy types have now been removed from this file.
// However, the corresponding legacy Rust types remain for use WITHIN the
// Registry canister (the legacy Rust types have shed support for Protocol
// Buffers encoding and decoding, since they are now only used internally).
//
// ## Secondary Migration/Clean Up
//
// After the migration described above, the legacy types were no longer needed
// here, and most of them have been removed from this file (but as the previous
// section states, the legacy Rust type definitions remain for internal use by
// the Registry canister). Therefore, it is a bit silly for "HighCapacity" to be
// in the name of the remaining types defined here, but now you know why these
// funny names exist. We could try to remove "HighCapacity" from the names of
// these types, but there is no intention to do that. Instead, the plan is to
// simply retain this vestigial naming, since the harm is minimal (sometimes, it
// is better to leave shrapnel in the body, rather than try to remove it).

package ic_registry_transport.pb.v1;

import "google/protobuf/wrappers.proto";
import "messaging/xnet/v1/mixed_hash_tree.proto";

// Message corresponding to an error while performing
// an operation on the registry.
message RegistryError {
  enum Code {
    // The message had a problem like a missing field
    // or a field that was set when it shouldn't.
    MALFORMED_MESSAGE = 0;
    // The 'key' specified on the request was not present
    // in the registry.
    KEY_NOT_PRESENT = 1;
    // The 'key' specified on the request was already present.
    KEY_ALREADY_PRESENT = 2;
    // The 'version' specified in a precondition for a mutation
    // was not the latest version.
    VERSION_NOT_LATEST = 3;
    // The 'version' specified in a precondition for a mutation
    // is beyond the latest version in the registry.
    VERSION_BEYOND_LATEST = 4;

    // The caller is not authorized.
    AUTHORIZATION = 5;

    // A generic internal error occurred in the registry.
    INTERNAL_ERROR = 999;
  }

  Code code = 1;

  // The reason for the error.
  // This is optional.
  string reason = 2;

  // The key on which the error occurred.
  // This is optional and only present for by-key errors.
  bytes key = 3;
}

// When a "monolithic" blob is too large to fit in a single response, this is
// used instead (in the ICP, messages can be at most 2 MiB in size). The
// `get_chunk` canister method can then be called to fetch the original
// monolithic blob in chunks (which can then be cancatenated to reconstitute the
// original monolithic blob).
message LargeValueChunkKeys {
  repeated bytes chunk_content_sha256s = 1;
}

// In the not so distant future, this will be used instead of RegistryValue. See
// the "Migrating to Large Values/High-Capacity Types" section in the file-level
// comments.
message HighCapacityRegistryValue {
  // The version at which this mutation happened.
  uint64 version = 2;

  oneof content {
    // The value that was set in this mutation.
    bytes value = 1;

    // If true, this change represents a deletion.
    bool deletion_marker = 3;

    // If the value is too large, this is used instead of the `value` field.
    LargeValueChunkKeys large_value_chunk_keys = 4;
  }

  // The timestamp at which the registry mutation happened.
  uint64 timestamp_nanoseconds = 5;
}

// In the not so distant future, this will be used instead of RegistryDelta. See
// the "Migrating to Large Values/High-Capacity Types" section in the file-level
// comments.
message HighCapacityRegistryDelta {
  bytes key = 1;
  repeated HighCapacityRegistryValue values = 2;
}

// In the not too distant future, this will be used instead of
// RegistryGetChangesSinceResponse. See the "Migrating to Large
// Values/High-Capacity Types" section in the file-level comments.
message HighCapacityRegistryGetChangesSinceResponse {
  // If anything went wrong, the registry canister
  // will set this error.
  RegistryError error = 1;

  // The last version of the registry.
  uint64 version = 2;

  // A list of all the keys and all the values that change
  // and all the intermediate changes since the version
  // requested.
  repeated HighCapacityRegistryDelta deltas = 3;
}

// Message to retrieve all the changes from the registry
// since 'version'.
message RegistryGetChangesSinceRequest { uint64 version = 1; }

// Message to retrieve a version of some registry key
// from the registry canister.
message RegistryGetValueRequest {
  // The version of the registry key to retrieve.
  // Optional: If not set (or set to the default value, 0), the method
  // will return the last version.
  google.protobuf.UInt64Value version = 1;
  // The byte array corresponding to the key to retrieve
  // from the registry.
  // Required.
  bytes key = 2;
}

// In the not too distant future, this will be used instead of
// RegistryGetValueResponse. See the "Migrating to Large Values/High-Capacity
// Types" section in the file-level comments.
message HighCapacityRegistryGetValueResponse {
  // If anything went wrong, the registry canister
  // will set this error.
  RegistryError error = 1;

  // the version at which the value corresponding to the queried
  // key was last mutated (inserted, updated, or deleted)
  // before at or at the version specified
  // in the RegistryGetValueRequest.
  uint64 version = 2;

  oneof content {
    // The value retrieved from the registry.
    bytes value = 3;

    // If the value is too large, this will be used instead of the `value`
    // field.
    LargeValueChunkKeys large_value_chunk_keys = 4;
  }

  // The timestamp at which the registry mutation happened.
  uint64 timestamp_nanoseconds = 5;
}

// Message corresponding to the response from the canister
// to a get_latest_version() request.
message RegistryGetLatestVersionResponse {
  // the latest registry version
  uint64 version = 1;
}

// In the not too distant future, the `get_certified_changes_since` canister
// method will use this instead of RegistryMutation. However, there is no
// intention for the `atomic_mutate` canister method to ever use this. See the
// "Migrating to Large Values/High-Capacity Types" section in the file-level
// comments.
message HighCapacityRegistryMutation {
  // The type of the mutation to apply to the registry.
  // Always required.
  RegistryMutation.Type mutation_type = 1;

  // The key of the entry to mutate in the registry.
  // Always required.
  bytes key = 2;

  oneof content {
    // The value to mutate in the registry.
    // Required for insert, update, but not for delete.
    bytes value = 3;

    // If the value is too large, this will be used instead of the `value`
    // field.
    LargeValueChunkKeys large_value_chunk_keys = 4;
  }
}

// In the not too distant future, the `get_certified_changes_since` canister
// method will use this instead of RegistryAtomicMutateRequest. However, there
// is no intention for the `atomic_mutate` canister method to ever use this. See
// the "Migrating to Large Values/High-Capacity Types" section in the file-level
// comments.
message HighCapacityRegistryAtomicMutateRequest {
  // The set of mutations to apply to the registry.
  repeated HighCapacityRegistryMutation mutations = 1;

  // Preconditions at the key level.
  repeated Precondition preconditions = 5;

  reserved 4;

  // The timestamp at which the registry atomic mutate request happened.
  uint64 timestamp_nanoseconds = 6;
}

// A single mutation in the registry.
message RegistryMutation {
  enum Type {
    // Key is expected to not exist in the registry at the current version.
    // (This includes the case of a key that has existed in the past and
    // later got deleted).
    // The mutation will fail otherwise.
    INSERT = 0;
    // Key is expected to exist in the registry at the current version.
    // The mutation will fail otherwise.
    UPDATE = 1;
    // Key is expected to exist in the registry at the current version.
    // The mutation will fail otherwise.
    DELETE = 2;
    // If the key does not exist at the current version, it will be created.
    // Otherwise, the value will be updated. The name is common in the
    // database world, and means Update or Insert.
    UPSERT = 4;
  }

  // The type of the mutation to apply to the registry.
  // Always required.
  Type mutation_type = 1;

  // The key of the entry to mutate in the registry.
  // Always required.
  bytes key = 2;

  // The value to mutate in the registry.
  // Required for insert, update, but not for delete.
  bytes value = 3;
}

// A precondition on the version at which the value of a given key was
// last mutated.
message Precondition {
  bytes key = 1;

  // The precondition is satisfied if and only is the version in the
  // RegistryValue for the key is equal to this.
  uint64 expected_version = 2;
}

// Deprecated for `get_certified_changes_since` responses; instead, use
// HighCapacityRegistryAtomicMutateRequest. See the "Migrating to Large
// Values/High-Capacity Types" section in the file-level comments.
//
// This is NOT deprecated for `atomic_mutate` requests though!
//
// Message corresponding to a list of mutations to apply, atomically, to the
// registry canister. If any of the mutations fails, the whole operation will fail.
message RegistryAtomicMutateRequest {
  // The set of mutations to apply to the registry.
  repeated RegistryMutation mutations = 1;

  // Preconditions at the key level.
  repeated Precondition preconditions = 5;

  reserved 4;
}

// Message corresponding to the response of an atomic_mutate request. If any of
// mutations failed the corresponding errors will be reflected in 'errors'.
// Otherwise 'version' will contain the version under which all the mutations
// were applied.
message RegistryAtomicMutateResponse {
  // If anything went wrong, the registry canister
  // will set this error.
  repeated RegistryError errors = 1;
  // The last version of the registry.
  uint64 version = 2;
}

// Message encoding a response to any *_certified method call.
message CertifiedResponse {
  // The hash tree encoding both the response and the intermediate
  // nodes required to recompute the root hash stored in
  // "certified_data" of the canister.
  //
  // Note that the contents of the tree depends on the type of request
  // issued.
  messaging.xnet.v1.MixedHashTree hash_tree = 1;
  // The certificate obtained from the system using
  // ic0.data_certificate_copy.
  bytes certificate = 2;
}
