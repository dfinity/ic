use crate::serialize_and_write_config;
use anyhow::{bail, Context, Result};
use config_types::GuestOSConfig;
#[cfg(feature = "dev")]
use ic_types::malicious_behaviour::MaliciousBehaviour;
use std::env;
use std::fmt::Write as _;
use std::fs::{self, File};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Configuration options for GuestOS bootstrap image/tar creation.
#[derive(Default, Debug, Clone, Eq, PartialEq)]
pub struct BootstrapOptions {
    pub guestos_config: Option<GuestOSConfig>,

    /// Injected crypto state. Should point to a directory containing material
    /// generated by ic-prep. Typically, this is IC_PREP_OUT_PATH/node-X/crypto.
    pub ic_crypto: Option<PathBuf>,

    /// Injected state. Should point to a directory containing a state (with checkpoint)
    /// to start from. Typically, this is IC_PREP_OUT_PATH/node-X/data/ic_state
    pub ic_state: Option<PathBuf>,

    /// Injected initial registry state. Should point to a directory containing
    /// material generated by ic-prep. Typically, this is
    /// IC_PREP_OUT_PATH/ic_registry_local_store
    pub ic_registry_local_store: Option<PathBuf>,

    /// NNS public key file.
    pub nns_public_key: Option<PathBuf>,

    /// Should point to a directory with files containing the authorized ssh
    /// keys for specific user accounts on the machine. The name of the
    /// key designates the name of the account (so, if there is a file
    /// "PATH/admin" then it is transferred to "~admin/.ssh/authorized_keys" on
    /// the target). The presently recognized accounts are: backup, readonly and
    /// admin
    #[cfg(feature = "dev")]
    pub accounts_ssh_authorized_keys: Option<PathBuf>,

    /// Should point to a file containing a Node Provider private key PEM.
    pub node_operator_private_key: Option<PathBuf>,

    /// The IPv6 address to assign. Must include netmask in bits (e.g.
    /// dead:beef::1/64). Overrides all other generation for testing.
    pub ipv6_address: Option<String>,

    /// Default IPv6 gateway.
    pub ipv6_gateway: Option<String>,

    /// The IPv4 address to assign. Must include prefix length (e.g.
    /// 18.208.190.35/28).
    pub ipv4_address: Option<String>,

    /// Default IPv4 gateway (e.g. 18.208.190.33).
    pub ipv4_gateway: Option<String>,

    /// The domain name to assign to the guest.
    pub domain: Option<String>,

    /// The node reward type determines node rewards
    pub node_reward_type: Option<String>,

    /// Name to assign to the host. Will be used in logging.
    pub hostname: Option<String>,

    /// Logging hosts to use.
    pub elasticsearch_hosts: Vec<String>,

    /// Tags to be used by Filebeat.
    pub elasticsearch_tags: Vec<String>,

    /// URL of NNS nodes for sign up or registry access. Can be multiple nodes
    /// separated by commas.
    pub nns_urls: Vec<String>,

    /// How long the backed up consensus artifacts should stay on the spool
    /// before they get purged.
    pub backup_retention_time_sec: Option<u64>,

    /// How often the backup purging should be executed.
    pub backup_purging_interval_sec: Option<u64>,

    /// A JSON-object that describes the malicious behavior activated on
    /// the node. This is only used for testing.
    #[cfg(feature = "dev")]
    pub malicious_behavior: Option<MaliciousBehaviour>,

    /// The length of the epoch in seconds. To be used in
    /// systems tests only.
    #[cfg(feature = "dev")]
    pub query_stats_epoch_length: Option<u64>,

    /// The IP address of a running bitcoind instance. To be used in
    /// systems tests only.
    #[cfg(feature = "dev")]
    pub bitcoind_addr: Option<String>,

    /// The IP address of a running Jaeger Collector instance. To be used in
    /// systems tests only.
    #[cfg(feature = "dev")]
    pub jaeger_addr: Option<String>,

    /// The URL of the socks proxy to use. To be used in
    /// systems tests only.
    #[cfg(feature = "dev")]
    pub socks_proxy: Option<String>,
}

impl BootstrapOptions {
    /// Create a FAT-formatted disk image containing bootstrap configuration.
    ///
    /// Takes all the configuration options specified in BootstrapOptions and packages them into
    /// a disk image that can be mounted by the GuestOS. The image contains a FAT filesystem with
    /// a single file named 'ic-bootstrap.tar' that includes all configuration files.
    pub fn build_bootstrap_config_image(&self, out_file: &Path) -> Result<()> {
        let tmp_dir = tempfile::tempdir().context("Failed to create temporary directory")?;

        // Create bootstrap tar
        let tar_path = tmp_dir.path().join("ic-bootstrap.tar");
        self.build_bootstrap_tar(&tar_path)?;

        let tar_size = fs::metadata(&tar_path)
            .context("Failed to get tar file metadata")?
            .len();

        // Calculate the disk image size (2 * tar_size + 1MB)
        let image_size = 2 * tar_size + 1_048_576;

        // Create an empty file of the calculated size
        let file = File::create(out_file).context("Failed to create output file")?;
        file.set_len(image_size)
            .context("Failed to set output file size")?;

        // Format the disk image as FAT
        // mkfs.vfat is usually in /usr/sbin which is not always in the PATH
        let path_with_usr_sbin = format!("/usr/sbin:{}", env::var("PATH").unwrap_or_default());
        if !Command::new("mkfs.vfat")
            .arg("-n")
            .arg("CONFIG")
            .env("PATH", path_with_usr_sbin)
            .arg(out_file)
            .status()
            .context("Failed to execute mkfs.vfat command")?
            .success()
        {
            bail!("Failed to format disk image");
        }

        // Copy the tar file to the disk image
        if !Command::new("mcopy")
            .arg("-i")
            .arg(out_file)
            .arg("-o")
            .arg(&tar_path)
            .arg("::")
            .status()
            .context("Failed to execute mcopy command")?
            .success()
        {
            bail!("Failed to copy tar to disk image");
        }

        Ok(())
    }

    /// Build a bootstrap tar file with this configuration.
    fn build_bootstrap_tar(&self, out_file: &Path) -> Result<()> {
        // Create temporary directory for bootstrap files
        let bootstrap_dir = tempfile::tempdir().context("Failed to create temporary directory")?;

        if let Some(guestos_config) = &self.guestos_config {
            serialize_and_write_config(&bootstrap_dir.path().join("config.json"), guestos_config)
                .context("Failed to write guestos config to config.json")?;
        }

        if let Some(nns_public_key) = &self.nns_public_key {
            fs::copy(
                nns_public_key,
                bootstrap_dir.path().join("nns_public_key.pem"),
            )
            .context("Failed to copy NNS public key")?;
        }

        if let Some(node_operator_private_key) = &self.node_operator_private_key {
            fs::copy(
                node_operator_private_key,
                bootstrap_dir.path().join("node_operator_private_key.pem"),
            )
            .context("Failed to copy node operator private key")?;
        }

        #[cfg(feature = "dev")]
        if let Some(accounts_ssh_authorized_keys) = &self.accounts_ssh_authorized_keys {
            let target_dir = bootstrap_dir.path().join("accounts_ssh_authorized_keys");
            Self::copy_dir_recursively(accounts_ssh_authorized_keys, &target_dir)
                .context("Failed to copy SSH authorized keys")?;
        }

        if let Some(ic_crypto) = &self.ic_crypto {
            Self::copy_dir_recursively(ic_crypto, &bootstrap_dir.path().join("ic_crypto"))
                .context("Failed to copy IC crypto directory")?;
        }

        if let Some(ic_state) = &self.ic_state {
            if ic_state.exists() {
                Self::copy_dir_recursively(ic_state, &bootstrap_dir.path().join("ic_state"))
                    .context("Failed to copy IC state directory")?;
            }
        }

        if let Some(ic_registry_local_store) = &self.ic_registry_local_store {
            Self::copy_dir_recursively(
                ic_registry_local_store,
                &bootstrap_dir.path().join("ic_registry_local_store"),
            )
            .context("Failed to copy registry local store")?;
        }

        fs::write(
            bootstrap_dir.path().join("network.conf"),
            self.generate_network_conf()?,
        )
        .context("Failed to write network.conf")?;

        if let Some(node_reward_type) = &self.node_reward_type {
            fs::write(
                bootstrap_dir.path().join("reward.conf"),
                format!("node_reward_type={node_reward_type}\n"),
            )
            .context("Failed to write reward.conf")?;
        }

        if !self.elasticsearch_hosts.is_empty() {
            let space_separated_hosts = self.elasticsearch_hosts.join(" ");
            let mut filebeat_config = File::create(bootstrap_dir.path().join("filebeat.conf"))
                .context("Failed to create filebeat.conf")?;

            writeln!(
                filebeat_config,
                "elasticsearch_hosts={space_separated_hosts}"
            )?;
            if !&self.elasticsearch_tags.is_empty() {
                let space_separated_tags = self.elasticsearch_tags.join(" ");
                writeln!(filebeat_config, "elasticsearch_tags={space_separated_tags}")?;
            }
        }

        if !self.nns_urls.is_empty() {
            let comma_separated_urls = self.nns_urls.join(",");
            fs::write(
                bootstrap_dir.path().join("nns.conf"),
                format!("nns_url={comma_separated_urls}\n"),
            )
            .context("Failed to write nns.conf")?;
        }

        if let Some(backup_retention_time) = self.backup_retention_time_sec {
            let mut backup_conf = File::create(bootstrap_dir.path().join("backup.conf"))
                .context("Failed to create backup.conf")?;

            writeln!(
                backup_conf,
                "backup_retention_time_secs={backup_retention_time}"
            )?;

            if let Some(backup_purging_interval) = self.backup_purging_interval_sec {
                writeln!(
                    backup_conf,
                    "backup_puging_interval_secs={backup_purging_interval}"
                )?;
            }
        }

        #[cfg(feature = "dev")]
        if let Some(malicious_behavior) = &self.malicious_behavior {
            fs::write(
                bootstrap_dir.path().join("malicious_behavior.conf"),
                format!(
                    "malicious_behavior={}\n",
                    serde_json::to_string(malicious_behavior)?
                ),
            )
            .context("Failed to write malicious_behavior.conf")?;
        }

        #[cfg(feature = "dev")]
        if let Some(query_stats_epoch_length) = self.query_stats_epoch_length {
            fs::write(
                bootstrap_dir.path().join("query_stats.conf"),
                format!("query_stats_epoch_length={query_stats_epoch_length}\n"),
            )
            .context("Failed to write query_stats.conf")?;
        }

        #[cfg(feature = "dev")]
        if let Some(bitcoind_addr) = &self.bitcoind_addr {
            fs::write(
                bootstrap_dir.path().join("bitcoind_addr.conf"),
                format!("bitcoind_addr={bitcoind_addr}\n"),
            )
            .context("Failed to write bitcoind_addr.conf")?;
        }

        #[cfg(feature = "dev")]
        if let Some(jaeger_addr) = &self.jaeger_addr {
            fs::write(
                bootstrap_dir.path().join("jaeger_addr.conf"),
                format!("jaeger_addr=http://{jaeger_addr}\n"),
            )
            .context("Failed to write jaeger_addr.conf")?;
        }

        #[cfg(feature = "dev")]
        if let Some(socks_proxy) = &self.socks_proxy {
            fs::write(
                bootstrap_dir.path().join("socks_proxy.conf"),
                format!("socks_proxy={socks_proxy}\n"),
            )
            .context("Failed to write socks_proxy.conf")?;
        }

        if !Command::new("tar")
            .arg("cf")
            .arg(out_file)
            .arg("--sort=name")
            .arg("--owner=root:0")
            .arg("--group=root:0")
            .arg("--mtime=UTC 1970-01-01 00:00:00")
            .arg("-C")
            .arg(bootstrap_dir.path())
            .arg(".")
            .status()
            .context("Failed to execute tar command")?
            .success()
        {
            bail!("Failed to create tar file");
        }

        Ok(())
    }

    /// Generate network configuration content.
    fn generate_network_conf(&self) -> Result<String> {
        let mut network_conf = String::new();

        if let Some(ipv6_address) = &self.ipv6_address {
            writeln!(network_conf, "ipv6_address={ipv6_address}")?;
        }

        if let Some(ipv6_gateway) = &self.ipv6_gateway {
            writeln!(network_conf, "ipv6_gateway={ipv6_gateway}")?;
        }

        let hostname = self.hostname.as_deref().unwrap_or_default();
        Self::validate_hostname(hostname)?;
        writeln!(network_conf, "hostname={hostname}",)?;

        if let Some(ipv4_address) = &self.ipv4_address {
            writeln!(network_conf, "ipv4_address={ipv4_address}")?;
        }

        if let Some(ipv4_gateway) = &self.ipv4_gateway {
            writeln!(network_conf, "ipv4_gateway={ipv4_gateway}")?;
        }

        if let Some(domain) = &self.domain {
            writeln!(network_conf, "domain={domain}")?;
        }

        Ok(network_conf)
    }

    fn validate_hostname(hostname_str: &str) -> Result<()> {
        let hostname = hostname_str.as_bytes();
        if hostname.is_empty() {
            return Ok(());
        }

        if hostname.len() > 63 {
            bail!("Hostname too long (must be max 63 bytes): '{hostname_str}'");
        }

        // The first and last character must be alphanumeric, middle characters can be alphanumeric
        // or '-'.
        let valid = hostname[0].is_ascii_alphanumeric()
            && hostname.last().unwrap().is_ascii_alphanumeric()
            && hostname
                .iter()
                .all(|c| c.is_ascii_alphanumeric() || *c == b'-');

        if !valid {
            bail!("Invalid hostname: '{hostname_str}'");
        }

        Ok(())
    }

    fn copy_dir_recursively(src: &Path, dst: &Path) -> Result<()> {
        if !Command::new("cp")
            .arg("-r")
            .arg(src)
            .arg(dst)
            .status()
            .context(format!(
                "Failed to copy {} to {}",
                src.display(),
                dst.display()
            ))?
            .success()
        {
            bail!("Failed to copy {} to {}", src.display(), dst.display());
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use config_types::{DeploymentEnvironment, ICOSSettings, Ipv6Config, NetworkSettings};

    #[test]
    fn test_is_valid_hostname() {
        // Valid hostnames
        assert!(BootstrapOptions::validate_hostname("").is_ok());
        assert!(BootstrapOptions::validate_hostname("h").is_ok());
        assert!(BootstrapOptions::validate_hostname("hostname").is_ok());
        assert!(BootstrapOptions::validate_hostname("hostname123").is_ok());
        assert!(BootstrapOptions::validate_hostname("hostname-part2").is_ok());
        assert!(BootstrapOptions::validate_hostname("h-1-2-3").is_ok());
        assert!(BootstrapOptions::validate_hostname("123hostname").is_ok());

        // Invalid hostnames
        assert!(BootstrapOptions::validate_hostname("hostname-").is_err());
        assert!(BootstrapOptions::validate_hostname("-hostname").is_err());
        assert!(BootstrapOptions::validate_hostname("hostname_invalid").is_err());
        assert!(BootstrapOptions::validate_hostname("hostname with spaces").is_err());
        assert!(BootstrapOptions::validate_hostname(
            "longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglong"
        )
        .is_err());
    }

    #[test]
    fn test_build_bootstrap_config_image_succeeds_with_default_options() {
        let tmp_dir = tempfile::tempdir().unwrap();
        let out_file = tmp_dir.path().join("bootstrap.tar");

        assert!(BootstrapOptions::default()
            .build_bootstrap_config_image(&out_file)
            .is_ok());
    }

    #[test]
    fn test_build_bootstrap_image() -> Result<()> {
        let tmp_dir = tempfile::tempdir()?;
        let out_file = tmp_dir.path().join("bootstrap.img");

        BootstrapOptions {
            hostname: Some("testhostname".to_string()),
            ipv6_address: Some("2001:db8::1/64".to_string()),
            ..Default::default()
        }
        .build_bootstrap_config_image(&out_file)?;

        assert!(out_file.exists());
        assert!(fs::metadata(&out_file)?.len() > 0);

        Ok(())
    }

    #[test]
    fn test_build_bootstrap_tar_with_all_options() -> Result<()> {
        let tmp_dir = tempfile::tempdir()?;
        let out_file = tmp_dir.path().join("bootstrap.tar");

        // Create test files and directories
        let test_files_dir = tmp_dir.path().join("test_files");
        fs::create_dir(&test_files_dir)?;

        let guestos_config = GuestOSConfig {
            config_version: "".to_string(),
            network_settings: NetworkSettings {
                ipv6_config: Ipv6Config::RouterAdvertisement,
                ipv4_config: None,
                domain_name: None,
            },
            icos_settings: ICOSSettings {
                node_reward_type: None,
                mgmt_mac: Default::default(),
                deployment_environment: DeploymentEnvironment::Mainnet,
                logging: Default::default(),
                use_nns_public_key: false,
                nns_urls: vec![],
                use_node_operator_private_key: false,
                enable_trusted_execution_environment: false,
                use_ssh_authorized_keys: false,
                icos_dev_settings: Default::default(),
            },
            guestos_settings: Default::default(),
        };

        let nns_key_path = test_files_dir.join("nns.pem");
        fs::write(&nns_key_path, "test_nns_key")?;

        let node_key_path = test_files_dir.join("node.pem");
        fs::write(&node_key_path, "test_node_key")?;

        let ssh_keys_dir = test_files_dir.join("ssh_keys");
        fs::create_dir(&ssh_keys_dir)?;
        fs::write(ssh_keys_dir.join("key1"), "ssh_key1")?;

        let crypto_dir = test_files_dir.join("crypto");
        fs::create_dir(&crypto_dir)?;
        fs::write(crypto_dir.join("test"), "crypto_data")?;

        let state_dir = test_files_dir.join("state");
        fs::create_dir(&state_dir)?;
        fs::write(state_dir.join("test"), "state_data")?;

        let registry_dir = test_files_dir.join("registry");
        fs::create_dir(&registry_dir)?;
        fs::write(registry_dir.join("test"), "registry_data")?;

        // Create full configuration
        let bootstrap_options = BootstrapOptions {
            hostname: Some("fulltest".to_string()),
            guestos_config: Some(guestos_config.clone()),
            nns_public_key: Some(nns_key_path),
            node_operator_private_key: Some(node_key_path),
            #[cfg(feature = "dev")]
            accounts_ssh_authorized_keys: Some(ssh_keys_dir),
            ic_crypto: Some(crypto_dir),
            ic_state: Some(state_dir),
            ic_registry_local_store: Some(registry_dir),
            ipv6_address: Some("2001:db8::1/64".to_string()),
            ipv6_gateway: Some("2001:db8::ff".to_string()),
            ipv4_address: Some("192.168.1.1/24".to_string()),
            ipv4_gateway: Some("192.168.1.254".to_string()),
            domain: Some("test.domain".to_string()),
            node_reward_type: Some("test_reward".to_string()),
            elasticsearch_hosts: vec!["host1".to_string(), "host2".to_string()],
            elasticsearch_tags: vec!["tag1".to_string(), "tag2".to_string()],
            nns_urls: vec!["url1".to_string(), "url2".to_string()],
            backup_retention_time_sec: Some(3600),
            backup_purging_interval_sec: Some(300),
            #[cfg(feature = "dev")]
            malicious_behavior: Some(MaliciousBehaviour::new(true)),
            #[cfg(feature = "dev")]
            query_stats_epoch_length: Some(60),
            #[cfg(feature = "dev")]
            bitcoind_addr: Some("127.0.0.1:8332".to_string()),
            #[cfg(feature = "dev")]
            jaeger_addr: Some("127.0.0.1:14250".to_string()),
            #[cfg(feature = "dev")]
            socks_proxy: Some("socks5://127.0.0.1:1080".to_string()),
        };

        // Build and extract tar
        bootstrap_options.build_bootstrap_tar(&out_file)?;
        let extract_dir = tmp_dir.path().join("extract");
        fs::create_dir(&extract_dir)?;
        Command::new("tar")
            .arg("xf")
            .arg(&out_file)
            .arg("-C")
            .arg(&extract_dir)
            .status()?;

        // Verify all copied files and directories
        assert_eq!(
            fs::read_to_string(extract_dir.join("config.json"))?,
            serde_json::to_string_pretty(&guestos_config)?
        );
        assert_eq!(
            fs::read_to_string(extract_dir.join("nns_public_key.pem"))?,
            "test_nns_key"
        );
        assert_eq!(
            fs::read_to_string(extract_dir.join("node_operator_private_key.pem"))?,
            "test_node_key"
        );
        assert_eq!(
            fs::read_to_string(extract_dir.join("accounts_ssh_authorized_keys/key1"))?,
            "ssh_key1"
        );
        assert_eq!(
            fs::read_to_string(extract_dir.join("ic_crypto/test"))?,
            "crypto_data"
        );
        assert_eq!(
            fs::read_to_string(extract_dir.join("ic_state/test"))?,
            "state_data"
        );
        assert_eq!(
            fs::read_to_string(extract_dir.join("ic_registry_local_store/test"))?,
            "registry_data"
        );

        let network_conf = fs::read_to_string(extract_dir.join("network.conf"))?;
        assert_eq!(
            network_conf,
            "ipv6_address=2001:db8::1/64\n\
             ipv6_gateway=2001:db8::ff\n\
             hostname=fulltest\n\
             ipv4_address=192.168.1.1/24\n\
             ipv4_gateway=192.168.1.254\n\
             domain=test.domain\n"
        );

        assert_eq!(
            fs::read_to_string(extract_dir.join("reward.conf"))?,
            "node_reward_type=test_reward\n"
        );

        assert_eq!(
            fs::read_to_string(extract_dir.join("filebeat.conf"))?,
            "elasticsearch_hosts=host1 host2\nelasticsearch_tags=tag1 tag2\n"
        );

        assert_eq!(
            fs::read_to_string(extract_dir.join("nns.conf"))?,
            "nns_url=url1,url2\n"
        );

        assert_eq!(
            fs::read_to_string(extract_dir.join("backup.conf"))?,
            "backup_retention_time_secs=3600\nbackup_puging_interval_secs=300\n"
        );

        assert_eq!(
            fs::read_to_string(extract_dir.join("malicious_behavior.conf"))?,
            "malicious_behavior={\"allow_malicious_behaviour\":true,\
        \"maliciously_seg_fault\":false,\
        \"malicious_flags\":{\"maliciously_propose_equivocating_blocks\":false,\
        \"maliciously_propose_empty_blocks\":false,\"maliciously_finalize_all\":false,\
        \"maliciously_notarize_all\":false,\"maliciously_tweak_dkg\":false,\
        \"maliciously_certify_invalid_hash\":false,\
        \"maliciously_malfunctioning_xnet_endpoint\":false,\
        \"maliciously_disable_execution\":false,\"maliciously_corrupt_own_state_at_heights\":[],\
        \"maliciously_disable_ingress_validation\":false,\
        \"maliciously_corrupt_idkg_dealings\":false,\"maliciously_delay_execution\":null,\
        \"maliciously_delay_state_sync\":null,\"maliciously_alter_certified_hash\":false,\
        \"maliciously_alter_state_sync_chunk_sending_side\":false,\
        \"maliciously_alter_state_sync_chunk_receiving_side\":null}}\n"
        );

        assert_eq!(
            fs::read_to_string(extract_dir.join("query_stats.conf"))?,
            "query_stats_epoch_length=60\n"
        );

        assert_eq!(
            fs::read_to_string(extract_dir.join("bitcoind_addr.conf"))?,
            "bitcoind_addr=127.0.0.1:8332\n"
        );

        assert_eq!(
            fs::read_to_string(extract_dir.join("jaeger_addr.conf"))?,
            "jaeger_addr=http://127.0.0.1:14250\n"
        );

        assert_eq!(
            fs::read_to_string(extract_dir.join("socks_proxy.conf"))?,
            "socks_proxy=socks5://127.0.0.1:1080\n"
        );

        Ok(())
    }

    #[test]
    fn ensure_tested_with_dev() {
        // Ensure that the test is run with the dev feature enabled.
        assert!(cfg!(feature = "dev"));
    }
}
