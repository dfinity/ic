use crate::serialize_and_write_config;
use anyhow::{Context, Result, bail};
use config_types::GuestOSConfig;
use std::fs::{self, File};
use std::path::{Path, PathBuf};
use std::process::Command;

/// Configuration options for GuestOS bootstrap image/tar creation.
#[derive(Default, Debug, Clone, Eq, PartialEq)]
pub struct BootstrapOptions {
    pub guestos_config: Option<GuestOSConfig>,

    /// Injected crypto state. Should point to a directory containing material
    /// generated by ic-prep. Typically, this is IC_PREP_OUT_PATH/node-X/crypto.
    pub ic_crypto: Option<PathBuf>,

    /// Injected state. Should point to a directory containing a state (with checkpoint)
    /// to start from. Typically, this is IC_PREP_OUT_PATH/node-X/data/ic_state
    pub ic_state: Option<PathBuf>,

    /// Injected initial registry state. Should point to a directory containing
    /// material generated by ic-prep. Typically, this is
    /// IC_PREP_OUT_PATH/ic_registry_local_store
    pub ic_registry_local_store: Option<PathBuf>,

    /// Path to the PEM-encoded Node Operator private key
    /// Will be filled only for the legacy SetupOS-installed systems
    pub node_operator_private_key: Option<PathBuf>,

    /// Should point to a directory with files containing the authorized ssh
    /// keys for specific user accounts on the machine. The name of the
    /// key designates the name of the account (so, if there is a file
    /// "PATH/admin" then it is transferred to "~admin/.ssh/authorized_keys" on
    /// the target). The presently recognized accounts are: backup, readonly and
    /// admin
    #[cfg(feature = "dev")]
    pub accounts_ssh_authorized_keys: Option<PathBuf>,
}

impl BootstrapOptions {
    /// Create a FAT-formatted disk image containing bootstrap configuration.
    ///
    /// Takes all the configuration options specified in BootstrapOptions and packages them into
    /// a disk image that can be mounted by the GuestOS. The image contains a FAT filesystem with
    /// the configuration files.
    pub fn build_bootstrap_config_image(&self, out_file: &Path) -> Result<()> {
        let tmp_dir = tempfile::tempdir().context("Failed to create temporary directory")?;

        // Create bootstrap directory with all files
        let bootstrap_dir = tmp_dir.path().join("bootstrap");
        fs::create_dir(&bootstrap_dir).context("Failed to create bootstrap directory")?;
        self.populate_bootstrap_dir(&bootstrap_dir)?;

        let dir_size = fs_extra::dir::get_size(&bootstrap_dir)?;
        // image size = 2 * directory size + 1 MB
        let image_size = dir_size * 2 + 1024 * 1024;

        let file = File::create(out_file).context("Failed to create output file")?;
        file.set_len(image_size)
            .context("Failed to set output file size")?;

        // Format the disk image as FAT
        if !Command::new("/usr/sbin/mkfs.vfat")
            .arg("-n")
            .arg("CONFIG")
            .arg(out_file)
            .status()
            .context("Failed to execute mkfs.vfat command")?
            .success()
        {
            bail!("Failed to format disk image");
        }

        // Copy all files from bootstrap directory to the disk image
        Self::copy_dir_to_vfat(&bootstrap_dir, out_file)?;

        Ok(())
    }

    /// Build a bootstrap directory with this configuration.
    /// Returns a TempDir containing all bootstrap files.
    fn populate_bootstrap_dir(&self, bootstrap_dir: &Path) -> Result<()> {
        if let Some(mut guestos_config) = self.guestos_config.clone() {
            // See if there's a node operator key defined on the config.
            // If not - see if there's a fallback path to the file provided
            // and try to load it if it exists.
            if guestos_config
                .icos_settings
                .node_operator_private_key
                .is_none()
                && let Some(v) = &self.node_operator_private_key
                && v.exists()
            {
                let key = fs::read_to_string(v)
                    .context("unable to read Node Operator private key from the file")?;
                guestos_config.icos_settings.node_operator_private_key = Some(key);
            }

            serialize_and_write_config(&bootstrap_dir.join("config.json"), &guestos_config)
                .context("Failed to write guestos config to config.json")?;
        }

        if let Some(ic_crypto) = &self.ic_crypto {
            Self::copy_dir_recursively(ic_crypto, &bootstrap_dir.join("ic_crypto"))
                .context("Failed to copy IC crypto directory")?;
        }

        if let Some(ic_state) = &self.ic_state
            && ic_state.exists()
        {
            Self::copy_dir_recursively(ic_state, &bootstrap_dir.join("ic_state"))
                .context("Failed to copy IC state directory")?;
        }

        if let Some(ic_registry_local_store) = &self.ic_registry_local_store {
            Self::copy_dir_recursively(
                ic_registry_local_store,
                &bootstrap_dir.join("ic_registry_local_store"),
            )
            .context("Failed to copy registry local store")?;
        }

        #[cfg(feature = "dev")]
        {
            if let Some(accounts_ssh_authorized_keys) = &self.accounts_ssh_authorized_keys {
                let target_dir = bootstrap_dir.join("accounts_ssh_authorized_keys");
                Self::copy_dir_recursively(accounts_ssh_authorized_keys, &target_dir)
                    .context("Failed to copy SSH authorized keys")?;
            }
        }

        Ok(())
    }

    /// Copy all files from a directory to a vfat image using mcopy.
    fn copy_dir_to_vfat(src_dir: &Path, vfat_image: &Path) -> Result<()> {
        let all_files = fs::read_dir(src_dir)?
            .map(|entry| Ok(entry?.path()))
            .collect::<Result<Vec<_>>>()
            .context("Failed to collect config directory entries")?;

        let output = Command::new("/usr/bin/mcopy")
            .arg("-i")
            .arg(vfat_image)
            .arg("-s")
            .args(all_files)
            .arg("::/")
            .output()
            .context("Failed to execute mcopy")?;

        if !output.status.success() {
            bail!("Failed to copy directory contents to vfat image. {output:?}");
        }

        Ok(())
    }

    fn copy_dir_recursively(src: &Path, dst: &Path) -> Result<()> {
        if !Command::new("cp")
            .arg("-r")
            .arg(src)
            .arg(dst)
            .status()
            .context(format!(
                "Failed to copy {} to {}",
                src.display(),
                dst.display()
            ))?
            .success()
        {
            bail!("Failed to copy {} to {}", src.display(), dst.display());
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_build_bootstrap_image() -> Result<()> {
        let tmp_dir = tempfile::tempdir()?;
        let out_file = tmp_dir.path().join("bootstrap.img");

        BootstrapOptions::default().build_bootstrap_config_image(&out_file)?;

        assert!(out_file.exists());
        assert!(fs::metadata(&out_file)?.len() > 0);

        Ok(())
    }

    #[test]
    #[cfg(feature = "dev")]
    fn test_populate_bootstrap_dir_with_all_options() -> Result<()> {
        let tmp_dir = tempfile::tempdir()?;
        let bootstrap_dir = tmp_dir.path().join("bootstrap");
        fs::create_dir(&bootstrap_dir)?;

        // Create test files and directories
        let test_files_dir = tmp_dir.path().join("test_files");
        fs::create_dir(&test_files_dir)?;

        let mut guestos_config = GuestOSConfig::default();

        let node_key_path = test_files_dir.join("node.pem");
        fs::write(&node_key_path, "test_node_key")?;

        let node_operator_private_key_path = test_files_dir.join("node_operator_private_key.pem");
        fs::write(
            &node_operator_private_key_path,
            "node_operator_private_key_foo",
        )?;

        let ssh_keys_dir = test_files_dir.join("ssh_keys");
        fs::create_dir(&ssh_keys_dir)?;
        fs::write(ssh_keys_dir.join("key1"), "ssh_key1")?;

        let crypto_dir = test_files_dir.join("crypto");
        fs::create_dir(&crypto_dir)?;
        fs::write(crypto_dir.join("test"), "crypto_data")?;

        let state_dir = test_files_dir.join("state");
        fs::create_dir(&state_dir)?;
        fs::write(state_dir.join("test"), "state_data")?;

        let registry_dir = test_files_dir.join("registry");
        fs::create_dir(&registry_dir)?;
        fs::write(registry_dir.join("test"), "registry_data")?;

        // Create full configuration
        let bootstrap_options = BootstrapOptions {
            guestos_config: Some(guestos_config.clone()),
            node_operator_private_key: Some(node_operator_private_key_path),
            #[cfg(feature = "dev")]
            accounts_ssh_authorized_keys: Some(ssh_keys_dir),
            ic_crypto: Some(crypto_dir),
            ic_state: Some(state_dir),
            ic_registry_local_store: Some(registry_dir),
        };

        bootstrap_options.populate_bootstrap_dir(&bootstrap_dir)?;

        // Set the expected key from the file
        guestos_config.icos_settings.node_operator_private_key =
            Some("node_operator_private_key_foo".to_string());
        let guestos_config_json: GuestOSConfig =
            serde_json::from_slice(&fs::read(bootstrap_dir.join("config.json"))?)?;

        // Verify all copied files and directories
        assert_eq!(guestos_config, guestos_config_json);

        assert_eq!(
            fs::read_to_string(bootstrap_dir.join("accounts_ssh_authorized_keys/key1"))?,
            "ssh_key1"
        );
        assert_eq!(
            fs::read_to_string(bootstrap_dir.join("ic_crypto/test"))?,
            "crypto_data"
        );
        assert_eq!(
            fs::read_to_string(bootstrap_dir.join("ic_state/test"))?,
            "state_data"
        );
        assert_eq!(
            fs::read_to_string(bootstrap_dir.join("ic_registry_local_store/test"))?,
            "registry_data"
        );

        // Check that the image can be created
        let out_file = tmp_dir.path().join("bootstrap.img");
        bootstrap_options.build_bootstrap_config_image(&out_file)?;

        Ok(())
    }

    #[test]
    #[cfg(feature = "dev")]
    fn test_build_bootstrap_dir_node_operator_in_config() -> Result<()> {
        let tmp_dir = tempfile::tempdir()?;
        let bootstrap_dir = tmp_dir.path().join("bootstrap");
        fs::create_dir(&bootstrap_dir)?;

        // Create test files and directories
        let test_files_dir = tmp_dir.path().join("test_files");
        fs::create_dir(&test_files_dir)?;

        let mut guestos_config = GuestOSConfig::default();
        guestos_config.icos_settings.node_operator_private_key =
            Some("node_operator_private_key_from_config".to_string());

        let node_key_path = test_files_dir.join("node.pem");
        fs::write(&node_key_path, "test_node_key")?;

        let node_operator_private_key_path = test_files_dir.join("node_operator_private_key.pem");
        fs::write(
            &node_operator_private_key_path,
            "node_operator_private_key_from_file",
        )?;

        let bootstrap_options = BootstrapOptions {
            guestos_config: Some(guestos_config.clone()),
            node_operator_private_key: Some(node_operator_private_key_path),
            #[cfg(feature = "dev")]
            accounts_ssh_authorized_keys: None,
            ic_crypto: None,
            ic_state: None,
            ic_registry_local_store: None,
        };

        bootstrap_options.populate_bootstrap_dir(&bootstrap_dir)?;

        let guestos_config_json: GuestOSConfig =
            serde_json::from_slice(&fs::read(bootstrap_dir.join("config.json"))?)?;

        // Make sure that the key from the config gets into the resulitng JSON,
        // and not the key from the file.
        assert_eq!(guestos_config, guestos_config_json);

        // Check that the image can be created
        let out_file = tmp_dir.path().join("bootstrap.img");
        bootstrap_options.build_bootstrap_config_image(&out_file)?;

        Ok(())
    }
}
