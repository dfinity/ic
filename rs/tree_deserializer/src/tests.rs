// clippy complains about the code generated by proptest-derive.
#![allow(clippy::unit_arg)]

use crate::{tree_deserializer::*, types::Leb128EncodedU64};
use ic_crypto_tree_hash::{FlatMap, Label, LabeledTree};
use maplit::btreemap;
use proptest::prelude::*;
use proptest_derive::Arbitrary;
use serde::Deserialize;
use std::collections::BTreeMap;

#[derive(Arbitrary, Deserialize, PartialEq, Eq, Debug, PartialOrd, Ord)]
struct Key(String);

#[derive(Arbitrary, Deserialize, PartialEq, Eq, Debug)]
struct Value(u32);

#[derive(Arbitrary, Deserialize, PartialEq, Eq, Debug)]
struct S {
    int32: u32,
    int64: u64,
    string: String,
    map: BTreeMap<Key, Value>,
}

fn decode<'a, T: Deserialize<'a>>(t: &'a LabeledTree<Vec<u8>>) -> Result<T, Error> {
    T::deserialize(LabeledTreeDeserializer::new(t))
}

fn leaf<T: AsRef<[u8]>>(x: T) -> LabeledTree<Vec<u8>> {
    LabeledTree::Leaf(x.as_ref().to_vec())
}

fn fork<L: AsRef<[u8]>>(children: Vec<(L, LabeledTree<Vec<u8>>)>) -> LabeledTree<Vec<u8>> {
    LabeledTree::SubTree(FlatMap::from_key_values(
        children
            .into_iter()
            .map(|(k, v)| (Label::from(k.as_ref()), v))
            .collect(),
    ))
}

fn encode_as_tree(s: &S) -> LabeledTree<Vec<u8>> {
    fork(vec![
        ("int32", leaf(s.int32.to_be_bytes())),
        ("int64", leaf(s.int64.to_be_bytes())),
        ("string", leaf(s.string.as_bytes())),
        (
            "map",
            LabeledTree::SubTree(FlatMap::from_key_values(
                s.map
                    .iter()
                    .map(|(k, v)| (Label::from(k.0.as_bytes()), leaf(v.0.to_be_bytes())))
                    .collect(),
            )),
        ),
    ])
}

#[test]
fn can_decode_tree_into_a_struct() {
    assert_eq!(
        decode::<'_, S>(&fork(vec![
            ("int32", leaf([0, 0, 0, 1])),
            ("int64", leaf([0, 0, 0, 0, 0, 0, 0, 2])),
            ("string", leaf("str")),
            (
                "map",
                fork(vec![("a", leaf([0, 0, 0, 1])), ("b", leaf([0, 0, 0, 2]))])
            ),
        ]))
        .expect("failed to deserialize a struct"),
        S {
            int32: 1,
            int64: 2,
            string: "str".to_string(),
            map: btreemap![
                Key("a".to_string()) => Value(0x01),
                Key("b".to_string()) => Value(0x02),
            ],
        }
    );
}
#[test]
fn can_decode_superset_tree_into_a_struct() {
    assert_eq!(
        decode::<'_, S>(&fork(vec![
            ("int32", leaf([0, 0, 0, 1])),
            ("int64", leaf([0, 0, 0, 0, 0, 0, 0, 2])),
            ("string", leaf("str")),
            (
                "map",
                fork(vec![("a", leaf([0, 0, 0, 1])), ("b", leaf([0, 0, 0, 2]))])
            ),
            ("ignored_field_1", leaf("str")), // Field not present in S
            ("ignored_field_2", leaf("str")), // Field not present in S
        ]))
        .expect("failed to deserialize a struct"),
        S {
            int32: 1,
            int64: 2,
            string: "str".to_string(),
            map: btreemap![
                Key("a".to_string()) => Value(0x01),
                Key("b".to_string()) => Value(0x02),
            ],
        }
    );
}

#[test]
fn can_decode_leb128_encoded_ints() {
    assert_eq!(
        decode::<'_, Leb128EncodedU64>(&leaf([1])),
        Ok(Leb128EncodedU64(1)),
    );

    assert_eq!(
        decode::<'_, Leb128EncodedU64>(&leaf([255, 1])),
        Ok(Leb128EncodedU64(255)),
    );
}

#[test]
#[should_panic(expected = "trailing data")]
fn leb128_decoding_fails_on_trailing_data() {
    decode::<'_, Leb128EncodedU64>(&leaf([0, 0])).unwrap();
}

#[test]
#[should_panic(expected = "overflow")]
fn leb128_decoding_fails_on_integer_overflow() {
    decode::<'_, Leb128EncodedU64>(&leaf([255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0]))
        .unwrap();
}

#[test]
#[should_panic(expected = "missing field")]
fn check_error_on_missing_field() {
    decode::<S>(&fork(vec![("int32", leaf([1, 1, 1, 1]))])).unwrap();
}

#[test]
fn can_collect_leaves() {
    assert_eq!(
        decode::<'_, Vec<u32>>(&fork(vec![
            ("1", leaf([0, 0, 0, 1])),
            ("2", leaf([0, 0, 0, 2])),
            ("3", leaf([0, 0, 0, 3])),
            ("4", leaf([0, 0, 0, 4])),
        ]))
        .expect("failed to deserialize a vector"),
        vec![1, 2, 3, 4]
    );
}

proptest! {
    #[test]
    fn tree_encoding_roundtrip(s in any::<S>()) {
        let t = encode_as_tree(&s);
        let s_decoded = decode(&t).expect("failed to decode a struct");
        assert_eq!(s, s_decoded);
    }
}
