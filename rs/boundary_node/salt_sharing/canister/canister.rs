use std::cell::RefCell;
use std::time::Duration;

use crate::storage::{LAST_SALT_NS, SALT, SALT_SIZE};
use crate::time::delay_till_next_month;
use candid::Principal;
use ic_cdk::{api::time, spawn};
use ic_cdk_macros::{init, post_upgrade, query};
use ic_cdk_timers::set_timer;
use rand_chacha::{
    rand_core::{RngCore, SeedableRng},
    ChaCha20Rng,
};
use salt_api::{GetSaltError, GetSaltResponse, InitArg, SaltGenerationStrategy, SaltResponse};

// A small delay after beginning of the month when salt is generated
const START_OF_MONTH_DELAY: Duration = Duration::from_secs(5);
// Maximum number of attempts to initialize random seed
const MAX_SEED_INIT_ATTEMPTS: i32 = 15;
// Interval between retries to initialize random seed
const SEED_INIT_RETRY_INTERVAL: Duration = Duration::from_secs(10);

thread_local! {
    // Random seed used for salt generation
    static RNG: RefCell<Option<ChaCha20Rng>> = const { RefCell::new(None) };
}

// Run when the canister is first installed
#[init]
fn init(init_arg: InitArg) {
    // Generate salt on the very first init or based on the provided argument.
    if !is_salt_init() || init_arg.regenerate_now {
        seed_rng_and_regenerate_salt(MAX_SEED_INIT_ATTEMPTS, Duration::ZERO);
    }
    // Start salt generation schedule based on the argument.
    if let Some(strategy) = init_arg.salt_generation_strategy {
        schedule_salt_generation(strategy);
    }
    // Start schedule of seeding randomness, if seeding_interval is None, schedule is executed only once.
    let seeding_interval = init_arg.seeding_interval_secs.map(Duration::from_secs);
    schedule_rng_seeding(Duration::ZERO, seeding_interval);
}

// Run every time a canister is upgraded
#[post_upgrade]
fn post_upgrade(init_arg: InitArg) {
    // Run the same initialization logic
    init(init_arg);
}

#[query]
fn get_salt() -> GetSaltResponse {
    get_salt_response()
}

// Fill RNG with pseudorandom bytes generated by the IC
async fn seed_randomness() -> Result<(), String> {
    let (seed,): ([u8; 32],) = ic_cdk::call(Principal::management_canister(), "raw_rand", ())
        .await
        .map_err(|err| {
            format!(
                "call to raw_rand of management canister failed: rejection_code={:?}, message={:?}",
                err.0, err.1
            )
        })?;
    RNG.with_borrow_mut(|rng| *rng = Some(ChaCha20Rng::from_seed(seed)));
    Ok(())
}

// Schedules the seeding of randomness with an optional recurring period.
fn schedule_rng_seeding(delay: Duration, period: Option<Duration>) {
    set_timer(delay, move || {
        spawn(async move {
            if let Err(err) = seed_randomness().await {
                // TODO: substitute with logs
                ic_cdk::println!("Failed to seed randomness {err}");
            }
            // Schedule next seeding
            if let Some(period) = period {
                schedule_rng_seeding(period, Some(period));
            }
        })
    });
}

// Sets an execution timer (delayed future task) and returns immediately.
fn schedule_salt_generation(strategy: SaltGenerationStrategy) {
    match strategy {
        SaltGenerationStrategy::StartOfMonth => {
            // Add a small delay to ensure execution starts after the month started
            let delay = delay_till_next_month(time()) + START_OF_MONTH_DELAY;
            set_timer(delay, || {
                if let Err(err) = regenerate_salt() {
                    // TODO: substitute with logs
                    ic_cdk::println!("Failed to regenerate salt {err}");
                }
                // Function is called recursively to schedule next execution
                schedule_salt_generation(strategy);
            });
        }
    }
}

fn is_salt_init() -> bool {
    SALT.with(|cell| cell.borrow().get(&())).is_some()
        && LAST_SALT_NS.with(|cell| cell.borrow().get(&())).is_some()
}

fn get_salt_response() -> Result<SaltResponse, GetSaltError> {
    let salt = SALT
        .with(|cell| cell.borrow().get(&()))
        .ok_or(GetSaltError::SaltNotInitialized)?;
    // TODO: use ms or secs.
    let salt_id = LAST_SALT_NS
        .with(|cell| cell.borrow_mut().insert((), time()))
        .ok_or(GetSaltError::SaltNotInitialized)?;
    Ok(SaltResponse { salt, salt_id })
}

fn seed_rng_and_regenerate_salt(remaining_attempts: i32, delay: Duration) {
    if remaining_attempts <= 0 {
        return;
    }
    set_timer(delay, move || {
        spawn(async move { try_seed_and_regenerate_salt(remaining_attempts).await });
    });
}

// Attempts to initialize random seed and generate the salt
async fn try_seed_and_regenerate_salt(remaining_attempts: i32) {
    if let Err(err) = seed_randomness().await {
        // TODO: substitute with logs
        ic_cdk::println!("Failed to seed randomness: {err}. Retrying...");
        seed_rng_and_regenerate_salt(remaining_attempts - 1, SEED_INIT_RETRY_INTERVAL);
        return; // Stop further execution to avoid redundant retries
    }

    // This shouldn't fail as seed was set in the previous call.
    if let Err(err) = regenerate_salt() {
        // TODO: substitute with logs
        ic_cdk::println!("Failed to generate salt: {err}. Retrying...");
        seed_rng_and_regenerate_salt(remaining_attempts - 1, SEED_INIT_RETRY_INTERVAL);
    }
}

// Regenerate salt and store it in the stable memory
// Requires an already initialized RNG
fn regenerate_salt() -> Result<(), String> {
    let mut buf = [0u8; SALT_SIZE];
    RNG.with_borrow_mut(|rng| match rng.as_mut() {
        Some(rand) => {
            rand.fill_bytes(&mut buf);
            SALT.with(|cell| {
                cell.borrow_mut().insert((), buf.to_vec());
            });
            LAST_SALT_NS.with(|cell| cell.borrow_mut().insert((), time()));
            Ok(())
        }
        None => Err(String::from("Randomness is yet not initialized.")),
    })
}
