use std::collections::{BTreeMap, HashMap, HashSet};

use crate::storage::StorableIncidentMetadata;
use ic_cdk::api::time;
use rate_limits_api::IncidentId;
use serde_json::{Map, Value};
use sha2::{Digest, Sha256};
use thiserror::Error;

use crate::{
    access_control::{AccessLevel, ResolveAccessLevel},
    state::Repository,
    storage::{StorableConfig, StorableRuleMetadata},
    types::{InputConfig, RuleId, Version},
};

pub const INIT_VERSION: Version = 1;

pub trait AddsConfig {
    fn add_config(&self, config: InputConfig) -> Result<(), AddConfigError>;
}

#[derive(Debug, Error, Clone)]
pub enum RulePolicyError {
    #[error("Rule at index={index} is linked to an already disclosed incident_id={incident_id}")]
    LinkingRuleToDisclosedIncident {
        index: usize,
        incident_id: IncidentId,
    },
    #[error("Rule at index={index} is already linked to an incident_id={incident_id}, attempted to relink to incident_id={incident_id_new}")]
    LinkingRuleToAnotherIncident {
        index: usize,
        incident_id: IncidentId,
        incident_id_new: IncidentId,
    },
    #[error("Rule at index={index} with rule_id={rule_id} was deactivated in version={version}, cannot be resubmitted")]
    DeactivatedRuleResubmission {
        index: usize,
        rule_id: RuleId,
        version: Version,
    },
}

#[derive(Debug, Error, Clone)]
pub enum RuleEncodingError {
    #[error("Rule doesn't encode a valid JSON object")]
    InvalidJsonEncoding,
}

#[derive(Debug, Error)]
pub enum AddConfigError {
    #[error("Not all rules encode valid JSON objects: {0}")]
    RuleEncodingError(#[from] RuleEncodingError),
    #[error("Rule violates policy: {0}")]
    RulePolicyViolation(#[from] RulePolicyError),
    #[error("Unauthorized operation")]
    Unauthorized,
    #[error("An unexpected error occurred: {0}")]
    Unexpected(#[from] anyhow::Error),
}

pub struct ConfigAdder<R, A> {
    pub repository: R,
    pub access_resolver: A,
}

impl<R, A> ConfigAdder<R, A> {
    pub fn new(repository: R, access_resolver: A) -> Self {
        Self {
            repository,
            access_resolver,
        }
    }
}

// Definitions:
// - Each rule has two IDs - rule_id and incident_id (to which a rule is linked)
// - A rule is uniquely identified by rule_id, which is autogenerated by hashing two fields `rule_raw` + `description` (JSON decoded `rule_raw` is used for hashing)
// - incident_id must be provided for each rule by the caller; multiple rules can be linked to one incident_id
// - The same rule (i.e. `rule_raw` + `description`) can be persisted (resubmitted) from one config version to next ones
//   If a rule is not resubmitted to the next config, it is marked as "deactivated" (`removed_in_version` field in `StorableRuleMetadata` is set to Some())
//   - Individual rules or incidents (vector holding multiple rule IDs) can be disclosed
//   - Disclosing individual rules (or incidents) for the second time has no effect further effect
// Policies:
// - Deactivated rules can't be resubmitted again (DeactivatedRuleResubmission error)
// - Newly added rules can't be linked to an already disclosed incident (LinkingRuleToDisclosedIncident error)

impl<R: Repository, A: ResolveAccessLevel> AddsConfig for ConfigAdder<R, A> {
    fn add_config(&self, config: InputConfig) -> Result<(), AddConfigError> {
        // Only privileged users can perform this operation
        if self.access_resolver.get_access_level() != AccessLevel::FullAccess {
            return Err(AddConfigError::Unauthorized);
        }

        let current_version = self
            .repository
            .get_version()
            .unwrap_or(INIT_VERSION.into())
            .0;
        let next_version = current_version + 1;

        // All rule IDs in the submitted config
        let mut rule_ids = Vec::new();
        // Metadata of the newly submitted rules
        let mut new_rules_metadata = Vec::<(RuleId, StorableRuleMetadata)>::new();
        // Hashmap of the newly submitted incident IDs
        let mut new_incidents = HashMap::<IncidentId, Vec<RuleId>>::new();
        // Hashmap of the already existing incident IDs
        let mut existing_incidents = HashMap::<IncidentId, Vec<RuleId>>::new();

        // For each rule:
        // - Validate its correct JSON encoding
        // - Autogenerate rule ID based on hash(JSON encoding + description)
        // - Validate rule submission policies
        for (rule_idx, rule) in config.rules.iter().enumerate() {
            let rule_id = generate_reproducible_id(&rule.rule_raw, &rule.description)?;
            rule_ids.push(rule_id.clone());

            // Check if submitted rule is new
            let existing_rule_metadata = self.repository.get_rule(&rule_id);
            // Check if an incident related to a rule is new
            let existing_related_incident = self.repository.get_incident(&rule.incident_id);

            if let Some(ref metadata) = existing_rule_metadata {
                if let Some(version) = metadata.removed_in_version {
                    Err(AddConfigError::RulePolicyViolation(
                        RulePolicyError::DeactivatedRuleResubmission {
                            index: rule_idx,
                            rule_id: rule_id.clone(),
                            version,
                        },
                    ))?;
                }
                // Check if the rule is relinked to another incident
                if metadata.incident_id != rule.incident_id {
                    Err(AddConfigError::RulePolicyViolation(
                        RulePolicyError::LinkingRuleToAnotherIncident {
                            index: rule_idx,
                            incident_id: metadata.incident_id.clone(),
                            incident_id_new: rule.incident_id.clone(),
                        },
                    ))?;
                }
            } else {
                let rule_metadata = StorableRuleMetadata {
                    incident_id: rule.incident_id.clone(),
                    rule_raw: rule.rule_raw.clone(),
                    description: rule.description.clone(),
                    disclosed_at: None,
                    added_in_version: next_version,
                    removed_in_version: None,
                };
                new_rules_metadata.push((rule_id.clone(), rule_metadata));
            }

            // Rule is linked to an already existing incident
            if let Some(incident) = existing_related_incident {
                // New rule can't be linked to a disclosed incident
                if existing_rule_metadata.is_none() && incident.is_disclosed {
                    Err(AddConfigError::RulePolicyViolation(
                        RulePolicyError::LinkingRuleToDisclosedIncident {
                            index: rule_idx,
                            incident_id: rule.incident_id.clone(),
                        },
                    ))?;
                }
                existing_incidents
                    .entry(rule.incident_id.clone())
                    .and_modify(|value| value.push(rule_id.clone()))
                    .or_insert(vec![rule_id.clone()]);
            } else {
                // Rule is linked to a new incident
                new_incidents
                    .entry(rule.incident_id.clone())
                    .and_modify(|value| value.push(rule_id.clone()))
                    .or_insert(vec![rule_id.clone()]);
            }
        }

        // Commit all changes to stable memory.
        // Note: if any operation below fails canister state can become inconsistent.
        // TODO: maybe it is better to panic to rollback changes

        // Mark deactivated rules
        let _ = self.repository.get_config(current_version).map(|config| {
            let deactivated_ids = find_difference(&config.rule_ids, &rule_ids);
            deactivated_ids.iter().for_each(|rule_id| {
                if let Some(mut metadata) = self.repository.get_rule(rule_id) {
                    metadata.removed_in_version = Some(next_version);
                    let _ = self.repository.update_rule(rule_id.clone(), metadata);
                }
            });
        });

        for (rule_id, metadata) in new_rules_metadata.iter().cloned() {
            if !self.repository.add_rule(rule_id.clone(), metadata) {
                return Err(AddConfigError::Unexpected(anyhow::anyhow!(
                    "rule_id={rule_id} already existed, failed to add rule"
                )));
            }
        }

        for (incident_id, rule_ids) in new_incidents {
            let incident_metadata = StorableIncidentMetadata {
                is_disclosed: false,
                rule_ids,
            };
            if !self
                .repository
                .add_incident(incident_id.clone(), incident_metadata)
            {
                return Err(AddConfigError::Unexpected(anyhow::anyhow!(
                    "incident_id={incident_id} already exists, failed to add incident"
                )));
            }
        }

        for (incident_id, rule_ids) in existing_incidents {
            let incident_metadata = StorableIncidentMetadata {
                is_disclosed: false,
                rule_ids,
            };
            if !self
                .repository
                .update_incident(incident_id.clone(), incident_metadata)
            {
                return Err(AddConfigError::Unexpected(anyhow::anyhow!(
                    "incident={incident_id} doesn't exist, failed to update"
                )));
            }
        }

        let storable_config = StorableConfig {
            schema_version: config.schema_version,
            active_since: time(),
            rule_ids,
        };

        if !self.repository.add_config(next_version, storable_config) {
            return Err(AddConfigError::Unexpected(anyhow::anyhow!(
                "Config for version {next_version} already exists, failed to add"
            )));
        }

        Ok(())
    }
}

fn generate_reproducible_id(
    rule_raw: &[u8],
    description: &str,
) -> Result<RuleId, RuleEncodingError> {
    let json_value = serde_json::from_slice::<Value>(rule_raw)
        .map_err(|_| RuleEncodingError::InvalidJsonEncoding)?;

    let canonical_json = canonicalize_json(&json_value)?;
    let canonical_json_bytes =
        serde_json::to_vec(&canonical_json).map_err(|_| RuleEncodingError::InvalidJsonEncoding)?;

    let mut hasher = Sha256::new();

    hasher.update(canonical_json_bytes);
    hasher.update(description.as_bytes());

    let result = hasher.finalize();

    let rule_id = hex::encode(result);

    Ok(rule_id)
}

fn canonicalize_json(value: &Value) -> Result<Value, RuleEncodingError> {
    match value {
        Value::Object(map) => {
            let mut sorted_map = BTreeMap::new();
            for (k, v) in map {
                sorted_map.insert(k.clone(), canonicalize_json(v)?);
            }
            let map: Map<String, Value> = sorted_map.into_iter().collect();
            Ok(Value::Object(map))
        }
        Value::Array(arr) => {
            let canonicalized_array: Result<Vec<Value>, _> =
                arr.iter().map(canonicalize_json).collect();
            Ok(Value::Array(canonicalized_array?))
        }
        _ => Ok(value.clone()),
    }
}

fn find_difference<T: Eq + std::hash::Hash + Clone>(v1: &[T], v2: &[T]) -> Vec<T> {
    let set2: HashSet<_> = v2.iter().collect();
    v1.iter()
        .filter(|&item| !set2.contains(item))
        .cloned()
        .collect()
}

impl From<AddConfigError> for String {
    fn from(value: AddConfigError) -> Self {
        value.to_string()
    }
}
