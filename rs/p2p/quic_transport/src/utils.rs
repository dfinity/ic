//! Quic Transport utilities.
//!
//! Contains the actual wire format used for messages.
//! Request encoding of Request<Bytes> into HttpRequest protobuf.
//! Response encoding Response<Bytes> into HttpResponse protobuf.
use anyhow::{anyhow, Context};
use axum::{
    body::{Body, HttpBody},
    extract::State,
    http::{Method, Request, Response, Version},
    middleware::Next,
};
use bytes::Bytes;
use ic_protobuf::transport::v1 as pb;
use prost::Message;
use quinn::{RecvStream, SendStream};

use crate::metrics::QuicTransportMetrics;

/// On purpose the value is big, otherwise there is risk of not processing important consensus messages.
/// E.g. summary blocks generated by the consensus protocol for 40 node subnet can be bigger than 5MB.
const MAX_MESSAGE_SIZE_BYTES: usize = 128 * 1024 * 1024;

pub(crate) async fn read_request(
    mut recv_stream: RecvStream,
) -> Result<Request<Body>, anyhow::Error> {
    let raw_msg = recv_stream
        .read_to_end(MAX_MESSAGE_SIZE_BYTES)
        .await
        .with_context(|| "Failed to read request from the stream.")?;

    let request_proto = pb::HttpRequest::decode(raw_msg.as_slice())
        .with_context(|| "Failed to decode http request.")?;

    let mut request = Request::builder()
        .method(match pb::HttpMethod::try_from(request_proto.method) {
            Ok(pb::HttpMethod::Get) => Method::GET,
            Ok(pb::HttpMethod::Post) => Method::POST,
            Ok(pb::HttpMethod::Put) => Method::PUT,
            Ok(pb::HttpMethod::Delete) => Method::DELETE,
            Ok(pb::HttpMethod::Head) => Method::HEAD,
            Ok(pb::HttpMethod::Options) => Method::OPTIONS,
            Ok(pb::HttpMethod::Connect) => Method::CONNECT,
            Ok(pb::HttpMethod::Patch) => Method::PATCH,
            Ok(pb::HttpMethod::Trace) => Method::TRACE,
            Ok(pb::HttpMethod::Unspecified) => {
                return Err(anyhow!("received http method unspecified."));
            }
            Err(e) => {
                return Err(anyhow!("received invalid method {}", e));
            }
        })
        .version(Version::HTTP_3)
        .uri(request_proto.uri);
    for h in request_proto.headers {
        let pb::HttpHeader { key, value } = h;
        request = request.header(key, value);
    }
    // This consumes the body without requiring allocation or cloning the whole content.
    let body_bytes = Bytes::from(request_proto.body);
    request
        .body(Body::from(body_bytes))
        .with_context(|| "Failed to build request.")
}

pub(crate) async fn read_response(
    mut recv_stream: RecvStream,
) -> Result<Response<Bytes>, anyhow::Error> {
    let raw_msg = recv_stream
        .read_to_end(MAX_MESSAGE_SIZE_BYTES)
        .await
        .with_context(|| "Failed to read response from the stream.")?;

    let response_proto = pb::HttpResponse::decode(raw_msg.as_slice())
        .with_context(|| "Failed to decode response header.")?;

    let status: u16 = match response_proto.status_code.try_into() {
        Ok(status) => status,
        Err(e) => {
            return Err(anyhow!(
                "Received invalid status code {} {}",
                response_proto.status_code,
                e
            ))
        }
    };

    let mut response = Response::builder().status(status).version(Version::HTTP_3);
    for h in response_proto.headers {
        let pb::HttpHeader { key, value } = h;
        response = response.header(key, value);
    }
    // This consumes the body without requiring allocation or cloning the whole content.
    let body_bytes = Bytes::from(response_proto.body);
    response
        .body(body_bytes)
        .with_context(|| "Failed to build response.")
}

pub(crate) async fn write_request(
    send_stream: &mut SendStream,
    request: Request<Bytes>,
) -> Result<(), anyhow::Error> {
    let (parts, body) = request.into_parts();

    let request_proto = pb::HttpRequest {
        uri: String::from(parts.uri.path()),
        headers: parts
            .headers
            .into_iter()
            .filter_map(|(k, v)| {
                k.map(|k| pb::HttpHeader {
                    key: k.to_string(),
                    value: v.as_bytes().to_vec(),
                })
            })
            .collect(),
        method: match parts.method {
            Method::GET => pb::HttpMethod::Get.into(),
            Method::POST => pb::HttpMethod::Post.into(),
            Method::PUT => pb::HttpMethod::Put.into(),
            Method::DELETE => pb::HttpMethod::Delete.into(),
            Method::HEAD => pb::HttpMethod::Head.into(),
            Method::OPTIONS => pb::HttpMethod::Options.into(),
            Method::CONNECT => pb::HttpMethod::Connect.into(),
            Method::PATCH => pb::HttpMethod::Patch.into(),
            Method::TRACE => pb::HttpMethod::Trace.into(),
            _ => return Err(anyhow!("invalid method")),
        },
        body: body.into(),
    };

    let request_bytes = request_proto.encode_to_vec();
    send_stream
        .write_all(&request_bytes)
        .await
        .with_context(|| "Failed to write request to stream.")?;
    Ok(())
}

pub(crate) async fn write_response(
    send_stream: &mut SendStream,
    response: Response<Body>,
) -> Result<(), anyhow::Error> {
    let (parts, body) = response.into_parts();
    // Check for axum error in body
    // TODO: Think about this. What is the error that can happen here?
    let body = axum::body::to_bytes(body, MAX_MESSAGE_SIZE_BYTES)
        .await
        .with_context(|| "Failed to read response from body.")?;
    let response_proto = pb::HttpResponse {
        status_code: parts.status.as_u16().into(),
        headers: parts
            .headers
            .into_iter()
            .filter_map(|(k, v)| {
                k.map(|k| ic_protobuf::transport::v1::HttpHeader {
                    key: k.to_string(),
                    value: v.as_bytes().to_vec(),
                })
            })
            .collect(),
        body: body.into(),
    };

    let response_bytes = response_proto.encode_to_vec();
    send_stream
        .write_all(&response_bytes)
        .await
        .with_context(|| "Failed to write request to stream.")?;
    Ok(())
}

/// Axum middleware to collect metrics
pub(crate) async fn collect_metrics(
    State(state): State<QuicTransportMetrics>,
    request: Request<Body>,
    next: Next,
) -> axum::response::Response {
    state
        .request_handle_bytes_received_total
        .with_label_values(&[request.uri().path()])
        .inc_by(request.body().size_hint().lower());
    let _timer = state
        .request_handle_duration_seconds
        .with_label_values(&[request.uri().path()])
        .start_timer();
    let out_counter = state
        .request_handle_bytes_sent_total
        .with_label_values(&[request.uri().path()]);
    let response = next.run(request).await;
    out_counter.inc_by(response.body().size_hint().lower());
    response
}
