//! Quic Transport utilities.
//!
//! Contains the actual wire format used for messages.
//! Request encoding of Request<Bytes> into HttpRequest protobuf.
//! Response encoding Response<Bytes> into HttpResponse protobuf.
use std::{
    cmp::Reverse,
    collections::{BTreeMap, BinaryHeap, HashMap},
};

use anyhow::{anyhow, Context};
use axum::{
    body::{Body, HttpBody},
    extract::State,
    http::{Method, Request, Response, Version},
    middleware::Next,
};
use bytes::{Buf, BufMut, Bytes, BytesMut};
use ic_protobuf::transport::v1 as pb;
use prost::Message;
use quinn::{Chunk, ClosedStream, RecvStream, SendStream, StoppedError, VarInt, WriteError};
use reed_solomon_simd::ReedSolomonDecoder;

use crate::metrics::QuicTransportMetrics;

/// On purpose the value is big, otherwise there is risk of not processing important consensus messages.
/// E.g. summary blocks generated by the consensus protocol for 40 node subnet can be bigger than 5MB.
const MAX_MESSAGE_SIZE_BYTES: usize = 128 * 1024 * 1024;

#[derive(Debug, Clone, Copy)]
struct EcHeader {
    len: u32,
    scheme: (u32, u32),
    padding: u32,
}

#[derive(Default)]
struct Assembler {
    header: Option<EcHeader>,
    partial_messages: HashMap<usize, BinaryHeap<(Reverse<usize>, Bytes)>>,
    full_messages: BTreeMap<usize, Bytes>,
}

impl Assembler {
    const CHUNK_SIZE: usize = 1280;
    const EC_HEADER_SIZE: usize = 16;
    const MSG_SIZE: usize = Self::CHUNK_SIZE + Self::EC_HEADER_SIZE;
    fn add_chunk(&mut self, offset: usize, mut bytes: Bytes) -> bool {
        let mut pos = offset;
        while !bytes.is_empty() {
            let ec_idx = pos / Self::MSG_SIZE;
            // offset is at chunk boundary
            let c = if pos % Self::MSG_SIZE == 0 {
                if bytes.len() < Self::MSG_SIZE {
                    pos += bytes.len();
                    let b = bytes.split_to(bytes.len());
                    assert!(bytes.is_empty());
                    b
                } else {
                    pos += Self::MSG_SIZE;
                    assert!(pos % Self::MSG_SIZE == 0);
                    let chunk = bytes.split_to(Self::MSG_SIZE);
                    assert!(chunk.len() == Self::MSG_SIZE);
                    chunk
                }
            } else {
                let dist_to_next_ec = Self::MSG_SIZE - (pos % Self::MSG_SIZE);
                if bytes.len() < dist_to_next_ec {
                    pos += bytes.len();
                    let b = bytes.split_to(bytes.len());
                    assert!(bytes.is_empty());
                    b
                } else {
                    pos += dist_to_next_ec;
                    assert!(pos % Self::MSG_SIZE == 0);
                    bytes.split_to(dist_to_next_ec)
                }
            };
            let e = self.partial_messages.entry(ec_idx).or_default();
            e.push((Reverse(pos), c));

            let sum = e.iter().map(|c| c.1.len()).sum::<usize>();
            assert!(sum <= Self::MSG_SIZE);

            // Entry contains complete chunk
            if sum == Self::MSG_SIZE {
                let mut bm = BytesMut::new();
                while let Some((Reverse(_), s)) = e.pop() {
                    bm.extend_from_slice(&s);
                }

                let mut ec_header = bm.split_off(bm.len() - Self::EC_HEADER_SIZE);
                if self.header.is_none() {
                    self.header = Some(EcHeader {
                        len: ec_header.get_u32(),
                        scheme: (ec_header.get_u32(), ec_header.get_u32()),
                        padding: ec_header.get_u32(),
                    });
                }
                self.full_messages.insert(ec_idx, bm.freeze());
            }
        }
        self.header
            .is_some_and(|h| h.scheme.0 <= self.full_messages.len() as u32)
    }
    fn assemble(self) -> Bytes {
        let header = self.header.unwrap();
        let mut decoder = ReedSolomonDecoder::new(
            header.scheme.0 as usize,
            header.scheme.1 as usize,
            Self::CHUNK_SIZE,
        )
        .unwrap();

        for (idx, data) in &self.full_messages {
            if *idx < header.scheme.0 as usize {
                decoder.add_original_shard(*idx, data).unwrap();
            } else {
                decoder
                    .add_recovery_shard(idx - header.scheme.0 as usize, data)
                    .unwrap();
            }
        }
        let missing_data_shards = decoder.decode().unwrap();

        let mut data = BytesMut::zeroed(header.len as usize + header.padding as usize);
        for (idx, d) in self
            .full_messages
            .into_iter()
            .filter(|(idx, _)| *idx < header.scheme.0 as usize)
        {
            let idx = idx * Assembler::CHUNK_SIZE;
            data[idx..idx + d.len()].copy_from_slice(&d)
        }
        for (idx, d) in missing_data_shards.restored_original_iter() {
            let idx = idx * Assembler::CHUNK_SIZE;
            data[idx..idx + d.len()].copy_from_slice(d)
        }
        let a = data.split_to(data.len() - header.padding as usize);

        assert_eq!(a.len(), header.len as usize);

        a.freeze()
    }

    fn split_message(mut bytes: Vec<u8>) -> Vec<Bytes> {
        let len_bytes = bytes.len();
        let padding = Self::CHUNK_SIZE - bytes.len() % Self::CHUNK_SIZE;
        bytes.resize(Self::CHUNK_SIZE * bytes.len().div_ceil(Self::CHUNK_SIZE), 0);
        assert!(bytes.len() % Self::CHUNK_SIZE == 0);
        let data_shards = std::cmp::max(1, bytes.len() / Self::CHUNK_SIZE);
        let parity_shards = std::cmp::max(1, data_shards / 2);
        bytes.resize(data_shards * Self::CHUNK_SIZE, 0);
        let shards: Vec<_> = bytes.chunks(Self::CHUNK_SIZE).collect();
        let parity = reed_solomon_simd::encode(data_shards, parity_shards, &shards).unwrap();
        let ecs: Vec<Bytes> = shards
            .into_iter()
            .chain(parity.iter().map(|x| x.as_slice()))
            .map(|x| {
                let mut b = BytesMut::new();
                b.extend_from_slice(x);
                b.put_u32(len_bytes as u32);
                b.put_u32(data_shards as u32);
                b.put_u32(parity_shards as u32);
                b.put_u32(padding as u32);
                b.freeze()
            })
            .collect();
        ecs
    }
}

async fn assemble(mut recv_stream: RecvStream) -> Result<Bytes, anyhow::Error> {
    let mut assembler = Assembler::default();
    while let Some(Chunk { offset, bytes }) = recv_stream
        .read_chunk(MAX_MESSAGE_SIZE_BYTES, false)
        .await?
    {
        if assembler.add_chunk(offset as usize, bytes) {
            recv_stream.stop(VarInt::from_u32(1)).unwrap();
            return Ok(assembler.assemble());
        }
    }

    panic!("ah")
}

async fn disassemble(send_stream: &mut SendStream, bytes: Vec<u8>) -> Result<(), anyhow::Error> {
    let mut ecs = Assembler::split_message(bytes);
    let write_result = send_stream.write_all_chunks(&mut ecs).await;
    match write_result {
        Ok(()) => {}
        Err(WriteError::Stopped(int)) if int == VarInt::from_u32(1) => {}
        Err(e) => return Err(e.into()),
    };
    let finish_result = send_stream.finish();
    match finish_result {
        Ok(()) => Ok::<(), anyhow::Error>(()),
        Err(e) => Err(e.into()),
    }?;
    let stopped_result = send_stream.stopped().await.map_err(|err| err);
    match stopped_result {
        Ok(None) => Ok(()),
        Ok(Some(int)) if int == VarInt::from_u32(1) => Ok(()),
        Ok(Some(_)) => Ok(()),
        Err(e) => Err(e.into()),
    }
}

pub(crate) async fn read_request(recv_stream: RecvStream) -> Result<Request<Body>, anyhow::Error> {
    let mut raw_msg = assemble(recv_stream)
        .await
        .with_context(|| "Failed to read request from the stream.")?;

    let request_proto =
        pb::HttpRequest::decode(&mut raw_msg).with_context(|| "Failed to decode http request.")?;

    let mut request = Request::builder()
        .method(match pb::HttpMethod::try_from(request_proto.method) {
            Ok(pb::HttpMethod::Get) => Method::GET,
            Ok(pb::HttpMethod::Post) => Method::POST,
            Ok(pb::HttpMethod::Put) => Method::PUT,
            Ok(pb::HttpMethod::Delete) => Method::DELETE,
            Ok(pb::HttpMethod::Head) => Method::HEAD,
            Ok(pb::HttpMethod::Options) => Method::OPTIONS,
            Ok(pb::HttpMethod::Connect) => Method::CONNECT,
            Ok(pb::HttpMethod::Patch) => Method::PATCH,
            Ok(pb::HttpMethod::Trace) => Method::TRACE,
            Ok(pb::HttpMethod::Unspecified) => {
                return Err(anyhow!("received http method unspecified."));
            }
            Err(e) => {
                return Err(anyhow!("received invalid method {}", e));
            }
        })
        .version(Version::HTTP_3)
        .uri(request_proto.uri);
    for h in request_proto.headers {
        let pb::HttpHeader { key, value } = h;
        request = request.header(key, value);
    }
    // This consumes the body without requiring allocation or cloning the whole content.
    let body_bytes = Bytes::from(request_proto.body);
    request
        .body(Body::from(body_bytes))
        .with_context(|| "Failed to build request.")
}

pub(crate) async fn read_response(
    recv_stream: RecvStream,
) -> Result<Response<Bytes>, anyhow::Error> {
    let mut raw_msg = assemble(recv_stream)
        .await
        .with_context(|| "Failed to read response from the stream.")?;

    let response_proto = pb::HttpResponse::decode(&mut raw_msg)
        .with_context(|| "Failed to decode response header.")?;

    let status: u16 = match response_proto.status_code.try_into() {
        Ok(status) => status,
        Err(e) => {
            return Err(anyhow!(
                "Received invalid status code {} {}",
                response_proto.status_code,
                e
            ))
        }
    };

    let mut response = Response::builder().status(status).version(Version::HTTP_3);
    for h in response_proto.headers {
        let pb::HttpHeader { key, value } = h;
        response = response.header(key, value);
    }
    // This consumes the body without requiring allocation or cloning the whole content.
    let body_bytes = Bytes::from(response_proto.body);
    response
        .body(body_bytes)
        .with_context(|| "Failed to build response.")
}

pub(crate) async fn write_request(
    mut send_stream: SendStream,
    request: Request<Bytes>,
) -> Result<(), anyhow::Error> {
    let (parts, body) = request.into_parts();

    let request_proto = pb::HttpRequest {
        uri: String::from(parts.uri.path()),
        headers: parts
            .headers
            .into_iter()
            .filter_map(|(k, v)| {
                k.map(|k| pb::HttpHeader {
                    key: k.to_string(),
                    value: v.as_bytes().to_vec(),
                })
            })
            .collect(),
        method: match parts.method {
            Method::GET => pb::HttpMethod::Get.into(),
            Method::POST => pb::HttpMethod::Post.into(),
            Method::PUT => pb::HttpMethod::Put.into(),
            Method::DELETE => pb::HttpMethod::Delete.into(),
            Method::HEAD => pb::HttpMethod::Head.into(),
            Method::OPTIONS => pb::HttpMethod::Options.into(),
            Method::CONNECT => pb::HttpMethod::Connect.into(),
            Method::PATCH => pb::HttpMethod::Patch.into(),
            Method::TRACE => pb::HttpMethod::Trace.into(),
            _ => return Err(anyhow!("invalid method")),
        },
        body: body.into(),
    };

    let res = request_proto.encode_to_vec();
    disassemble(&mut send_stream, res).await
}

pub(crate) async fn write_response(
    mut send_stream: &mut SendStream,
    response: Response<Body>,
) -> Result<(), anyhow::Error> {
    let (parts, body) = response.into_parts();
    // Check for axum error in body
    // TODO: Think about this. What is the error that can happen here?
    let body = axum::body::to_bytes(body, MAX_MESSAGE_SIZE_BYTES)
        .await
        .with_context(|| "Failed to read response from body.")?;
    let response_proto = pb::HttpResponse {
        status_code: parts.status.as_u16().into(),
        headers: parts
            .headers
            .into_iter()
            .filter_map(|(k, v)| {
                k.map(|k| ic_protobuf::transport::v1::HttpHeader {
                    key: k.to_string(),
                    value: v.as_bytes().to_vec(),
                })
            })
            .collect(),
        body: body.into(),
    };
    let res = response_proto.encode_to_vec();
    disassemble(&mut send_stream, res).await
}

/// Axum middleware to collect metrics
pub(crate) async fn collect_metrics(
    State(state): State<QuicTransportMetrics>,
    request: Request<Body>,
    next: Next,
) -> axum::response::Response {
    state
        .request_handle_bytes_received_total
        .with_label_values(&[request.uri().path()])
        .inc_by(request.body().size_hint().lower());
    let _timer = state
        .request_handle_duration_seconds
        .with_label_values(&[request.uri().path()])
        .start_timer();
    let out_counter = state
        .request_handle_bytes_sent_total
        .with_label_values(&[request.uri().path()]);
    let response = next.run(request).await;
    out_counter.inc_by(response.body().size_hint().lower());
    response
}

#[cfg(test)]
mod tests {
    use rand::{seq::SliceRandom, thread_rng};

    use super::*;
    #[test]
    fn tt() {
        let vals: Vec<u8> = (0..100000_u64).map(|v| (7 * v * v * v) as u8).collect();

        let mut data: Vec<(usize, Bytes)> = Assembler::split_message(vals.clone())
            .into_iter()
            .enumerate()
            .map(|(i, d)| (i * d.len(), d))
            .collect();
        data.shuffle(&mut thread_rng());

        let mut assembler = Assembler::default();
        for (offset, d) in data {
            if assembler.add_chunk(offset, d) {
                let reasseblmed = assembler.assemble();
                assert_eq!(reasseblmed, vals);
                return;
            }
        }
        unreachable!()
    }
}
