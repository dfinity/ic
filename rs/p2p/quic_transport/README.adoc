
= Transport = 
:toc:

== Overview ==

The IC Transport layer enables message delivery between nodes within a subnet.

== Requirements ==

[cols="3,3,3"]
|===
| **Capability**
| **Purpose**
| **Implementation Requirement**

| RPC-like library
| Simplifies application development by abstracting communication between nodes, allowing developers to focus on application logic instead of low-level networking.
| Ensure https://en.wikipedia.org/wiki/Reliability_(computer_networking)[reliable data delivery] so the sender can confirm successful message delivery to the recipient.

| Multitenancy of applications
| Enables multiple applications to safely share the library, ensuring isolation and uninterrupted operation across applications.
| Support https://en.wikipedia.org/wiki/Multiplexing[multiplexing] to independently route messages to their endpoints, unaffected by packet losses or delays impacting other messages.

| Operates in P2P networks with Byzantine peers
| Supports deployment in real-world environments, including networks with faulty or malicious nodes.
| Implement https://en.wikipedia.org/wiki/Flow_control_(data)[flow control] to manage the number of connections, inflight messages, and streams per connection, ensuring stability and resilience.

| Scalable and resource-efficient
| Optimizes usage of shared resources (e.g., CPU, file descriptors) to maintain performance under high demand and prevent resource exhaustion.
| Utilize https://en.wikipedia.org/wiki/Connection-oriented_communication[connection-oriented communication] (e.g., a single persistent connection) to minimize overhead from repeated TLS handshakes or excessive connections between peers.

|===

== Architecture ==

Transport is devided into two logical parts - sending and receiving.

For the sending side, transport exposes the `+rpc+` API call. 

Transport uses https://docs.rs/anyhow/latest/anyhow/struct.Error.html[anyhow::Error] instead of https://docs.rs/thiserror/latest/thiserror/derive.Error.html[thiserror::Error] as the error type 
because the errors are transient and it is expected that the user retries on failure.

How do you make sure there are only transient errors? For example, how do you ruled out

* Invalid arguments - Invalid arguments are prevented from making it to the transport methods by using the type system.
* Internal, unknown errors - By definition, internal errors can't be handled meaningfully by the caller. Transport desides if it should crash the process or just propagate the error with the expectations that the user will retry.

[source, rust]
----
    async fn rpc(&self, peer_id: &NodeId, request: Request<Bytes>) -> Result<Response<Bytes>, anyhow::Error>;
----

The receiving side, is a collection of callbacks, called handlers. Each possible URI is associated with a single handler. 
When a message is received by transport, a handler is chosen using the URI and invoked with the payload (a.k.a. routing).

=== Handlers ===

A handler implements an async interface. This implies that a handler must satisfy all Tokio requirements for async code.
Some handlers may use synchronous APIs that block the running thread for longer periods of time (>100 microseconds). 
In order to make request processing https://docs.rs/tokio/latest/tokio/task/index.html[non-blocking], the handler can use a https://docs.rs/threadpool/latest/threadpool/[threadpool] and https://docs.rs/tokio/latest/tokio/sync/oneshot/index.html[Tokio oneshot channel] for communicating the result back.
Job execution starts in the threadpool iff the parent task was not cancelled.
A nice writeup about async and blocking operations can be found in https://ryhl.io/blog/async-what-is-blocking/[Alice Ryhl's blog post].

== Implementation design decisions ==

1. Use QUIC to satisfy the first two requirements ("Reliable data delivery" and "Multiplexing").
2. Open a new QUIC stream for each message, instead of one stream per handler/URI. TODO: explain.
3. Handlers are always ready to process messages, hence the router is always ready to accept streams. TODO: explain.

=== Breaking dependency cycles in P2P protocols ===

Many P2P protocol designs use a single TCP/UDP connection between any two peers. The main benefit is less consumption of limited resources (e.g. CPU for TLS handshake, file descriptors for sockets).
Such protocols that use a single connection for inbound and outbound traffic, with a designated listener and dialer, have circular dependency between the read and write paths.

There are different approaches to breaking this dependency.

1. Clients of the P2P protocol have a single event loop that drives the outbound traffic. Hence only those event loops need access to the `+QuicTransport+` object. 
In this model, handlers can have a channel to the main event loop. Effectively this means that P2P clients are instantiated in two stages 1. creating the receive side router and 2. creating the send side event loop.

2. An alternative is instead of splitting the creation of P2P clients into send and receive sides to split the creation of the `+QuicTransport+` in two - 
creating the `+QuicTransport+` object (client side) and starting the `+QuicTransport+` event loop for establishing connections(server side). 
This approach enables the handlers to do most of the work and potentially eliminates the need for the event loop from the first approach. However, this comes at the cost of having a more shared state and contention. 
One possible implementation using this approach is to have weak references to the transport object that can be used directly in the handlers. 
As a result, when there are handlers that take the weak reference the transport object needs first to be instantiated and later started with the already constructed router.

3. Another alternative is to allow the `+QuicTransport+` to update the routes dynamically. In this case, once a connection is established it is unnatural to change the available routes from a client PoV.

=== Unused QUIC/QUINN abstraction ===

* `+QuicTransport+` doesn't send nor receive datagrams because they are not reliably delivered.
* `+QuicTransport+` doesn't use uni-directional streams. One possible situation where uni-directional
stream may make sense if a handler is infallible. Since each route and the corresponding handler is given by a client,
if a route is missing it should not be considered a failure in transport.
For comparison, https://grpc.io/docs/what-is-grpc/core-concepts/#rpc-life-cycle[all `+gRPC+` methods contain a response from the application receive side].
In addition, no +gRPC+ implementation will return https://grpc.github.io/grpc/core/md_doc_statuscodes.html[`+NOT_FOUND+`],
which is the most appropriate return code if a route is missing.

=== Using HTTP request/response as API types ===

gRPC implementations use Interface Definition Language (IDL) for describing both the service interface and the structure of the payload messages.
Since the QUIC transport is a lightweight library, no IDL is used. 

The QUIC transport library directly exposes the HTTP request and response to the client instead of introducing a custom type that wraps the payload.
There are two main reasons for this design decision:

* Reuse the HTTP request and response types to keep the code compact. This also eliminates the need to implement https://docs.rs/axum/latest/axum/index.html#extractors[extractors].
* Existing HTTP client-server can be transitioned more easily to the QUIC transport. For example, the server router can be completely reused; request building and response handling on the client stay unchanged.
