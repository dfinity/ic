// DFN-467: clippy complains about the code generated by derive(Arbitrary)
#![cfg_attr(test, allow(clippy::unit_arg))]
//! Defines the [`Time`] type used by the Internet Computer.

#[cfg(test)]
mod tests;

use ic_constants::{MAX_INGRESS_TTL, PERMITTED_DRIFT};
#[cfg(test)]
use proptest_derive::Arbitrary;
use serde::{Deserialize, Serialize};
use std::convert::TryFrom;
use std::fmt;
use std::time::{Duration, SystemTime};
use thiserror::Error;

/// Time since UNIX_EPOCH (in nanoseconds). Just like 'std::time::Instant' or
/// 'std::time::SystemTime', [Time] does not implement the [Default] trait.
/// Please use `ic_test_utilities::mock_time` if you ever need such a value.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash, Serialize, Deserialize)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct Time(u64);

/// The unix epoch.
pub const UNIX_EPOCH: Time = Time(0);

/// The Genesis launch timestamp.
/// Corresponds to 2021-05-06T19:17:10 UTC
pub const GENESIS: Time = Time::from_nanos_since_unix_epoch(1_620_328_630_000_000_000);

const NANOS_PER_MILLI: u64 = 1_000_000;

impl std::ops::Add<Duration> for Time {
    type Output = Time;
    fn add(self, dur: Duration) -> Time {
        Time::from_duration(Duration::from_nanos(self.0) + dur)
    }
}

impl std::ops::AddAssign<Duration> for Time {
    fn add_assign(&mut self, other: Duration) {
        *self = Time::from_duration(Duration::from_nanos(self.0) + other)
    }
}

impl std::ops::Sub<Time> for Time {
    type Output = Duration;

    fn sub(self, other: Time) -> Duration {
        let lhs = Duration::from_nanos(self.0);
        let rhs = Duration::from_nanos(other.0);
        lhs - rhs
    }
}

impl std::ops::Sub<Duration> for Time {
    type Output = Time;

    fn sub(self, other: Duration) -> Time {
        let time = Duration::from_nanos(self.0);
        Time::from_duration(time - other)
    }
}

impl Time {
    /// Number of nanoseconds since UNIX EPOCH
    pub fn as_nanos_since_unix_epoch(self) -> u64 {
        self.0
    }

    pub const fn from_nanos_since_unix_epoch(nanos: u64) -> Self {
        Time(nanos)
    }

    /// Number of milliseconds since UNIX EPOCH
    pub fn as_millis_since_unix_epoch(self) -> u64 {
        self.as_nanos_since_unix_epoch() / NANOS_PER_MILLI
    }

    pub fn from_millis_since_unix_epoch(millis: u64) -> Result<Self, TimeInstantiationError> {
        millis
            .checked_mul(NANOS_PER_MILLI )
            .map(Time)
            .ok_or_else(|| {
                TimeInstantiationError::Overflow(format!(
                    "The number of milliseconds {} is too large and cannot be converted into a u64 of nanoseconds",
                    millis
                ))
            })
    }

    /// A private function to cast from [Duration] to [Time].
    fn from_duration(t: Duration) -> Self {
        Time(t.as_nanos() as u64)
    }

    /// Checked `Time` addition. Computes `self + rhs`, returning [`None`]
    /// if overflow occurred.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use ic_types::Time;
    ///
    /// assert_eq!(Time::from_nanos_since_unix_epoch(0).checked_add(Time::from_nanos_since_unix_epoch(1)), Some(Time::from_nanos_since_unix_epoch(1)));
    /// assert_eq!(Time::from_nanos_since_unix_epoch(1).checked_add(Time::from_nanos_since_unix_epoch(u64::MAX)), None);
    /// ```
    pub const fn checked_add(self, rhs: Time) -> Option<Time> {
        if let Some(result) = self.0.checked_add(rhs.0) {
            Some(Time(result))
        } else {
            None
        }
    }

    /// Checked `Time` addition with a `Duration`. Computes `self + rhs`, returning [`None`]
    /// if overflow occurred.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use std::time::Duration;
    /// use ic_types::Time;
    ///
    /// assert_eq!(Time::from_nanos_since_unix_epoch(0).checked_add_duration(Duration::from_nanos(1)), Some(Time::from_nanos_since_unix_epoch(1)));
    /// assert_eq!(Time::from_nanos_since_unix_epoch(0).checked_add_duration(Duration::MAX), None);
    /// assert_eq!(Time::from_nanos_since_unix_epoch(1).checked_add_duration(Duration::from_nanos(u64::MAX)), None);
    /// ```
    pub fn checked_add_duration(self, rhs: Duration) -> Option<Time> {
        if let Ok(rhs_time) = Time::try_from(rhs) {
            self.checked_add(rhs_time)
        } else {
            None
        }
    }
}

#[derive(Error, Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum TimeInstantiationError {
    #[error("Time cannot be instantiated as it would overflow: {0}")]
    Overflow(String),
}

impl TryFrom<Duration> for Time {
    type Error = TimeInstantiationError;
    fn try_from(d: Duration) -> Result<Self, Self::Error> {
        u64::try_from(d.as_nanos())
            .map_err(|_| {
                TimeInstantiationError::Overflow(
                    "Duration is too large to be converted into a u64 of nanoseconds!".to_string(),
                )
            })
            .map(Time)
    }
}

impl From<Time> for Duration {
    fn from(val: Time) -> Self {
        Duration::from_nanos(val.0)
    }
}

impl TryFrom<SystemTime> for Time {
    type Error = TimeInstantiationError;

    /// Performs conversion from `SystemTime` to `Time`.
    ///
    /// # Panics
    ///
    /// The function panics when `duration_since(UNIX_EPOCH)` fails,
    /// i.e. when the `SystemTime` measurement is earlier than the
    /// `UNIX_EPOCH`.
    fn try_from(st: SystemTime) -> Result<Self, Self::Error> {
        st.duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .try_into()
    }
}

impl From<Time> for SystemTime {
    fn from(t: Time) -> Self {
        SystemTime::UNIX_EPOCH + Duration::from(t)
    }
}

#[cfg(not(all(target_arch = "wasm32", target_os = "unknown")))]
impl fmt::Display for Time {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use chrono::{TimeZone, Utc};

        match self.0.try_into() {
            Ok(signed) => write!(f, "{}", Utc.timestamp_nanos(signed)),
            Err(_) => write!(f, "{}ns", self.0),
        }
    }
}

#[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
impl fmt::Display for Time {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}ns", self.0)
    }
}

/// Returns the current time.
///
/// WARNING: this function should not be used in any deterministic part of the
/// IC as it accesses system time, which is non-deterministic between nodes.
pub fn current_time() -> Time {
    let start = std::time::SystemTime::now();
    let since_epoch = start
        .duration_since(std::time::UNIX_EPOCH)
        .expect("Time wrapped around");
    UNIX_EPOCH + since_epoch
}

/// A utility function to help set the expiry time when creating an
/// SignedIngress message from scratch.  Returns the current time and expiry
/// time.  The expiry time is set from the current system time + the maximum
/// amount of time ingress messages are allowed to stay alive for - 60 seconds.
///
/// Subtracting 60 seconds is because this uses the system time and not the
/// block time. The block time is going to lag behind the system time by
/// some amount, so if you don't subtract you have an expiry time that is too
/// far in the future when the expiry time is compared against block_time +
/// MAX_INGRESS_TTL, and the message will be rejected.
///
/// 60 seconds is hopefully enough leeway.
///
///
/// WARNING: this function should not be used in any deterministic part of the
/// IC as it accesses system time, which is non-deterministic between nodes.
//
// This function is made public to be able to use it for testing purposes.
pub fn current_time_and_expiry_time() -> (Time, Time) {
    let start = std::time::SystemTime::now();
    let since_epoch = start
        .duration_since(std::time::UNIX_EPOCH)
        .expect("Time wrapped around");
    (
        UNIX_EPOCH + since_epoch,
        UNIX_EPOCH + (since_epoch + MAX_INGRESS_TTL - PERMITTED_DRIFT),
    )
}
