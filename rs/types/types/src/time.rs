// DFN-467: clippy complains about the code generated by derive(Arbitrary)
#![cfg_attr(test, allow(clippy::unit_arg))]
//! Defines the [`Time`] type used by the Internet Computer.

#[cfg(test)]
mod tests;

use ic_constants::{MAX_INGRESS_TTL, PERMITTED_DRIFT};
#[cfg(test)]
use ic_exhaustive_derive::ExhaustiveSet;
#[cfg(test)]
use proptest_derive::Arbitrary;
use serde::{Deserialize, Serialize};
use std::convert::TryFrom;
use std::fmt;
use std::time::{Duration, SystemTime};
use thiserror::Error;

/// Time since UNIX_EPOCH (in nanoseconds). Just like 'std::time::Instant' or
/// 'std::time::SystemTime', [Time] does not implement the [Default] trait.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash, Serialize, Deserialize)]
#[cfg_attr(test, derive(Arbitrary, ExhaustiveSet))]
pub struct Time(u64);

/// The unix epoch.
pub const UNIX_EPOCH: Time = Time(0);

/// The Genesis launch timestamp.
/// Corresponds to 2021-05-06T19:17:10 UTC
pub const GENESIS: Time = Time::from_nanos_since_unix_epoch(1_620_328_630_000_000_000);

const NANOS_PER_MILLI: u64 = 1_000_000;
const NANOS_PER_SEC: u64 = 1_000_000_000;

impl std::ops::Add<Duration> for Time {
    type Output = Time;
    fn add(self, dur: Duration) -> Time {
        Time::from_duration(Duration::from_nanos(self.0) + dur)
    }
}

impl std::ops::AddAssign<Duration> for Time {
    fn add_assign(&mut self, other: Duration) {
        *self = Time::from_duration(Duration::from_nanos(self.0) + other)
    }
}

impl Time {
    /// Number of nanoseconds since `UNIX EPOCH`.
    pub fn as_nanos_since_unix_epoch(self) -> u64 {
        self.0
    }

    pub const fn from_nanos_since_unix_epoch(nanos: u64) -> Self {
        Time(nanos)
    }

    /// Number of milliseconds since `UNIX EPOCH`.
    pub fn as_millis_since_unix_epoch(self) -> u64 {
        self.as_nanos_since_unix_epoch() / NANOS_PER_MILLI
    }

    pub fn from_millis_since_unix_epoch(millis: u64) -> Result<Self, TimeInstantiationError> {
        millis
            .checked_mul(NANOS_PER_MILLI )
            .map(Time)
            .ok_or_else(|| {
                TimeInstantiationError::Overflow(format!(
                    "The number of milliseconds {} is too large and cannot be converted into a u64 of nanoseconds",
                    millis
                ))
            })
    }

    /// Number of seconds since `UNIX EPOCH`.
    pub fn as_secs_since_unix_epoch(self) -> u64 {
        self.as_nanos_since_unix_epoch() / NANOS_PER_SEC
    }

    pub fn from_secs_since_unix_epoch(secs: u64) -> Result<Self, TimeInstantiationError> {
        secs.checked_mul(NANOS_PER_SEC)
            .map(Time)
            .ok_or_else(|| {
                TimeInstantiationError::Overflow(format!(
                    "The number of seconds {} is too large and cannot be converted into a u64 of nanoseconds",
                    secs
                ))
            })
    }

    /// A private function to cast from [Duration] to [Time].
    fn from_duration(t: Duration) -> Self {
        Time(t.as_nanos() as u64)
    }

    /// Checked `Time` addition with a `Duration`. Computes `self + rhs`, returning [`None`]
    /// if overflow occurred.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use ic_types::Time;
    /// use std::time::Duration;
    ///
    /// assert_eq!(Time::from_nanos_since_unix_epoch(0).checked_add(Duration::from_nanos(1)), Some(Time::from_nanos_since_unix_epoch(1)));
    /// assert_eq!(Time::from_nanos_since_unix_epoch(0).checked_add(Duration::MAX), None);
    /// assert_eq!(Time::from_nanos_since_unix_epoch(1).checked_add(Duration::from_nanos(u64::MAX)), None);
    /// ```
    pub fn checked_add(self, rhs: Duration) -> Option<Time> {
        if let Ok(rhs_nanos) = u64::try_from(rhs.as_nanos()) {
            Some(Time(self.0.checked_add(rhs_nanos)?))
        } else {
            None
        }
    }

    /// Checked `Time` subtraction. Computes `self - rhs`, returning [`None`]
    /// if underflow occurs.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use ic_types::Time;
    /// use std::time::Duration;
    ///
    /// assert_eq!(Time::from_nanos_since_unix_epoch(3).checked_duration_since(Time::from_nanos_since_unix_epoch(2)), Some(Duration::from_nanos(1)));
    /// assert_eq!(Time::from_nanos_since_unix_epoch(2).checked_duration_since(Time::from_nanos_since_unix_epoch(3)), None);
    /// ```
    pub const fn checked_duration_since(self, rhs: Time) -> Option<Duration> {
        if let Some(result) = self.0.checked_sub(rhs.0) {
            Some(Duration::from_nanos(result))
        } else {
            None
        }
    }

    /// Checked `Time` subtraction with a `Duration`. Computes `self - rhs`,
    /// returning [`None`] if underflow occurs.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use ic_types::Time;
    /// use std::time::Duration;
    ///
    /// assert_eq!(Time::from_nanos_since_unix_epoch(3).checked_sub(Duration::from_nanos(2)), Some(Time::from_nanos_since_unix_epoch(1)));
    /// assert_eq!(Time::from_nanos_since_unix_epoch(2).checked_sub(Duration::from_nanos(3)), None);
    /// ```
    pub fn checked_sub(self, rhs: Duration) -> Option<Time> {
        if let Ok(rhs_nanos) = u64::try_from(rhs.as_nanos()) {
            Some(Time(self.0.checked_sub(rhs_nanos)?))
        } else {
            None
        }
    }

    /// Saturating `Time` subtraction. Computes `self - rhs`, returning
    /// `Duration::from_nanos(0)` if underflow occurs.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use ic_types::Time;
    /// use std::time::Duration;
    ///
    /// assert_eq!(Time::from_nanos_since_unix_epoch(3).saturating_duration_since(Time::from_nanos_since_unix_epoch(2)), Duration::from_nanos(1));
    /// assert_eq!(Time::from_nanos_since_unix_epoch(2).saturating_duration_since(Time::from_nanos_since_unix_epoch(3)), Duration::from_nanos(0));
    /// ```
    pub const fn saturating_duration_since(self, rhs: Time) -> Duration {
        Duration::from_nanos(self.0.saturating_sub(rhs.0))
    }

    /// Saturating `Duration` subtraction from a `Time`. Computes `self - rhs`,
    /// returning `Time::from_nanos_since_unix_epoch(0)` if underflow occurs.
    ///
    /// # Examples
    ///
    /// Basic usage:
    ///
    /// ```
    /// use ic_types::Time;
    /// use std::time::Duration;
    ///
    /// assert_eq!(Time::from_nanos_since_unix_epoch(3).saturating_sub(Duration::from_nanos(2)), Time::from_nanos_since_unix_epoch(1));
    /// assert_eq!(Time::from_nanos_since_unix_epoch(2).saturating_sub(Duration::from_nanos(3)), Time::from_nanos_since_unix_epoch(0));
    /// ```
    pub fn saturating_sub(self, rhs: Duration) -> Time {
        if let Ok(rhs_nanos) = u64::try_from(rhs.as_nanos()) {
            Time(self.0.saturating_sub(rhs_nanos))
        } else {
            Time(0)
        }
    }
}

#[derive(Error, Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum TimeInstantiationError {
    #[error("Time cannot be instantiated as it would overflow: {0}")]
    Overflow(String),
}

impl TryFrom<Duration> for Time {
    type Error = TimeInstantiationError;
    fn try_from(d: Duration) -> Result<Self, Self::Error> {
        u64::try_from(d.as_nanos())
            .map_err(|_| {
                TimeInstantiationError::Overflow(
                    "Duration is too large to be converted into a u64 of nanoseconds!".to_string(),
                )
            })
            .map(Time)
    }
}

impl From<Time> for Duration {
    fn from(val: Time) -> Self {
        Duration::from_nanos(val.0)
    }
}

impl TryFrom<SystemTime> for Time {
    type Error = TimeInstantiationError;

    /// Performs conversion from `SystemTime` to `Time`.
    ///
    /// # Panics
    ///
    /// The function panics when `duration_since(UNIX_EPOCH)` fails,
    /// i.e. when the `SystemTime` measurement is earlier than the
    /// `UNIX_EPOCH`.
    fn try_from(st: SystemTime) -> Result<Self, Self::Error> {
        st.duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .try_into()
    }
}

impl From<Time> for SystemTime {
    fn from(t: Time) -> Self {
        SystemTime::UNIX_EPOCH + Duration::from(t)
    }
}

#[cfg(not(all(target_arch = "wasm32", target_os = "unknown")))]
impl fmt::Display for Time {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use chrono::{TimeZone, Utc};

        match self.0.try_into() {
            Ok(signed) => write!(f, "{}", Utc.timestamp_nanos(signed)),
            Err(_) => write!(f, "{}ns", self.0),
        }
    }
}

#[cfg(all(target_arch = "wasm32", target_os = "unknown"))]
impl fmt::Display for Time {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}ns", self.0)
    }
}

/// Returns the current time.
///
/// WARNING: this function should not be used in any deterministic part of the
/// IC as it accesses system time, which is non-deterministic between nodes.
pub fn current_time() -> Time {
    let start = std::time::SystemTime::now();
    let since_epoch = start
        .duration_since(std::time::UNIX_EPOCH)
        .expect("Time wrapped around");
    UNIX_EPOCH + since_epoch
}

/// A utility function that returns an expiry time when creating an
/// SignedIngress message from scratch.
/// The expiry time is set from the current system time + the maximum
/// amount of time ingress messages are allowed to stay alive for - 60 seconds.
///
/// Subtracting 60 seconds is because this uses the system time and not the
/// block time. The block time is going to lag behind the system time by
/// some amount, so if you don't subtract you have an expiry time that is too
/// far in the future when the expiry time is compared against block_time +
/// MAX_INGRESS_TTL, and the message will be rejected.
///
/// 60 seconds is hopefully enough leeway.
///
///
/// WARNING: this function should not be used in any deterministic part of the
/// IC as it accesses system time, which is non-deterministic between nodes.
pub fn expiry_time_from_now() -> Time {
    let start = std::time::SystemTime::now();
    let since_epoch = start
        .duration_since(std::time::UNIX_EPOCH)
        .expect("Time wrapped around");

    UNIX_EPOCH + (since_epoch + MAX_INGRESS_TTL - PERMITTED_DRIFT)
}

/// Time since `UNIX_EPOCH`, in seconds.
///
/// Only intended for storing and passing around low resolution timestamps.
/// For any time arithmetic or pretty printing, convert to `Time` first. Like
/// `Time`, does not implement the `Default` trait.
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash, Serialize, Deserialize)]
#[cfg_attr(test, derive(ExhaustiveSet))]
pub struct CoarseTime(u32);

impl CoarseTime {
    pub const fn from_secs_since_unix_epoch(seconds: u32) -> Self {
        Self(seconds)
    }

    /// Returns a `CoarseTime` obtained by rounding `time` down to an integer second.
    ///
    /// If the result would exceed `u32::MAX` (`2106-02-07T06:28:15`), it is replaced
    /// by `u32::MAX`.
    pub const fn floor(time: Time) -> Self {
        Self::from_u64_seconds(time.0 / NANOS_PER_SEC)
    }

    /// Returns a `CoarseTime` obtained by rounding `time` toward the closest integer
    /// second.
    ///
    /// If the result would exceed `u32::MAX` (`2106-02-07T06:28:15`), it is replaced
    /// by `u32::MAX`.
    pub const fn round(time: Time) -> Self {
        Self::from_u64_seconds(time.0.saturating_add(NANOS_PER_SEC / 2) / NANOS_PER_SEC)
    }

    /// Returns a `CoarseTime` obtained by rounding `time` up to an integer second.
    ///
    /// If the result would exceed `u32::MAX` (`2106-02-07T06:28:15`), it is replaced
    /// by `u32::MAX`.
    pub const fn ceil(time: Time) -> Self {
        Self::from_u64_seconds(time.0.saturating_add(NANOS_PER_SEC - 1) / NANOS_PER_SEC)
    }

    /// Helper for saturating rounding to `u32`.
    const fn from_u64_seconds(seconds: u64) -> Self {
        if seconds < u32::MAX as u64 {
            Self(seconds as u32)
        } else {
            Self(u32::MAX)
        }
    }

    /// Number of seconds since `UNIX EPOCH`.
    pub const fn as_secs_since_unix_epoch(&self) -> u32 {
        self.0
    }
}

impl From<CoarseTime> for Time {
    fn from(time: CoarseTime) -> Self {
        Self(time.0 as u64 * NANOS_PER_SEC)
    }
}
