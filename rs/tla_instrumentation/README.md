# Libraries for linking TLA+ models with Rust code

This directory contains proc macros (in the `tla_instrumentation_proc_macros` crate) and a library (in the `tla_instrumentation` crate) for linking TLA+ models with Rust code. The libraries are intended to help collect traces (list of state pairs) from test runs, and then check whether the trace is allowed according to a TLA+ model (by checking whether each individual state pair in the trace satisfies the model's transition predicate). Currently, the libraries are geared towards instrumenting canisters rather than general-purpose code.

See `tla_instrumentation/tests` for (unfortunately not-really-documented) examples (also see `tla` for sample models). Also see the governance canister for real-world example (a text search of the monorepo for `tla_` is a good start)

# Usage

1. Divide up your TLA model such that you have one TLA module per (logical) entry point that you want to model. Here, "logical entry point" is a bit vague. For example, for governance, the actual code has a single relevant update method called `manage_neuron`, which can then do several different operations depending on the command it receives (e.g., claiming a neuron, merging neurons, etc). The TLA model treats the individual operations (claiming, merging) as entry points, rather than just `merge_neuron`. This allows us to also use state pairs obtained from Rust tests that call the individual operations directly, rather than calling merge_neuron. Recombine the TLA modules into a single model separately (so that you can check things with TLC, for example).
1. Use PlusCal to write your model. You don't have to if you really don't want to, but it's normally easier than modeling the async/await syntax by hand, and the library code assumes that the TLA model is built up the way that PlusCal models would get translated (for example, that there's a "pc" variable that's used as the program counter, for controlling flow). Create a single PlusCal process per entry point (and thus per TLA module). You can control how many invocations of the entry point you want to consider during model checking by setting the cardinality of the process ID set (1 process ID = 1 invocation). If the entry point doesn't increase the state space on every invocation (for example, claiming a neuron adds a new neuron ID and thus increases the state space, but refreshing a neuron does not), then consider making your method a loop (either using PlusCal while, or just gotos). A loop makes the model checker (TLC) check for infinitely many sequential invocations of the method (if you want to consider concurrent invocations, you have to increase the process ID set's cardinality).
1. Assuming you created a `Mymodel.tla` in the previous step, add *another* model called `Mymodel_Apalache.tla` that contains the Apalache type annotations for your model and instantiates `Mymodel` as a module. After you're done and the types work out, comment out the CONSTANT definitions in `Mymodel_Apalache.tla`, and (outside the comment) add another comment line:
   ```
   \* CODE_LINK_INSERT_CONSTANTS
   ```
1. The line above will later be replaced by the definitions of constants derived from the test cases. For example, for governance, the set of neuron IDs needs to be defined as a constant in the TLA model, yet the actual set that appears in a trace obviously depends on the test. So you will define a way to extract constants from the trace. The search/replace above is not very elegant but deal with it.
1. Add a `#[tla_update_method]` attribute macro on the method/function that's the logical entry point as above (that's modeled by a single TLA model). Usually, you want to make this annotation conditional on some feature flag, because this may end up recording a ton of data in the background. You must provide the following two arguments to the macro:

    1. A `tla_instrumentation::Update` value describing the entry point. In particular, this contains the information that cannot be derived from the trace: the TLA model name (e.g., `Mymodel` above), the initial and final value for local variables, the start and end PlusCal labels, your canister's name (the convention is that your model uses "buffers" for inter-canister communication that have the form `governance_to_ledger` and `ledger_to_governance`; in this example, `governance` is your canister's name), and a post-processing function. The post-processing function is usually used to extract the constants from the recorded state pairs as discussed above, and potentially clean up the trace. For example, if you treat run-time configurable values (for example, the ICP ledger fee) as constants in the TLA model, you'll probably record these in the state pairs, and in the post-processing function remove them from the state pairs and record them as constants.

    1. A "snapshotter" macro or function that returns another function (wrapped in an `Arc<Mutex>>`) which can "snapshot" the global state of the model at any point in time (returning a `tla_instrumentation::GLobalState`). This is usually dodgy unsafe Rust code that violates all Rust ownership rules and passes raw pointers around. However, because canisters are single-threaded and generally don't move their heap around you should be fine in practice.
1. Optionally, you can also provide a boolean `force_async_fn` argument to the macro. Setting it to `true` makes the `tla_update_macro` treat the code as an async function, even if the function isn't explicitly marked with an `async` keyword. This is useful when the function is part of an `#[async_trait]` implementation, as the `async_trait` macro desugars the method definition to remove the `async` annotation and return a `Pin<Box<Future<...>>>` instead.
1. Wherever you use `tla_update_method` the following three variables must be in scope (usually, you want to make their import conditional on the same feature flag as the `tla_update_method` annotation itself):

   1. `TLA_INSTRUMENTATION_STATE: local_key::LocalKey<InstrumentationState>`. See the `local_key` package in this directory (a copy of `tokio::local_key`)
   1. `TLA_TRACES_LKEY: local_key::LocalKey<Mutex<Vec<UpdateTrace>>>`. You can also wrap the `Mutex` in an `Arc` (this is needed in particular when `tla_update_method` is used in conjunction with `async_trait`). When a test is run in a scope where this local key is available, the traces will be recorded in this local key. You can use this to isolate different test runs when running pure Rust-based tests.
   1. `TLA_TRACES_MUTEX: Option<RwLock<Vec<UpdateTrace>>>`. If the `TLA_TRACES_LKEY` local key is not available (hasn't been scoped), the recorded traces will be stored in this variable instead. If the variable is `None`, the trace will be dropped. Use this for running canister (Wasm) based tests, as there is no way to scope a local key in this case. To isolate tests, each test should have it's own canister (i.e., tests shouldn't share canisters).
1. Use the `tla_log_locals` macro to record the local variables pertinent to the TLA model.
1. Use the `tla_log_request` and `tla_log_response` macros to record the end/start of a new message handler.
1. Additional conventions are needed when an async Rust function that makes a donwstream call is reused multiple times by an entry point (for example, in governance the `transfer_funds` method is used multiple times when merging neurons, both to burn fees and to move the stake). The current convention is to model such calls by having a different label for each call, but with the same suffix. For example, the TLA model of merge neurons has labels `MergeNeurons_Burn_WaitForTransfer` and `MergeNeurons_Stake_WaitForTransfer`. To make the instrumentation produce such different labels from the same function (`transfer_funds` above), you will need an additional `tla_function` annotation on the reused function. This instructs the instrumentation to "stack" the labels as above. Additionally, you can use `tla_log_label` to change the prefix of the label as you move through the outer method. Note that you can also have a stack of functions annotated by `tla_function`. In this case, make sure that each of them sets a local label, either through `tla_log_label`, or using `tla_log_request`/`tla_log_response`. Note that `tla_function` also takes an optional `force_async_fn` argument.
1. The above instrumentation only collects the traces. You will also want to actually check that they correspond to the model. You can use `tla_instrumentation::checker::check_tla_code_link` for this. You'll need to ensure that a Java Runtime Environment is available for `apalache-mc` to run. See this directory's `BUILD.bazel` for an example of how to do that with Bazel.
