// This file is @generated by prost-build.
/// The entity that owns the nodes that run the network.
///
/// Note that this is different from a node operator, the entity that
/// operates the nodes. In terms of responsibilities, the node operator
/// is responsible for adding/removing and generally making sure that
/// the nodes are working, while the NodeProvider is the entity that
/// is compensated.
///
/// Note: The NodeOperatorRecord is defined in:
/// rs/protobuf/def/registry/node_operator/v1/node_operator.proto.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct NodeProvider {
    /// The ID of the node provider.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<::ic_base_types::PrincipalId>,
    /// The account where rewards earned from providing nodes will be sent.
    #[prost(message, optional, tag = "2")]
    pub reward_account: ::core::option::Option<::icp_ledger::protobuf::AccountIdentifier>,
}
/// Used to update node provider records
///
/// There is no need to specify a node provider Principal ID here, as Governance
/// uses the Principal ID of the caller as the Node Provider Principal ID.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct UpdateNodeProvider {
    /// The account where rewards earned from providing nodes will be sent.
    #[prost(message, optional, tag = "1")]
    pub reward_account: ::core::option::Option<::icp_ledger::protobuf::AccountIdentifier>,
}
/// How did a neuron vote in the recent past? This data is used by
/// other neurons to determine what neurons to follow.
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable, Eq)]
#[compare_default]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BallotInfo {
    #[prost(message, optional, tag = "1")]
    pub proposal_id: ::core::option::Option<::ic_nns_common::pb::v1::ProposalId>,
    #[prost(enumeration = "Vote", tag = "2")]
    pub vote: i32,
}
/// A transfer performed from some account to stake a new neuron.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct NeuronStakeTransfer {
    /// When the transfer arrived at the governance canister.
    #[prost(uint64, tag = "1")]
    pub transfer_timestamp: u64,
    /// The principal that made the transfer.
    #[prost(message, optional, tag = "2")]
    pub from: ::core::option::Option<::ic_base_types::PrincipalId>,
    /// The (optional) subaccount from which the transfer was made.
    #[prost(bytes = "vec", tag = "3")]
    #[serde(with = "serde_bytes")]
    pub from_subaccount: ::prost::alloc::vec::Vec<u8>,
    /// The subaccount to which the transfer was made.
    #[prost(bytes = "vec", tag = "4")]
    #[serde(with = "serde_bytes")]
    pub to_subaccount: ::prost::alloc::vec::Vec<u8>,
    /// The amount of stake that was transferred.
    #[prost(uint64, tag = "5")]
    pub neuron_stake_e8s: u64,
    /// The block height at which the transfer occurred.
    #[prost(uint64, tag = "6")]
    pub block_height: u64,
    /// The memo sent with the transfer.
    #[prost(uint64, tag = "7")]
    pub memo: u64,
}
/// Protobuf representing a list of followees of a neuron for a
/// specific topic.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct Followees {
    #[prost(message, repeated, tag = "1")]
    pub followees: ::prost::alloc::vec::Vec<::ic_nns_common::pb::v1::NeuronId>,
}
/// Subset of Neuron that has no collections or big fields that might not exist in most neurons, and
/// the goal is to keep the size of the struct consistent and can be easily stored in a
/// StableBTreeMap. For the meaning of each field, see the Neuron struct.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct AbridgedNeuron {
    #[prost(bytes = "vec", tag = "2")]
    #[serde(with = "serde_bytes")]
    pub account: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub controller: ::core::option::Option<::ic_base_types::PrincipalId>,
    #[prost(uint64, tag = "5")]
    pub cached_neuron_stake_e8s: u64,
    #[prost(uint64, tag = "6")]
    pub neuron_fees_e8s: u64,
    #[prost(uint64, tag = "7")]
    pub created_timestamp_seconds: u64,
    #[prost(uint64, tag = "8")]
    pub aging_since_timestamp_seconds: u64,
    #[prost(uint64, optional, tag = "19")]
    pub spawn_at_timestamp_seconds: ::core::option::Option<u64>,
    #[prost(bool, tag = "13")]
    pub kyc_verified: bool,
    #[prost(uint64, tag = "15")]
    pub maturity_e8s_equivalent: u64,
    #[prost(uint64, optional, tag = "20")]
    pub staked_maturity_e8s_equivalent: ::core::option::Option<u64>,
    #[prost(bool, optional, tag = "21")]
    pub auto_stake_maturity: ::core::option::Option<bool>,
    #[prost(bool, tag = "16")]
    pub not_for_profit: bool,
    #[prost(uint64, optional, tag = "17")]
    pub joined_community_fund_timestamp_seconds: ::core::option::Option<u64>,
    #[prost(enumeration = "NeuronType", optional, tag = "22")]
    pub neuron_type: ::core::option::Option<i32>,
    #[prost(enumeration = "Visibility", optional, tag = "23")]
    pub visibility: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "24")]
    pub voting_power_refreshed_timestamp_seconds: ::core::option::Option<u64>,
    #[prost(uint32, optional, tag = "25")]
    pub recent_ballots_next_entry_index: ::core::option::Option<u32>,
    #[prost(oneof = "abridged_neuron::DissolveState", tags = "9, 10")]
    pub dissolve_state: ::core::option::Option<abridged_neuron::DissolveState>,
}
/// Nested message and enum types in `AbridgedNeuron`.
pub mod abridged_neuron {
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum DissolveState {
        #[prost(uint64, tag = "9")]
        WhenDissolvedTimestampSeconds(u64),
        #[prost(uint64, tag = "10")]
        DissolveDelaySeconds(u64),
    }
}
/// Payload of a proposal that calls a function on another NNS
/// canister. The canister and function to call is derived from the
/// `nns_function`.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct ExecuteNnsFunction {
    /// This enum value determines what canister to call and what NNS
    /// function to call on that canister.
    #[prost(enumeration = "NnsFunction", tag = "1")]
    pub nns_function: i32,
    /// The payload of the NNS function.
    #[prost(bytes = "vec", tag = "2")]
    #[serde(with = "serde_bytes")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// If adopted, a motion should guide the future strategy of the
/// Internet Computer ecosystem.
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable)]
#[self_describing]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Motion {
    /// The text of the motion. Maximum 100kib.
    #[prost(string, tag = "1")]
    pub motion_text: ::prost::alloc::string::String,
}
/// For all Neurons controlled by the given principals, set their
/// KYC status to `kyc_verified=true`.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct ApproveGenesisKyc {
    #[prost(message, repeated, tag = "1")]
    pub principals: ::prost::alloc::vec::Vec<::ic_base_types::PrincipalId>,
}
/// Adds and/or removes NodeProviders from the list of current
/// node providers.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct AddOrRemoveNodeProvider {
    #[prost(oneof = "add_or_remove_node_provider::Change", tags = "1, 2")]
    pub change: ::core::option::Option<add_or_remove_node_provider::Change>,
}
/// Nested message and enum types in `AddOrRemoveNodeProvider`.
pub mod add_or_remove_node_provider {
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Change {
        #[prost(message, tag = "1")]
        ToAdd(super::NodeProvider),
        #[prost(message, tag = "2")]
        ToRemove(super::NodeProvider),
    }
}
/// This proposal payload is used to reward a node provider by minting
/// ICPs directly to the node provider's ledger account, or into a new
/// neuron created on behalf of the node provider.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct RewardNodeProvider {
    /// The NodeProvider to reward.
    #[prost(message, optional, tag = "1")]
    pub node_provider: ::core::option::Option<NodeProvider>,
    /// The amount of e8s to mint to reward the node provider.
    #[prost(uint64, tag = "2")]
    pub amount_e8s: u64,
    #[prost(oneof = "reward_node_provider::RewardMode", tags = "4, 5")]
    pub reward_mode: ::core::option::Option<reward_node_provider::RewardMode>,
}
/// Nested message and enum types in `RewardNodeProvider`.
pub mod reward_node_provider {
    /// This message specifies how to create a new neuron on behalf of
    /// the node provider.
    ///
    /// - The controller of the new neuron is the node provider's
    ///    principal.
    ///
    /// - The account is chosen at random.
    ///
    /// - The stake of the new neuron is `amount_e8s`.
    ///
    /// - `dissolve_delay_seconds` is as specified in the proto.
    ///
    /// - `kyc_verified` is set to true, as node providers are
    ///    (implicitly) KYC'ed.
    ///
    /// - `not_for_profit` is set to false.
    ///
    /// - All other values are set as for other neurons: timestamp is
    ///    now, following is set up per default, maturity is 0, neuron fee
    ///    is 0.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct RewardToNeuron {
        #[prost(uint64, tag = "1")]
        pub dissolve_delay_seconds: u64,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct RewardToAccount {
        #[prost(message, optional, tag = "1")]
        pub to_account: ::core::option::Option<::icp_ledger::protobuf::AccountIdentifier>,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum RewardMode {
        /// If this is specified, executing this proposal will create a
        /// neuron instead of directly minting ICP into the node provider's
        /// account.
        #[prost(message, tag = "4")]
        RewardToNeuron(RewardToNeuron),
        /// If this is specified, executing this proposal will mint to the
        /// specified account.
        #[prost(message, tag = "5")]
        RewardToAccount(RewardToAccount),
    }
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct RewardNodeProviders {
    #[prost(message, repeated, tag = "1")]
    pub rewards: ::prost::alloc::vec::Vec<RewardNodeProvider>,
    /// If true, reward Node Providers with the rewards returned by the Registry's
    /// get_node_providers_monthly_xdr_rewards method
    #[prost(bool, optional, tag = "2")]
    pub use_registry_derived_rewards: ::core::option::Option<bool>,
}
/// Changes the default followees to match the one provided.
/// This completely replaces the default followees so entries for all
/// Topics (except ManageNeuron) must be provided on each proposal.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct SetDefaultFollowees {
    #[prost(map = "int32, message", tag = "1")]
    pub default_followees: ::std::collections::HashMap<i32, Followees>,
}
/// Obsolete. Superseded by OpenSnsTokenSwap.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct SetSnsTokenSwapOpenTimeWindow {
    /// The swap canister to send the request to.
    #[prost(message, optional, tag = "1")]
    pub swap_canister_id: ::core::option::Option<::ic_base_types::PrincipalId>,
    /// Arguments that get sent to the swap canister when its set_open_time_window
    /// Candid method is called.
    #[prost(message, optional, tag = "2")]
    pub request: ::core::option::Option<::ic_sns_swap::pb::v1::SetOpenTimeWindowRequest>,
}
/// A proposal is the immutable input of a proposal submission. This contains
/// all the information from the original proposal submission.
///
/// Making a proposal implicitly votes yes.
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable)]
#[compare_default]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Proposal {
    /// Must be present (enforced at the application layer, not by PB).
    /// A brief description of what the proposal does.
    /// Size in bytes must be in the interval \[5, 256\].
    #[prost(string, optional, tag = "20")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    /// Text providing a short description of the proposal, composed
    /// using a maximum of 30000 bytes of characters.
    #[prost(string, tag = "1")]
    pub summary: ::prost::alloc::string::String,
    /// The Web address of additional content required to evaluate the
    /// proposal, specified using HTTPS. For example, the address might
    /// describe content supporting the assignment of a DCID (data center
    /// id) to a new data center. The URL string must not be longer than
    /// 2000 bytes.
    #[prost(string, tag = "2")]
    pub url: ::prost::alloc::string::String,
    /// A self-describing action that can be understood without the schema of a specific proposal type.
    /// This is populated and stored at the time of proposal creation and does not change as the
    /// proposal type evolves.
    #[prost(message, optional, tag = "30")]
    pub self_describing_action: ::core::option::Option<SelfDescribingProposalAction>,
    /// This section describes the action that the proposal proposes to
    /// take.
    #[prost(
        oneof = "proposal::Action",
        tags = "10, 12, 13, 14, 15, 16, 17, 18, 19, 21, 29, 22, 23, 24, 25, 26, 27, 28"
    )]
    pub action: ::core::option::Option<proposal::Action>,
}
/// Nested message and enum types in `Proposal`.
pub mod proposal {
    /// This section describes the action that the proposal proposes to
    /// take.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Action {
        /// This type of proposal calls a major function on a specified
        /// target neuron. Only the followees of the target neuron (on the
        /// topic \[Topic::ManageNeuron\]) may vote on these proposals,
        /// which effectively provides the followees with control over the
        /// target neuron. This can provide a convenient and highly secure
        /// means for a team of individuals to manage an important
        /// neuron. For example, a neuron might hold a large balance, or
        /// belong to an organization of high repute, and be publicized so
        /// that many other neurons can follow its vote. In both cases,
        /// managing the private key of the principal securely could be
        /// problematic (either a single copy is held, which is very
        /// insecure and provides for a single party to take control, or a
        /// group of individuals must divide responsibility, for example
        /// using threshold cryptography, which is complex and time
        /// consuming). To address this, using this proposal type, the
        /// important neuron can be configured to follow the neurons
        /// controlled by individual members of a team. Now they can submit
        /// proposals to make the important neuron perform actions, which
        /// are adopted if and only if a majority of them vote to
        /// adopt. Nearly any command on the target neuron can be executed,
        /// including commands that change the follow rules, allowing the
        /// set of team members to be dynamic. Only the final step of
        /// dissolving the neuron once its dissolve delay reaches zero
        /// cannot be performed using this type of proposal (since this
        /// would allow control/“ownership” over the locked balances to be
        /// transferred). To prevent a neuron falling under the malign
        /// control of the principal’s private key by accident, the private
        /// key can be destroyed so that the neuron can only be controlled
        /// by its followees, although this makes it impossible to
        /// subsequently unlock the balance.
        #[prost(message, tag = "10")]
        ManageNeuron(::prost::alloc::boxed::Box<super::ManageNeuron>),
        /// Propose a change to some network parameters of network
        /// economics.
        #[prost(message, tag = "12")]
        ManageNetworkEconomics(super::NetworkEconomics),
        /// See \[Motion\]
        #[prost(message, tag = "13")]
        Motion(super::Motion),
        /// A update affecting something outside of the Governance
        /// canister.
        #[prost(message, tag = "14")]
        ExecuteNnsFunction(super::ExecuteNnsFunction),
        /// Approve Genesis KYC for a given list of principals.
        #[prost(message, tag = "15")]
        ApproveGenesisKyc(super::ApproveGenesisKyc),
        /// Add/remove NodeProvider from the list of NodeProviders
        #[prost(message, tag = "16")]
        AddOrRemoveNodeProvider(super::AddOrRemoveNodeProvider),
        /// Reward a NodeProvider
        #[prost(message, tag = "17")]
        RewardNodeProvider(super::RewardNodeProvider),
        /// Set the default following
        #[prost(message, tag = "18")]
        SetDefaultFollowees(super::SetDefaultFollowees),
        /// Reward multiple NodeProvider
        #[prost(message, tag = "19")]
        RewardNodeProviders(super::RewardNodeProviders),
        /// Register Known Neuron
        #[prost(message, tag = "21")]
        RegisterKnownNeuron(super::KnownNeuron),
        /// Deregister Known Neuron
        #[prost(message, tag = "29")]
        DeregisterKnownNeuron(super::DeregisterKnownNeuron),
        /// Obsolete. Superseded by CreateServiceNervousSystem. Kept for Candid compatibility.
        #[prost(message, tag = "22")]
        SetSnsTokenSwapOpenTimeWindow(super::SetSnsTokenSwapOpenTimeWindow),
        /// Call the open method on an SNS swap canister.
        ///
        /// This is still supported but will soon be superseded by
        /// CreateServiceNervousSystem.
        #[prost(message, tag = "23")]
        OpenSnsTokenSwap(super::OpenSnsTokenSwap),
        /// Create a new SNS.
        #[prost(message, tag = "24")]
        CreateServiceNervousSystem(super::CreateServiceNervousSystem),
        /// Install, reinstall or upgrade the code of a canister that is controlled by the NNS.
        #[prost(message, tag = "25")]
        InstallCode(super::InstallCode),
        /// Stop or start a canister that is controlled by the NNS.
        #[prost(message, tag = "26")]
        StopOrStartCanister(super::StopOrStartCanister),
        /// Update the settings of a canister that is controlled by the NNS.
        #[prost(message, tag = "27")]
        UpdateCanisterSettings(super::UpdateCanisterSettings),
        /// Create a rented subnet.
        #[prost(message, tag = "28")]
        FulfillSubnetRentalRequest(super::FulfillSubnetRentalRequest),
    }
}
/// Empty message to use in oneof fields that represent empty
/// enums.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct Empty {}
/// All operations that modify the state of an existing neuron are
/// represented by instances of `ManageNeuron`.
///
/// All commands are available to the `controller` of the neuron. In
/// addition, commands related to voting, i.g., \[manage_neuron::Follow\]
/// and \[manage_neuron::RegisterVote\], are also available to the
/// registered hot keys of the neuron.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct ManageNeuron {
    /// This is the legacy way to specify neuron IDs that is now discouraged.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<::ic_nns_common::pb::v1::NeuronId>,
    /// The ID of the neuron to manage. This can either be a subaccount or a neuron ID.
    #[prost(oneof = "manage_neuron::NeuronIdOrSubaccount", tags = "11, 12")]
    pub neuron_id_or_subaccount: ::core::option::Option<manage_neuron::NeuronIdOrSubaccount>,
    #[prost(
        oneof = "manage_neuron::Command",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 15, 16, 17, 18"
    )]
    pub command: ::core::option::Option<manage_neuron::Command>,
}
/// Nested message and enum types in `ManageNeuron`.
pub mod manage_neuron {
    /// The dissolve delay of a neuron can be increased up to a maximum
    /// of 8 years.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct IncreaseDissolveDelay {
        #[prost(uint32, tag = "1")]
        pub additional_dissolve_delay_seconds: u32,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct StartDissolving {}
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct StopDissolving {}
    /// Add a new hot key that can be used to manage the neuron. This
    /// provides an alternative to using the controller principal’s cold key to
    /// manage the neuron, which might be onerous and difficult to keep
    /// secure, especially if it is used regularly. A hot key might be a
    /// WebAuthn key that is maintained inside a user device, such as a
    /// smartphone.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct AddHotKey {
        #[prost(message, optional, tag = "1")]
        pub new_hot_key: ::core::option::Option<::ic_base_types::PrincipalId>,
    }
    /// Remove a hot key that has been previously assigned to the neuron.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct RemoveHotKey {
        #[prost(message, optional, tag = "1")]
        pub hot_key_to_remove: ::core::option::Option<::ic_base_types::PrincipalId>,
    }
    /// An (idempotent) alternative to IncreaseDissolveDelay where the dissolve delay
    /// is passed as an absolute timestamp in seconds since the unix epoch.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct SetDissolveTimestamp {
        #[prost(uint64, tag = "1")]
        pub dissolve_timestamp_seconds: u64,
    }
    /// Join the Internet Computer's community fund with this neuron's present and future maturity.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct JoinCommunityFund {}
    /// Leave the Internet Computer's community fund.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct LeaveCommunityFund {}
    /// Changes auto-stake maturity for this Neuron. While on, auto-stake
    /// maturity will cause all the maturity generated by voting rewards
    /// to this neuron to be automatically staked and contribute to the
    /// voting power of the neuron.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct ChangeAutoStakeMaturity {
        #[prost(bool, tag = "1")]
        pub requested_setting_for_auto_stake_maturity: bool,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct SetVisibility {
        #[prost(enumeration = "super::Visibility", optional, tag = "1")]
        pub visibility: ::core::option::Option<i32>,
    }
    /// Commands that only configure a given neuron, but do not interact
    /// with the outside world. They all require the caller to be the
    /// controller of the neuron.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Configure {
        #[prost(oneof = "configure::Operation", tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10")]
        pub operation: ::core::option::Option<configure::Operation>,
    }
    /// Nested message and enum types in `Configure`.
    pub mod configure {
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            PartialEq,
            ::prost::Oneof,
        )]
        pub enum Operation {
            #[prost(message, tag = "1")]
            IncreaseDissolveDelay(super::IncreaseDissolveDelay),
            #[prost(message, tag = "2")]
            StartDissolving(super::StartDissolving),
            #[prost(message, tag = "3")]
            StopDissolving(super::StopDissolving),
            #[prost(message, tag = "4")]
            AddHotKey(super::AddHotKey),
            #[prost(message, tag = "5")]
            RemoveHotKey(super::RemoveHotKey),
            #[prost(message, tag = "6")]
            SetDissolveTimestamp(super::SetDissolveTimestamp),
            #[prost(message, tag = "7")]
            JoinCommunityFund(super::JoinCommunityFund),
            #[prost(message, tag = "8")]
            LeaveCommunityFund(super::LeaveCommunityFund),
            #[prost(message, tag = "9")]
            ChangeAutoStakeMaturity(super::ChangeAutoStakeMaturity),
            #[prost(message, tag = "10")]
            SetVisibility(super::SetVisibility),
        }
    }
    /// Disburse this neuron's stake: transfer the staked ICP to the
    /// specified account.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Disburse {
        /// The (optional) amount to transfer. If not specified the cached
        /// stake is used.
        #[prost(message, optional, tag = "1")]
        pub amount: ::core::option::Option<disburse::Amount>,
        /// The principal to which to transfer the stake.
        #[prost(message, optional, tag = "2")]
        pub to_account: ::core::option::Option<::icp_ledger::protobuf::AccountIdentifier>,
    }
    /// Nested message and enum types in `Disburse`.
    pub mod disburse {
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            Copy,
            PartialEq,
            ::prost::Message,
        )]
        pub struct Amount {
            #[prost(uint64, tag = "1")]
            pub e8s: u64,
        }
    }
    /// Split this neuron into two neurons.
    ///
    /// The child neuron retains the parent neuron's properties.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Split {
        /// The amount to split to the child neuron.
        #[prost(uint64, tag = "1")]
        pub amount_e8s: u64,
        /// The memo to use for the child neuron.
        #[prost(uint64, optional, tag = "2")]
        pub memo: ::core::option::Option<u64>,
    }
    /// Merge another neuron into this neuron.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Merge {
        /// The neuron to merge stake and maturity from.
        #[prost(message, optional, tag = "1")]
        pub source_neuron_id: ::core::option::Option<::ic_nns_common::pb::v1::NeuronId>,
    }
    /// When the maturity of a neuron has risen above a threshold, it can
    /// be instructed to spawn a new neuron. This creates a new neuron
    /// that locks a new balance of ICP on the ledger. The new neuron can
    /// remain controlled by the same principal as its parent, or be
    /// assigned to a new principal.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Spawn {
        /// If not set, the spawned neuron will have the same controller as
        /// this neuron.
        #[prost(message, optional, tag = "1")]
        pub new_controller: ::core::option::Option<::ic_base_types::PrincipalId>,
        /// The nonce with which to create the subaccount.
        #[prost(uint64, optional, tag = "2")]
        pub nonce: ::core::option::Option<u64>,
        /// The percentage to spawn, from 1 to 100 (inclusive).
        #[prost(uint32, optional, tag = "3")]
        pub percentage_to_spawn: ::core::option::Option<u32>,
    }
    /// Merge the maturity of a neuron into the current stake.
    /// The caller can choose a percentage of the current maturity to merge into
    /// the existing stake. The resulting amount to merge must be greater than
    /// or equal to the transaction fee.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct MergeMaturity {
        /// The percentage to merge, from 1 to 100 (inclusive).
        #[prost(uint32, tag = "1")]
        pub percentage_to_merge: u32,
    }
    /// Stake the maturity of a neuron.
    /// The caller can choose a percentage of of the current maturity to stake.
    /// If 'percentage_to_stake' is not provided, all of the neuron's current
    /// maturity will be staked.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct StakeMaturity {
        /// The percentage of maturity to stake, from 1 to 100 (inclusive).
        #[prost(uint32, optional, tag = "1")]
        pub percentage_to_stake: ::core::option::Option<u32>,
    }
    /// Disburse a portion of this neuron's stake into another neuron.
    /// This allows to split a neuron but with a new dissolve delay
    /// and owned by someone else.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct DisburseToNeuron {
        /// The controller of the new neuron (must be set).
        #[prost(message, optional, tag = "1")]
        pub new_controller: ::core::option::Option<::ic_base_types::PrincipalId>,
        /// The amount to disburse.
        #[prost(uint64, tag = "2")]
        pub amount_e8s: u64,
        /// The dissolve delay of the new neuron.
        #[prost(uint64, tag = "3")]
        pub dissolve_delay_seconds: u64,
        /// Whether the new neuron has been kyc verified.
        #[prost(bool, tag = "4")]
        pub kyc_verified: bool,
        /// The nonce with which to create the subaccount.
        #[prost(uint64, tag = "5")]
        pub nonce: u64,
    }
    /// Add a rule that enables the neuron to vote automatically on
    /// proposals that belong to a specific topic, by specifying a group
    /// of followee neurons whose majority vote is followed. The
    /// configuration of such follow rules can be used to a) distribute
    /// control over voting power amongst multiple entities, b) have a
    /// neuron vote automatically when its owner lacks time to evaluate
    /// newly submitted proposals, c) have a neuron vote automatically
    /// when its own lacks the expertise to evaluate newly submitted
    /// proposals, and d) for other purposes. A follow rule specifies a
    /// set of followees. Once a majority of the followees votes to adopt
    /// or reject a proposal belonging to the specified topic, the neuron
    /// votes the same way. If it becomes impossible for a majority of
    /// the followees to adopt (for example, because they are split 50-50
    /// between adopt and reject), then the neuron votes to reject. If a
    /// rule is specified where the proposal topic is UNSPECIFIED, then it
    /// becomes a catch-all follow rule, which will be used to vote
    /// automatically on proposals belonging to topics for which no
    /// specific rule has been specified.
    ///
    /// If the list 'followees' is empty, this removes following for a
    /// specific topic.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Follow {
        /// Topic UNSPECIFIED means add following for the 'catch all'.
        #[prost(enumeration = "super::Topic", tag = "1")]
        pub topic: i32,
        #[prost(message, repeated, tag = "2")]
        pub followees: ::prost::alloc::vec::Vec<::ic_nns_common::pb::v1::NeuronId>,
    }
    /// Have the neuron vote to either adopt or reject a proposal with a specified
    /// id.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct RegisterVote {
        #[prost(message, optional, tag = "1")]
        pub proposal: ::core::option::Option<::ic_nns_common::pb::v1::ProposalId>,
        #[prost(enumeration = "super::Vote", tag = "2")]
        pub vote: i32,
    }
    /// Claim a new neuron or refresh the stake of an existing neuron.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct ClaimOrRefresh {
        #[prost(oneof = "claim_or_refresh::By", tags = "1, 2, 3")]
        pub by: ::core::option::Option<claim_or_refresh::By>,
    }
    /// Nested message and enum types in `ClaimOrRefresh`.
    pub mod claim_or_refresh {
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            PartialEq,
            ::prost::Message,
        )]
        pub struct MemoAndController {
            #[prost(uint64, tag = "1")]
            pub memo: u64,
            #[prost(message, optional, tag = "2")]
            pub controller: ::core::option::Option<::ic_base_types::PrincipalId>,
        }
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            PartialEq,
            ::prost::Oneof,
        )]
        pub enum By {
            /// DEPRECATED: Use MemoAndController and omit the controller.
            #[prost(uint64, tag = "1")]
            Memo(u64),
            /// Claim or refresh a neuron, by providing the memo used in the
            /// staking transfer and 'controller' as the principal id used to
            /// calculate the subaccount to which the transfer was made. If
            /// 'controller' is omitted, the principal id of the caller is
            /// used.
            #[prost(message, tag = "2")]
            MemoAndController(MemoAndController),
            /// This just serves as a tag to indicate that the neuron should be
            /// refreshed by it's id or subaccount. This does not work to claim
            /// new neurons.
            #[prost(message, tag = "3")]
            NeuronIdOrSubaccount(super::super::Empty),
        }
    }
    /// This is one way for a neuron to make sure that its deciding_voting_power is
    /// not less than its potential_voting_power. See the description of those
    /// fields in Neuron.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct RefreshVotingPower {}
    /// Disburse the maturity of a neuron to any ledger account. If an account is not specified, the
    /// controller's account will be used. The controller can choose a percentage of the current
    /// maturity to disburse to the ledger account. The resulting amount to disburse must be at least 1
    /// ICP. The disbursement has a 7-day delay before it is finalized. At the finalization time, the
    /// maturity modulation will be applied to the amount, which can make the amount \[95%, 105%\] of the
    /// original amount.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct DisburseMaturity {
        /// The percentage to disburse, from 1 to 100
        #[prost(uint32, tag = "1")]
        pub percentage_to_disburse: u32,
        /// The (optional) principal to which to transfer the stake. It should not be set if
        /// `to_account_identifier` is set.
        #[prost(message, optional, tag = "2")]
        pub to_account: ::core::option::Option<super::Account>,
        /// The (optional) account identifier to which to transfer the stake. It should not be set if
        /// `to_account` is set.
        #[prost(message, optional, tag = "3")]
        pub to_account_identifier:
            ::core::option::Option<::icp_ledger::protobuf::AccountIdentifier>,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct SetFollowing {
        #[prost(message, repeated, tag = "1")]
        pub topic_following: ::prost::alloc::vec::Vec<set_following::FolloweesForTopic>,
    }
    /// Nested message and enum types in `SetFollowing`.
    pub mod set_following {
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            PartialEq,
            ::prost::Message,
        )]
        pub struct FolloweesForTopic {
            #[prost(message, repeated, tag = "1")]
            pub followees: ::prost::alloc::vec::Vec<::ic_nns_common::pb::v1::NeuronId>,
            #[prost(enumeration = "super::super::Topic", optional, tag = "2")]
            pub topic: ::core::option::Option<i32>,
        }
    }
    /// The ID of the neuron to manage. This can either be a subaccount or a neuron ID.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum NeuronIdOrSubaccount {
        #[prost(bytes, tag = "11")]
        #[serde(with = "serde_bytes")]
        Subaccount(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "12")]
        NeuronId(::ic_nns_common::pb::v1::NeuronId),
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Command {
        #[prost(message, tag = "2")]
        Configure(Configure),
        #[prost(message, tag = "3")]
        Disburse(Disburse),
        #[prost(message, tag = "4")]
        Spawn(Spawn),
        #[prost(message, tag = "5")]
        Follow(Follow),
        #[prost(message, tag = "6")]
        MakeProposal(::prost::alloc::boxed::Box<super::Proposal>),
        #[prost(message, tag = "7")]
        RegisterVote(RegisterVote),
        #[prost(message, tag = "8")]
        Split(Split),
        #[prost(message, tag = "9")]
        DisburseToNeuron(DisburseToNeuron),
        #[prost(message, tag = "10")]
        ClaimOrRefresh(ClaimOrRefresh),
        #[prost(message, tag = "13")]
        MergeMaturity(MergeMaturity),
        #[prost(message, tag = "14")]
        Merge(Merge),
        #[prost(message, tag = "15")]
        StakeMaturity(StakeMaturity),
        #[prost(message, tag = "16")]
        RefreshVotingPower(RefreshVotingPower),
        #[prost(message, tag = "17")]
        DisburseMaturity(DisburseMaturity),
        #[prost(message, tag = "18")]
        SetFollowing(SetFollowing),
    }
}
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable)]
#[compare_default]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GovernanceError {
    #[prost(enumeration = "governance_error::ErrorType", tag = "1")]
    pub error_type: i32,
    #[prost(string, tag = "2")]
    pub error_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GovernanceError`.
pub mod governance_error {
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum ErrorType {
        Unspecified = 0,
        /// The operation was successfully completed.
        Ok = 1,
        /// There have been too many instances of this operation recently. In
        /// practice, this usually just means that another instance of this operation
        /// is currently in flight, but another reason this might come up is rate
        /// limiting.
        Unavailable = 2,
        /// The caller is not authorized to perform this operation.
        NotAuthorized = 3,
        /// Some entity required for the operation (for example, a neuron) was not found.
        NotFound = 4,
        /// The command was missing or invalid. This is a permanent error.
        InvalidCommand = 5,
        /// The neuron is dissolving or dissolved and the operation requires it to
        /// be not dissolving (that is, having a non-zero dissolve delay that is
        /// accumulating age).
        RequiresNotDissolving = 6,
        /// The neuron is not dissolving or dissolved and the operation requires
        /// it to be dissolving (that is, having a non-zero dissolve delay with
        /// zero age that is not accumulating).
        RequiresDissolving = 7,
        /// The neuron is not dissolving and not dissolved and the operation
        /// requires it to be dissolved (that is, having a dissolve delay of zero
        /// and an age of zero).
        RequiresDissolved = 8,
        /// When adding or removing a hot key: the key to add was already
        /// present or the key to remove was not present or the key to add
        /// was invalid or adding another hot key would bring the total
        /// number of the maximum number of allowed hot keys per neuron.
        HotKey = 9,
        /// Some canister side resource is exhausted, so this operation cannot be
        /// performed.
        ResourceExhausted = 10,
        /// Some precondition for executing this method was not met (e.g. the
        /// neuron's dissolve time is too short). There could be a change in the
        /// state of the system such that the operation becomes allowed (e.g. the
        /// owner of the neuron increases its dissolve delay).
        PreconditionFailed = 11,
        /// Executing this method failed for some reason external to the
        /// governance canister.
        External = 12,
        /// A neuron has an ongoing ledger update and thus can't be
        /// changed.
        LedgerUpdateOngoing = 13,
        /// There wasn't enough funds to perform the operation.
        InsufficientFunds = 14,
        /// The principal provided was invalid.
        InvalidPrincipal = 15,
        /// The proposal is defective in some way (e.g. title is too long). If the
        /// same proposal is submitted again without modification, it will be
        /// rejected regardless of changes in the system's state (e.g. increasing
        /// the neuron's dissolve delay will not make the proposal acceptable).
        InvalidProposal = 16,
        /// The neuron attempted to join the community fund while already
        /// a member.
        AlreadyJoinedCommunityFund = 17,
        /// The neuron attempted to leave the community fund but is not a member.
        NotInTheCommunityFund = 18,
        /// The neuron attempted to vote on a proposal that it has already voted on before.
        NeuronAlreadyVoted = 19,
    }
    impl ErrorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ERROR_TYPE_UNSPECIFIED",
                Self::Ok => "ERROR_TYPE_OK",
                Self::Unavailable => "ERROR_TYPE_UNAVAILABLE",
                Self::NotAuthorized => "ERROR_TYPE_NOT_AUTHORIZED",
                Self::NotFound => "ERROR_TYPE_NOT_FOUND",
                Self::InvalidCommand => "ERROR_TYPE_INVALID_COMMAND",
                Self::RequiresNotDissolving => "ERROR_TYPE_REQUIRES_NOT_DISSOLVING",
                Self::RequiresDissolving => "ERROR_TYPE_REQUIRES_DISSOLVING",
                Self::RequiresDissolved => "ERROR_TYPE_REQUIRES_DISSOLVED",
                Self::HotKey => "ERROR_TYPE_HOT_KEY",
                Self::ResourceExhausted => "ERROR_TYPE_RESOURCE_EXHAUSTED",
                Self::PreconditionFailed => "ERROR_TYPE_PRECONDITION_FAILED",
                Self::External => "ERROR_TYPE_EXTERNAL",
                Self::LedgerUpdateOngoing => "ERROR_TYPE_LEDGER_UPDATE_ONGOING",
                Self::InsufficientFunds => "ERROR_TYPE_INSUFFICIENT_FUNDS",
                Self::InvalidPrincipal => "ERROR_TYPE_INVALID_PRINCIPAL",
                Self::InvalidProposal => "ERROR_TYPE_INVALID_PROPOSAL",
                Self::AlreadyJoinedCommunityFund => "ERROR_TYPE_ALREADY_JOINED_COMMUNITY_FUND",
                Self::NotInTheCommunityFund => "ERROR_TYPE_NOT_IN_THE_COMMUNITY_FUND",
                Self::NeuronAlreadyVoted => "ERROR_TYPE_NEURON_ALREADY_VOTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ERROR_TYPE_OK" => Some(Self::Ok),
                "ERROR_TYPE_UNAVAILABLE" => Some(Self::Unavailable),
                "ERROR_TYPE_NOT_AUTHORIZED" => Some(Self::NotAuthorized),
                "ERROR_TYPE_NOT_FOUND" => Some(Self::NotFound),
                "ERROR_TYPE_INVALID_COMMAND" => Some(Self::InvalidCommand),
                "ERROR_TYPE_REQUIRES_NOT_DISSOLVING" => Some(Self::RequiresNotDissolving),
                "ERROR_TYPE_REQUIRES_DISSOLVING" => Some(Self::RequiresDissolving),
                "ERROR_TYPE_REQUIRES_DISSOLVED" => Some(Self::RequiresDissolved),
                "ERROR_TYPE_HOT_KEY" => Some(Self::HotKey),
                "ERROR_TYPE_RESOURCE_EXHAUSTED" => Some(Self::ResourceExhausted),
                "ERROR_TYPE_PRECONDITION_FAILED" => Some(Self::PreconditionFailed),
                "ERROR_TYPE_EXTERNAL" => Some(Self::External),
                "ERROR_TYPE_LEDGER_UPDATE_ONGOING" => Some(Self::LedgerUpdateOngoing),
                "ERROR_TYPE_INSUFFICIENT_FUNDS" => Some(Self::InsufficientFunds),
                "ERROR_TYPE_INVALID_PRINCIPAL" => Some(Self::InvalidPrincipal),
                "ERROR_TYPE_INVALID_PROPOSAL" => Some(Self::InvalidProposal),
                "ERROR_TYPE_ALREADY_JOINED_COMMUNITY_FUND" => {
                    Some(Self::AlreadyJoinedCommunityFund)
                }
                "ERROR_TYPE_NOT_IN_THE_COMMUNITY_FUND" => Some(Self::NotInTheCommunityFund),
                "ERROR_TYPE_NEURON_ALREADY_VOTED" => Some(Self::NeuronAlreadyVoted),
                _ => None,
            }
        }
    }
}
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable)]
#[self_describing]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Ballot {
    #[prost(enumeration = "Vote", tag = "1")]
    pub vote: i32,
    #[prost(uint64, tag = "2")]
    pub voting_power: u64,
}
/// A tally of votes.
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable)]
#[self_describing]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Tally {
    /// When was this tally made
    #[prost(uint64, tag = "1")]
    pub timestamp_seconds: u64,
    /// Yeses, in voting power unit.
    #[prost(uint64, tag = "2")]
    pub yes: u64,
    /// Noes, in voting power unit.
    #[prost(uint64, tag = "3")]
    pub no: u64,
    /// Total voting power unit of eligible neurons.
    /// Should always be greater than or equal to yes + no.
    #[prost(uint64, tag = "4")]
    pub total: u64,
}
/// A ProposalData contains everything related to an open proposal:
/// the proposal itself (immutable), as well as mutable data such as
/// ballots.
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable)]
#[compare_default]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProposalData {
    /// This is stored here temporarily. It is also stored on the map
    /// that contains proposals.
    ///
    /// Immutable: The unique id for this proposal.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<::ic_nns_common::pb::v1::ProposalId>,
    /// Immutable: The ID of the neuron that made this proposal.
    #[prost(message, optional, tag = "2")]
    pub proposer: ::core::option::Option<::ic_nns_common::pb::v1::NeuronId>,
    /// Immutable: The amount of ICP in E8s to be charged to the proposer if the
    /// proposal is rejected.
    #[prost(uint64, tag = "3")]
    pub reject_cost_e8s: u64,
    /// Immutable: The proposal originally submitted.
    #[prost(message, optional, tag = "4")]
    pub proposal: ::core::option::Option<Proposal>,
    /// Immutable: The timestamp, in seconds from the Unix epoch, when this proposal
    /// was made.
    #[prost(uint64, tag = "5")]
    pub proposal_timestamp_seconds: u64,
    /// Map neuron ID to to the neuron's vote and voting power. Only
    /// present for as long as the proposal is not yet settled with
    /// respect to rewards.
    #[prost(map = "fixed64, message", tag = "6")]
    pub ballots: ::std::collections::HashMap<u64, Ballot>,
    /// Latest tally. Recomputed for every vote. Even after the proposal has been
    /// decided, the latest_tally will still be updated based on the recent vote,
    /// until the voting deadline.
    #[prost(message, optional, tag = "7")]
    pub latest_tally: ::core::option::Option<Tally>,
    /// If specified: the timestamp when this proposal was adopted or
    /// rejected. If not specified, this proposal is still 'open'.
    #[prost(uint64, tag = "8")]
    pub decided_timestamp_seconds: u64,
    /// When an adopted proposal has been executed, this is set to
    /// current timestamp.
    #[prost(uint64, tag = "12")]
    pub executed_timestamp_seconds: u64,
    /// When an adopted proposal has failed to be executed, this is set
    /// to the current timestamp.
    #[prost(uint64, tag = "13")]
    pub failed_timestamp_seconds: u64,
    /// When an adopted proposal has failed to executed, this is set the
    /// reason for the failure.
    #[prost(message, optional, tag = "15")]
    pub failure_reason: ::core::option::Option<GovernanceError>,
    /// The reward event round at which rewards for votes on this proposal
    /// was distributed.
    ///
    /// Rounds do not have to be consecutive.
    ///
    /// Rounds start at one: a value of zero indicates that
    /// no reward event taking this proposal into consideration happened yet.
    ///
    /// This field matches field day_after_genesis in RewardEvent.
    #[prost(uint64, tag = "14")]
    pub reward_event_round: u64,
    /// Wait-for-quiet state that needs to be saved in stable memory.
    #[prost(message, optional, tag = "16")]
    pub wait_for_quiet_state: ::core::option::Option<WaitForQuietState>,
    /// This is populated when an OpenSnsTokenSwap proposal is first made.
    #[prost(uint64, optional, tag = "17")]
    pub original_total_community_fund_maturity_e8s_equivalent: ::core::option::Option<u64>,
    /// This gets set to one of the terminal values (i.e. Committed or Aborted)
    /// when the swap canister calls our conclude_community_fund_participation
    /// Candid method. Initially, it is set to Open, because swap is supposed to
    /// enter that state when we call its open Candid method, which is the main
    /// operation in the execution of an OpenSnsTokenSwap proposal.
    #[prost(enumeration = "::ic_sns_swap::pb::v1::Lifecycle", optional, tag = "19")]
    pub sns_token_swap_lifecycle: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "20")]
    pub derived_proposal_information: ::core::option::Option<DerivedProposalInformation>,
    /// This structure contains data for settling the Neurons' Fund participation at the end of a swap.
    ///
    /// TODO\[NNS1-2566\]: deprecate `original_total_community_fund_maturity_e8s_equivalent` and
    /// `cf_participants` and use only this field for managing the Neurons' Fund swap participation.
    #[prost(message, optional, tag = "21")]
    pub neurons_fund_data: ::core::option::Option<NeuronsFundData>,
    /// This is the amount of voting power that would be available if all neurons
    /// kept themselves "refreshed". This is used as the baseline for voting
    /// rewards. That is, the amount of maturity that a neuron receives is the
    /// amount of voting power that it exercised (so called "deciding" voting
    /// power) in proportion to this.
    #[prost(uint64, optional, tag = "22")]
    pub total_potential_voting_power: ::core::option::Option<u64>,
    /// The topic of the proposal.
    #[prost(enumeration = "Topic", optional, tag = "23")]
    pub topic: ::core::option::Option<i32>,
    /// When a voting power spike is detected, ballots are created using a previous snapshot of the
    /// voting power, and this field indicates the timestamp at which the snapshot was taken. This
    /// field should not be set in normal circumstances, and if it is set, it is an indicator that a
    /// bug might have caused the voting power spike.
    #[prost(uint64, optional, tag = "24")]
    pub previous_ballots_timestamp_seconds: ::core::option::Option<u64>,
}
/// This structure contains data for settling the Neurons' Fund participation in an SNS token swap.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct NeuronsFundData {
    /// Initial Neurons' Fund reserves computed at the time of execution of the proposal through which
    /// the SNS swap is created.
    #[prost(message, optional, tag = "1")]
    pub initial_neurons_fund_participation: ::core::option::Option<NeuronsFundParticipation>,
    /// Final Neurons' Fund participation computed at the time of swap finalization. This field should
    /// remain unspecified until either (1) the `settle_neurons_fund_participation` function is called
    /// or (2) the NNS handles an error at the SNS deployment stage.
    ///
    /// If specified, this must be a subset of `initial_neurons_fund_participation`.
    #[prost(message, optional, tag = "2")]
    pub final_neurons_fund_participation: ::core::option::Option<NeuronsFundParticipation>,
    /// Refunds for any leftover Neurons' Fund maturity that could not be used to participate in
    /// the swap. This field should remain unspecified `settle_neurons_fund_participation` is called.
    ///
    /// If specified, this must be equal to the following set-difference:
    /// `initial_neurons_fund_participation.neurons_fund_reserves`
    /// set-minus `final_neurons_fund_participation.neurons_fund_reserves`.
    #[prost(message, optional, tag = "3")]
    pub neurons_fund_refunds: ::core::option::Option<NeuronsFundSnapshot>,
}
/// This is a view of the NeuronsFundData returned by API queries and is NOT used for storage.
/// Currently, the structure is identical to NeuronsFundData, but this may change over time.
/// Some of the fields, e.g., actual IDs of neurons, are anonymized.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct NeuronsFundAuditInfo {
    /// See documentation for NeuronsFundData.neurons_fund_participation
    #[prost(message, optional, tag = "1")]
    pub initial_neurons_fund_participation: ::core::option::Option<NeuronsFundParticipation>,
    /// See documentation for NeuronsFundData.final_neurons_fund_participation
    #[prost(message, optional, tag = "2")]
    pub final_neurons_fund_participation: ::core::option::Option<NeuronsFundParticipation>,
    /// See documentation for NeuronsFundData.neurons_fund_refunds
    #[prost(message, optional, tag = "3")]
    pub neurons_fund_refunds: ::core::option::Option<NeuronsFundSnapshot>,
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct GetNeuronsFundAuditInfoRequest {
    /// ID of the NNS proposal that resulted in the creation of the corresponding Swap.
    #[prost(message, optional, tag = "1")]
    pub nns_proposal_id: ::core::option::Option<::ic_nns_common::pb::v1::ProposalId>,
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct GetNeuronsFundAuditInfoResponse {
    #[prost(oneof = "get_neurons_fund_audit_info_response::Result", tags = "1, 2")]
    pub result: ::core::option::Option<get_neurons_fund_audit_info_response::Result>,
}
/// Nested message and enum types in `GetNeuronsFundAuditInfoResponse`.
pub mod get_neurons_fund_audit_info_response {
    /// Request was completed successfully.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Ok {
        /// Represents public information suitable for auditing Neurons' Fund participation in an SNS swap.
        #[prost(message, optional, tag = "1")]
        pub neurons_fund_audit_info: ::core::option::Option<super::NeuronsFundAuditInfo>,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Result {
        #[prost(message, tag = "1")]
        Err(super::GovernanceError),
        #[prost(message, tag = "2")]
        Ok(Ok),
    }
}
/// Information for deciding how the Neurons' Fund should participate in an SNS Swap.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct NeuronsFundParticipation {
    /// The function used in the implementation of Matched Funding.
    ///
    /// If an NNS Governance upgrade takes place *during* a swap, the original "ideal" matched
    /// participation function needs to be recovered at the end of the swap, ensuring e.g., that
    /// the amount of maturity stored in `neurons_fund_snapshot` will not not be exceeded for due to
    /// a change in this function.
    #[prost(message, optional, tag = "1")]
    pub ideal_matched_participation_function:
        ::core::option::Option<IdealMatchedParticipationFunction>,
    /// The snapshot of the Neurons' Fund allocation of its maximum swap participation amount among
    /// its neurons. This snapshot is computed at the execution time of the NNS proposal leading
    /// to the swap opening.
    #[prost(message, optional, tag = "2")]
    pub neurons_fund_reserves: ::core::option::Option<NeuronsFundSnapshot>,
    /// Absolute constraints for direct participants of this swap needed in Matched Funding
    /// computations.
    #[prost(message, optional, tag = "3")]
    pub swap_participation_limits: ::core::option::Option<SwapParticipationLimits>,
    /// Neurons' Fund participation is computed for this amount of direct participation.
    #[prost(uint64, optional, tag = "4")]
    pub direct_participation_icp_e8s: ::core::option::Option<u64>,
    /// Total amount of maturity in the Neurons' Fund at the time when the Neurons' Fund participation
    /// was created.
    #[prost(uint64, optional, tag = "5")]
    pub total_maturity_equivalent_icp_e8s: ::core::option::Option<u64>,
    /// Maximum amount that the Neurons' Fund will participate with in this SNS swap, regardless of how
    /// large the value of `direct_participation_icp_e8s` is.
    #[prost(uint64, optional, tag = "6")]
    pub max_neurons_fund_swap_participation_icp_e8s: ::core::option::Option<u64>,
    /// How much the Neurons' Fund would ideally like to participate with in this SNS swap, given
    /// the direct participation amount (`direct_participation_icp_e8s`) and matching function
    /// (`ideal_matched_participation_function`).
    #[prost(uint64, optional, tag = "7")]
    pub intended_neurons_fund_participation_icp_e8s: ::core::option::Option<u64>,
    /// How much from `intended_neurons_fund_participation_icp_e8s` was the Neurons' Fund actually able
    /// to allocate, given the specific composition of neurons at the time of execution of the proposal
    /// through which this SNS was created and the participation limits of this SNS.
    #[prost(uint64, optional, tag = "8")]
    pub allocated_neurons_fund_participation_icp_e8s: ::core::option::Option<u64>,
}
/// This function is called "ideal" because it serves as the guideline that the Neurons' Fund will
/// try to follow, but may deviate from in order to satisfy SNS-specific participation constraints
/// while allocating its overall participation amount among its neurons' maturity. In contrast,
/// The "effective" matched participation function `crate::neurons_fund::MatchedParticipationFunction`
/// is computed *based* on this one.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct IdealMatchedParticipationFunction {
    /// The encoding of the "ideal" matched participation function is defined in `crate::neurons_fund`.
    /// In the future, we could change this message to represent full abstract syntactic trees
    /// comprised of elementary mathematical operators, with literals and variables as tree leaves.
    #[prost(string, optional, tag = "1")]
    pub serialized_representation: ::core::option::Option<::prost::alloc::string::String>,
}
/// The snapshot of the Neurons' Fund allocation of its maximum swap participation amount among
/// its neurons. This snapshot is computed at the execution time of the NNS proposal leading
/// to the swap opening; it is then used at the end of a swap to compute the refund amounts
/// per Neuron' Fund neuron.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct NeuronsFundSnapshot {
    #[prost(message, repeated, tag = "1")]
    pub neurons_fund_neuron_portions:
        ::prost::alloc::vec::Vec<neurons_fund_snapshot::NeuronsFundNeuronPortion>,
}
/// Nested message and enum types in `NeuronsFundSnapshot`.
pub mod neurons_fund_snapshot {
    /// Represents one NNS neuron from the Neurons' Fund participating in this swap.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct NeuronsFundNeuronPortion {
        /// The NNS neuron ID of the participating neuron.
        #[prost(message, optional, tag = "1")]
        pub nns_neuron_id: ::core::option::Option<::ic_nns_common::pb::v1::NeuronId>,
        /// Portion of maturity taken from this neuron. Must be less than or equal to
        /// `maturity_equivalent_icp_e8s`.
        #[prost(uint64, optional, tag = "2")]
        pub amount_icp_e8s: ::core::option::Option<u64>,
        /// Overall amount of maturity of the neuron from which this portion is taken.
        #[prost(uint64, optional, tag = "3")]
        pub maturity_equivalent_icp_e8s: ::core::option::Option<u64>,
        /// Whether the portion specified by `amount_icp_e8s` is limited due to SNS-specific
        /// participation constraints.
        #[prost(bool, optional, tag = "5")]
        pub is_capped: ::core::option::Option<bool>,
        /// The principal that can manage the NNS neuron that participated in the Neurons' Fund.
        #[prost(message, optional, tag = "6")]
        pub controller: ::core::option::Option<::ic_base_types::PrincipalId>,
        /// The principals that can vote, propose, and follow on behalf of this neuron.
        #[prost(message, repeated, tag = "7")]
        pub hotkeys: ::prost::alloc::vec::Vec<::ic_base_types::PrincipalId>,
    }
}
/// Absolute constraints of this swap needed that the Neurons' Fund need to be aware of.
/// The fields correspond to those in Swap's `Init` message.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct SwapParticipationLimits {
    #[prost(uint64, optional, tag = "1")]
    pub min_direct_participation_icp_e8s: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub max_direct_participation_icp_e8s: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub min_participant_icp_e8s: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "4")]
    pub max_participant_icp_e8s: ::core::option::Option<u64>,
}
/// This message has a couple of unusual features.
///
/// 1. There is (currently) only one field. We expect that more fields will be
///     (and possibly other clients) to be able to handle this information in a
///     generic way, i.e. without having to change their code.
///
/// 2. Fields that might be added later will probably be mutually exclusive with
///     existing fields. Normally, this would be handled by putting all such
///     fields into a oneof. However, Candid has a bug where variant is not
///     handled correctly. Therefore, we refrain from using oneof until we believe
///     that the fix is very imminent.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct DerivedProposalInformation {
    #[prost(message, optional, tag = "1")]
    pub swap_background_information: ::core::option::Option<SwapBackgroundInformation>,
}
/// Additional information about the SNS that's being "swapped".
///
/// This data is fetched from other canisters. Currently, the swap canister
/// itself, and the root canister are queried, but additional canisters could be
/// queried later. In particular, the ID of the root canister is discovered via
/// the swap canister.
///
/// (See Governance::fetch_swap_background_information for how this is compiled.)
///
/// Obsolete. Superseded by newer fields.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct SwapBackgroundInformation {
    #[prost(message, repeated, tag = "7")]
    pub fallback_controller_principal_ids: ::prost::alloc::vec::Vec<::ic_base_types::PrincipalId>,
    #[prost(message, optional, tag = "8")]
    pub root_canister_summary: ::core::option::Option<swap_background_information::CanisterSummary>,
    #[prost(message, optional, tag = "9")]
    pub governance_canister_summary:
        ::core::option::Option<swap_background_information::CanisterSummary>,
    #[prost(message, optional, tag = "10")]
    pub ledger_canister_summary:
        ::core::option::Option<swap_background_information::CanisterSummary>,
    #[prost(message, optional, tag = "11")]
    pub swap_canister_summary: ::core::option::Option<swap_background_information::CanisterSummary>,
    #[prost(message, repeated, tag = "12")]
    pub ledger_archive_canister_summaries:
        ::prost::alloc::vec::Vec<swap_background_information::CanisterSummary>,
    #[prost(message, optional, tag = "13")]
    pub ledger_index_canister_summary:
        ::core::option::Option<swap_background_information::CanisterSummary>,
    #[prost(message, repeated, tag = "14")]
    pub dapp_canister_summaries:
        ::prost::alloc::vec::Vec<swap_background_information::CanisterSummary>,
}
/// Nested message and enum types in `SwapBackgroundInformation`.
pub mod swap_background_information {
    /// Transcribed from sns/root.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct CanisterSummary {
        #[prost(message, optional, tag = "1")]
        pub canister_id: ::core::option::Option<::ic_base_types::PrincipalId>,
        #[prost(message, optional, tag = "2")]
        pub status: ::core::option::Option<CanisterStatusResultV2>,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct CanisterStatusResultV2 {
        #[prost(enumeration = "CanisterStatusType", optional, tag = "1")]
        pub status: ::core::option::Option<i32>,
        #[prost(bytes = "vec", tag = "2")]
        #[serde(with = "serde_bytes")]
        pub module_hash: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, repeated, tag = "3")]
        pub controllers: ::prost::alloc::vec::Vec<::ic_base_types::PrincipalId>,
        #[prost(uint64, optional, tag = "4")]
        pub memory_size: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "5")]
        pub cycles: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "6")]
        pub freezing_threshold: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "7")]
        pub idle_cycles_burned_per_day: ::core::option::Option<u64>,
    }
    /// A canister can be stopped by calling stop_canister. The effect of
    /// stop_canister can be undone by calling start_canister. Stopping is an
    /// intermediate state where new method calls are rejected, but in-flight
    /// method calls are allowed to be fully serviced.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum CanisterStatusType {
        Unspecified = 0,
        Running = 1,
        Stopping = 2,
        Stopped = 3,
    }
    impl CanisterStatusType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CANISTER_STATUS_TYPE_UNSPECIFIED",
                Self::Running => "CANISTER_STATUS_TYPE_RUNNING",
                Self::Stopping => "CANISTER_STATUS_TYPE_STOPPING",
                Self::Stopped => "CANISTER_STATUS_TYPE_STOPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CANISTER_STATUS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CANISTER_STATUS_TYPE_RUNNING" => Some(Self::Running),
                "CANISTER_STATUS_TYPE_STOPPING" => Some(Self::Stopping),
                "CANISTER_STATUS_TYPE_STOPPED" => Some(Self::Stopped),
                _ => None,
            }
        }
    }
}
/// Stores data relevant to the "wait for quiet" implementation.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct WaitForQuietState {
    #[prost(uint64, tag = "1")]
    pub current_deadline_timestamp_seconds: u64,
}
/// Network economics contains the parameters for several operations related
/// to the economy of the network. When submitting a NetworkEconomics proposal
/// default values (0) are considered unchanged, so a valid proposal only needs
/// to set the parameters that it wishes to change.
/// In other words, it's not possible to set any of the values of
/// NetworkEconomics to 0.
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable)]
#[self_describing]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEconomics {
    /// The number of E8s (10E-8 of an ICP token) that a rejected
    /// proposal will cost.
    ///
    /// This fee should be controlled by an #Economic proposal type.
    /// The fee does not apply for ManageNeuron proposals.
    #[prost(uint64, tag = "1")]
    pub reject_cost_e8s: u64,
    /// The minimum number of E8s that can be staked in a neuron.
    #[prost(uint64, tag = "2")]
    pub neuron_minimum_stake_e8s: u64,
    /// The number of E8s (10E-8 of an ICP token) that it costs to
    /// employ the 'manage neuron' functionality through proposals. The
    /// cost is incurred by the neuron that makes the 'manage neuron'
    /// proposal and is applied regardless of whether the proposal is
    /// adopted or rejected.
    #[prost(uint64, tag = "4")]
    pub neuron_management_fee_per_proposal_e8s: u64,
    /// The minimum number that the ICP/XDR conversion rate can be set to.
    ///
    /// Measured in XDR (the currency code of IMF SDR) to two decimal
    /// places.
    ///
    /// See /rs/protobuf/def/registry/conversion_rate/v1/conversion_rate.proto
    /// for more information on the rate itself.
    #[prost(uint64, tag = "5")]
    pub minimum_icp_xdr_rate: u64,
    /// The dissolve delay of a neuron spawned from the maturity of an
    /// existing neuron.
    #[prost(uint64, tag = "6")]
    pub neuron_spawn_dissolve_delay_seconds: u64,
    /// The maximum rewards to be distributed to NodeProviders in a single
    /// distribution event, in e8s.
    #[prost(uint64, tag = "8")]
    pub maximum_node_provider_rewards_e8s: u64,
    /// The transaction fee that must be paid for each ledger transaction.
    #[prost(uint64, tag = "9")]
    pub transaction_fee_e8s: u64,
    /// The maximum number of proposals to keep, per topic for eligible topics.
    /// When the total number of proposals for a given topic is greater than this
    /// number, the oldest proposals that have reached a "final" state
    /// may be deleted.
    ///
    /// If unspecified or zero, all proposals are kept.
    #[prost(uint32, tag = "10")]
    pub max_proposals_to_keep_per_topic: u32,
    /// Global Neurons' Fund participation thresholds.
    #[prost(message, optional, tag = "11")]
    pub neurons_fund_economics: ::core::option::Option<NeuronsFundEconomics>,
    /// Parameters that affect the voting power of neurons.
    #[prost(message, optional, tag = "12")]
    pub voting_power_economics: ::core::option::Option<VotingPowerEconomics>,
}
/// Parameters that affect the voting power of neurons.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct VotingPowerEconomics {
    /// If a neuron has not "refreshed" its voting power after this amount of time,
    /// its deciding voting power starts decreasing linearly. See also
    /// clear_following_after_seconds.
    ///
    /// For explanation of what "refresh" means in this context, see
    /// <https://dashboard.internetcomputer.org/proposal/132411>
    ///
    /// Initially, set to 0.5 years. (The nominal length of a year is 365.25 days).
    #[prost(uint64, optional, tag = "1")]
    pub start_reducing_voting_power_after_seconds: ::core::option::Option<u64>,
    /// After a neuron has experienced voting power reduction for this amount of
    /// time, a couple of things happen:
    ///
    ///      1. Deciding voting power reaches 0.
    ///
    ///      2. Its following on topics other than NeuronManagement are cleared.
    ///
    /// Initially, set to 1/12 years.
    #[prost(uint64, optional, tag = "2")]
    pub clear_following_after_seconds: ::core::option::Option<u64>,
    /// The minimum dissolve delay a neuron must have in order to be eligible to vote.
    ///
    /// Neurons with a dissolve delay lower than this threshold will not have
    /// voting power, even if they are otherwise active.
    ///
    /// This value is an essential part of the staking mechanism, promoting
    /// long-term alignment with the network's governance.
    #[prost(uint64, optional, tag = "3")]
    pub neuron_minimum_dissolve_delay_to_vote_seconds: ::core::option::Option<u64>,
}
/// The thresholds specify the shape of the ideal matching function used by the Neurons' Fund to
/// determine how much to contribute for a given direct participation amount. Note that the actual
/// swap participation is in ICP, whereas these thresholds are specifid in XDR; the conversion rate
/// is determined at the time of execution of the CreateServiceNervousSystem proposal.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct NeuronsFundMatchedFundingCurveCoefficients {
    /// Up to this amount of direct participation, the Neurons' Fund does not contribute to this SNS.
    #[prost(message, optional, tag = "1")]
    pub contribution_threshold_xdr:
        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
    /// Say the direct participation amount is `x_icp`. When `x_icp` equals the equavalent of
    /// `one_third_participation_milestone_xdr` in ICP (we use ICP/XDR conversion data from the CMC),
    /// the Neurons' Fund contributes 50% on top of that amount, so the overall contributions would
    /// be `1.5 * x_icp` of which 1/3 comes from the Neurons' Fund.
    #[prost(message, optional, tag = "2")]
    pub one_third_participation_milestone_xdr:
        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
    /// Say the direct participation amount is `x_icp`. When `x_icp` equals the equavalent of
    /// `full_participation_milestone_xdr` in ICP (we use ICP/XDR conversion data from the CMC),
    /// the Neurons' Fund contributes 100% on top of that amount, so the overall contributions would
    /// be `2.0 * x_icp` of which a half comes from the Neurons' Fund.
    #[prost(message, optional, tag = "3")]
    pub full_participation_milestone_xdr:
        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
}
/// When the Neurons' Fund decides to participates in an SNS swap, the amount of participation is
/// determined according to the rules of Matched Funding. The amount of ICP tokens contributed by
/// the Neurons' Fund depends on four factors:
/// (1) Direct participation amount at the time of the swap's successful finalization.
/// (2) Amount of maturity held by all eligible neurons that were members of the Neurons' Fund
///      at the time of the CreateServiceNervousSystem proposal execution.
/// (3) Global Neurons' Fund participation thresholds, held in this structure (defined in XDR).
/// (4) ICP/XDR conversion rate at the time of the CreateServiceNervousSystem proposal execution.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct NeuronsFundEconomics {
    /// This is a theoretical limit which should be smaller than any realistic amount of maturity
    /// that practically needs to be reserved from the Neurons' Fund for a given SNS swap.
    #[prost(message, optional, tag = "1")]
    pub max_theoretical_neurons_fund_participation_amount_xdr:
        ::core::option::Option<::ic_nervous_system_proto::pb::v1::Decimal>,
    /// Thresholds specifying the shape of the matching function used by the Neurons' Fund to
    /// determine how much to contribute for a given direct participation amount.
    #[prost(message, optional, tag = "2")]
    pub neurons_fund_matched_funding_curve_coefficients:
        ::core::option::Option<NeuronsFundMatchedFundingCurveCoefficients>,
    /// The minimum value of the ICP/XDR conversion rate used by the Neurons' Fund for converting
    /// XDR values into ICP.
    #[prost(message, optional, tag = "3")]
    pub minimum_icp_xdr_rate: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Percentage>,
    /// The maximum value of the ICP/XDR conversion rate used by the Neurons' Fund for converting
    /// XDR values into ICP.
    #[prost(message, optional, tag = "4")]
    pub maximum_icp_xdr_rate: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Percentage>,
}
/// A reward event is an event at which neuron maturity is increased
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct RewardEvent {
    /// This reward event correspond to a time interval that ends at the end of
    /// genesis + day_after_genesis days.
    ///
    /// For instance: when this is 0, this is for a period that ends at genesis -- there can
    /// never be a reward for this.
    ///
    /// When this is 1, this is for the first day after genesis.
    ///
    /// On rare occasions, the reward event may cover several days ending at genesis + day_after_genesis days,
    /// when it was not possible to proceed to a reward event for a while. This makes that day_after_genesis
    /// does not have to be consecutive.
    #[prost(uint64, tag = "1")]
    pub day_after_genesis: u64,
    /// The timestamp at which this reward event took place, in seconds since the unix epoch.
    ///
    /// This does not match the date taken into account for reward computation, which
    /// should always be an integer number of days after genesis.
    #[prost(uint64, tag = "2")]
    pub actual_timestamp_seconds: u64,
    /// The list of proposals that were taken into account during
    /// this reward event.
    #[prost(message, repeated, tag = "3")]
    pub settled_proposals: ::prost::alloc::vec::Vec<::ic_nns_common::pb::v1::ProposalId>,
    /// The total amount of reward that was distributed during this reward event.
    ///
    /// The unit is "e8s equivalent" to insist that, while this quantity is on
    /// the same scale as ICPs, maturity is not directly convertible to ICPs:
    /// conversion requires a minting event to spawn a new neuron.
    #[prost(uint64, tag = "4")]
    pub distributed_e8s_equivalent: u64,
    /// The total amount of rewards that was available during the reward event.
    #[prost(uint64, tag = "5")]
    pub total_available_e8s_equivalent: u64,
    /// The amount of rewards that was available during the last round included in
    /// this event. This will only be different from `total_available_e8s_equivalent`
    /// if there were "rollover rounds" included in this event.
    #[prost(uint64, optional, tag = "7")]
    pub latest_round_available_e8s_equivalent: ::core::option::Option<u64>,
    /// In some cases, the rewards that would have been distributed in one round are
    /// "rolled over" into the next reward event. This field keeps track of how many
    /// rounds have passed since the last time rewards were distributed (rather
    /// than being rolled over).
    ///
    /// For the genesis reward event, this field will be zero.
    ///
    /// In normal operation, this field will almost always be 1. There are two
    /// reasons that rewards might not be distributed in a given round.
    ///
    /// 1. "Missed" rounds: there was a long period when we did calculate rewards
    ///     (longer than 1 round). (I.e. distribute_rewards was not called by
    ///     heartbeat for whatever reason, most likely some kind of bug.)
    ///
    /// 2. Rollover: We tried to distribute rewards, but there were no proposals
    ///     settled to distribute rewards for.
    ///
    /// In both of these cases, the rewards purse rolls over into the next round.
    #[prost(uint64, optional, tag = "6")]
    pub rounds_since_last_distribution: ::core::option::Option<u64>,
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct KnownNeuron {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<::ic_nns_common::pb::v1::NeuronId>,
    #[prost(message, optional, tag = "2")]
    pub known_neuron_data: ::core::option::Option<KnownNeuronData>,
}
/// Known neurons have extra information (a name and optionally a description) that can be used to identify them.
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable, Eq)]
#[compare_default]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KnownNeuronData {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub links: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "Topic", repeated, tag = "4")]
    pub committed_topics: ::prost::alloc::vec::Vec<i32>,
}
/// Proposal action to deregister a known neuron by removing its name and description.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct DeregisterKnownNeuron {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<::ic_nns_common::pb::v1::NeuronId>,
}
/// Proposal action to call the "open" method of an SNS token swap canister.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct OpenSnsTokenSwap {
    /// The ID of the canister where the command will be sent (assuming that the
    /// proposal is adopted, of course).
    #[prost(message, optional, tag = "1")]
    pub target_swap_canister_id: ::core::option::Option<::ic_base_types::PrincipalId>,
    /// Various limits on the swap.
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<::ic_sns_swap::pb::v1::Params>,
    /// The amount that the community fund will collectively spend in maturity on
    /// the swap.
    #[prost(uint64, optional, tag = "3")]
    pub community_fund_investment_e8s: ::core::option::Option<u64>,
}
/// Mainly, calls the deploy_new_sns Candid method on the SNS-WASMs canister.
/// Therefore, most of the fields here have equivalents in SnsInitPayload.
/// Please, consult the comments therein.
///
/// Metadata
/// --------
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct CreateServiceNervousSystem {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub logo: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Image>,
    #[prost(message, repeated, tag = "5")]
    pub fallback_controller_principal_ids: ::prost::alloc::vec::Vec<::ic_base_types::PrincipalId>,
    #[prost(message, repeated, tag = "6")]
    pub dapp_canisters: ::prost::alloc::vec::Vec<::ic_nervous_system_proto::pb::v1::Canister>,
    #[prost(message, optional, tag = "7")]
    pub initial_token_distribution:
        ::core::option::Option<create_service_nervous_system::InitialTokenDistribution>,
    #[prost(message, optional, tag = "8")]
    pub swap_parameters: ::core::option::Option<create_service_nervous_system::SwapParameters>,
    #[prost(message, optional, tag = "9")]
    pub ledger_parameters: ::core::option::Option<create_service_nervous_system::LedgerParameters>,
    #[prost(message, optional, tag = "10")]
    pub governance_parameters:
        ::core::option::Option<create_service_nervous_system::GovernanceParameters>,
}
/// Nested message and enum types in `CreateServiceNervousSystem`.
pub mod create_service_nervous_system {
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct InitialTokenDistribution {
        #[prost(message, optional, tag = "1")]
        pub developer_distribution:
            ::core::option::Option<initial_token_distribution::DeveloperDistribution>,
        #[prost(message, optional, tag = "2")]
        pub treasury_distribution:
            ::core::option::Option<initial_token_distribution::TreasuryDistribution>,
        #[prost(message, optional, tag = "3")]
        pub swap_distribution: ::core::option::Option<initial_token_distribution::SwapDistribution>,
    }
    /// Nested message and enum types in `InitialTokenDistribution`.
    pub mod initial_token_distribution {
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            PartialEq,
            ::prost::Message,
        )]
        pub struct DeveloperDistribution {
            #[prost(message, repeated, tag = "1")]
            pub developer_neurons:
                ::prost::alloc::vec::Vec<developer_distribution::NeuronDistribution>,
        }
        /// Nested message and enum types in `DeveloperDistribution`.
        pub mod developer_distribution {
            #[derive(
                candid::CandidType,
                candid::Deserialize,
                serde::Serialize,
                comparable::Comparable,
                Clone,
                PartialEq,
                ::prost::Message,
            )]
            pub struct NeuronDistribution {
                #[prost(message, optional, tag = "1")]
                pub controller: ::core::option::Option<::ic_base_types::PrincipalId>,
                #[prost(message, optional, tag = "2")]
                pub dissolve_delay:
                    ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
                #[prost(uint64, optional, tag = "3")]
                pub memo: ::core::option::Option<u64>,
                #[prost(message, optional, tag = "4")]
                pub stake: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
                #[prost(message, optional, tag = "5")]
                pub vesting_period:
                    ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
            }
        }
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            Copy,
            PartialEq,
            ::prost::Message,
        )]
        pub struct TreasuryDistribution {
            #[prost(message, optional, tag = "1")]
            pub total: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        }
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            Copy,
            PartialEq,
            ::prost::Message,
        )]
        pub struct SwapDistribution {
            #[prost(message, optional, tag = "1")]
            pub total: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        }
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct SwapParameters {
        #[prost(uint64, optional, tag = "1")]
        pub minimum_participants: ::core::option::Option<u64>,
        #[prost(message, optional, tag = "2")]
        pub minimum_icp: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        #[prost(message, optional, tag = "3")]
        pub maximum_icp: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        #[prost(message, optional, tag = "12")]
        pub minimum_direct_participation_icp:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        #[prost(message, optional, tag = "13")]
        pub maximum_direct_participation_icp:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        #[prost(message, optional, tag = "4")]
        pub minimum_participant_icp:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        #[prost(message, optional, tag = "5")]
        pub maximum_participant_icp:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        #[prost(message, optional, tag = "6")]
        pub neuron_basket_construction_parameters:
            ::core::option::Option<swap_parameters::NeuronBasketConstructionParameters>,
        #[prost(string, optional, tag = "7")]
        pub confirmation_text: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "8")]
        pub restricted_countries:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Countries>,
        /// The swap occurs at a specific time of day, in UTC.
        /// It will happen the first time start_time occurs that's at least 24h after
        /// the proposal is adopted.
        #[prost(message, optional, tag = "9")]
        pub start_time: ::core::option::Option<::ic_nervous_system_proto::pb::v1::GlobalTimeOfDay>,
        #[prost(message, optional, tag = "10")]
        pub duration: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
        /// The amount that the Neuron's Fund will collectively spend in maturity on
        /// the swap.
        #[prost(message, optional, tag = "11")]
        pub neurons_fund_investment_icp:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        /// Whether Neurons' Fund participation is requested.
        /// Cannot be set to true until Matched Funding is released
        #[prost(bool, optional, tag = "14")]
        pub neurons_fund_participation: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `SwapParameters`.
    pub mod swap_parameters {
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            Copy,
            PartialEq,
            ::prost::Message,
        )]
        pub struct NeuronBasketConstructionParameters {
            #[prost(uint64, optional, tag = "1")]
            pub count: ::core::option::Option<u64>,
            #[prost(message, optional, tag = "2")]
            pub dissolve_delay_interval:
                ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
        }
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct LedgerParameters {
        #[prost(message, optional, tag = "1")]
        pub transaction_fee: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        #[prost(string, optional, tag = "2")]
        pub token_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub token_symbol: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "4")]
        pub token_logo: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Image>,
    }
    /// Proposal Parameters
    /// -------------------
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct GovernanceParameters {
        #[prost(message, optional, tag = "1")]
        pub proposal_rejection_fee:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        #[prost(message, optional, tag = "2")]
        pub proposal_initial_voting_period:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
        #[prost(message, optional, tag = "3")]
        pub proposal_wait_for_quiet_deadline_increase:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
        #[prost(message, optional, tag = "4")]
        pub neuron_minimum_stake: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Tokens>,
        #[prost(message, optional, tag = "5")]
        pub neuron_minimum_dissolve_delay_to_vote:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
        #[prost(message, optional, tag = "6")]
        pub neuron_maximum_dissolve_delay:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
        #[prost(message, optional, tag = "7")]
        pub neuron_maximum_dissolve_delay_bonus:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Percentage>,
        #[prost(message, optional, tag = "8")]
        pub neuron_maximum_age_for_age_bonus:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
        #[prost(message, optional, tag = "9")]
        pub neuron_maximum_age_bonus:
            ::core::option::Option<::ic_nervous_system_proto::pb::v1::Percentage>,
        #[prost(message, optional, tag = "10")]
        pub voting_reward_parameters:
            ::core::option::Option<governance_parameters::VotingRewardParameters>,
    }
    /// Nested message and enum types in `GovernanceParameters`.
    pub mod governance_parameters {
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            Copy,
            PartialEq,
            ::prost::Message,
        )]
        pub struct VotingRewardParameters {
            #[prost(message, optional, tag = "1")]
            pub initial_reward_rate:
                ::core::option::Option<::ic_nervous_system_proto::pb::v1::Percentage>,
            #[prost(message, optional, tag = "2")]
            pub final_reward_rate:
                ::core::option::Option<::ic_nervous_system_proto::pb::v1::Percentage>,
            #[prost(message, optional, tag = "3")]
            pub reward_rate_transition_duration:
                ::core::option::Option<::ic_nervous_system_proto::pb::v1::Duration>,
        }
    }
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct InstallCode {
    /// The target canister ID to call install_code on. Required.
    #[prost(message, optional, tag = "1")]
    pub canister_id: ::core::option::Option<::ic_base_types::PrincipalId>,
    /// The install mode. Either install, reinstall, or upgrade. Required.
    #[prost(enumeration = "install_code::CanisterInstallMode", optional, tag = "2")]
    pub install_mode: ::core::option::Option<i32>,
    /// The wasm module to install. required.
    #[prost(bytes = "vec", optional, tag = "3")]
    #[serde(deserialize_with = "ic_utils::deserialize::deserialize_option_blob")]
    pub wasm_module: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The arg to pass to the canister. Optional.
    #[prost(bytes = "vec", optional, tag = "4")]
    #[serde(deserialize_with = "ic_utils::deserialize::deserialize_option_blob")]
    pub arg: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Whether to skip stopping the canister before installing. Optional. Default is false.
    #[prost(bool, optional, tag = "5")]
    pub skip_stopping_before_installing: ::core::option::Option<bool>,
    /// The hash of the wasm module to install. Calculated from `wasm_module` when proposal is created.
    #[prost(bytes = "vec", optional, tag = "6")]
    pub wasm_module_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// The hash of the arg to pass to the canister. Calculated from `arg` when proposal is created.
    #[prost(bytes = "vec", optional, tag = "7")]
    pub arg_hash: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Nested message and enum types in `InstallCode`.
pub mod install_code {
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum CanisterInstallMode {
        Unspecified = 0,
        Install = 1,
        Reinstall = 2,
        Upgrade = 3,
    }
    impl CanisterInstallMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CANISTER_INSTALL_MODE_UNSPECIFIED",
                Self::Install => "CANISTER_INSTALL_MODE_INSTALL",
                Self::Reinstall => "CANISTER_INSTALL_MODE_REINSTALL",
                Self::Upgrade => "CANISTER_INSTALL_MODE_UPGRADE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CANISTER_INSTALL_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CANISTER_INSTALL_MODE_INSTALL" => Some(Self::Install),
                "CANISTER_INSTALL_MODE_REINSTALL" => Some(Self::Reinstall),
                "CANISTER_INSTALL_MODE_UPGRADE" => Some(Self::Upgrade),
                _ => None,
            }
        }
    }
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct StopOrStartCanister {
    /// The target canister ID to call stop_canister or start_canister on. The canister must be
    /// controlled by NNS Root, and it cannot be NNS Governance or Lifeline. Required.
    #[prost(message, optional, tag = "1")]
    pub canister_id: ::core::option::Option<::ic_base_types::PrincipalId>,
    #[prost(
        enumeration = "stop_or_start_canister::CanisterAction",
        optional,
        tag = "2"
    )]
    pub action: ::core::option::Option<i32>,
}
/// Nested message and enum types in `StopOrStartCanister`.
pub mod stop_or_start_canister {
    /// The action to take on the canister. Required.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum CanisterAction {
        Unspecified = 0,
        Stop = 1,
        Start = 2,
    }
    impl CanisterAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CANISTER_ACTION_UNSPECIFIED",
                Self::Stop => "CANISTER_ACTION_STOP",
                Self::Start => "CANISTER_ACTION_START",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CANISTER_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "CANISTER_ACTION_STOP" => Some(Self::Stop),
                "CANISTER_ACTION_START" => Some(Self::Start),
                _ => None,
            }
        }
    }
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct UpdateCanisterSettings {
    /// The target canister ID to call update_settings on. Required.
    #[prost(message, optional, tag = "1")]
    pub canister_id: ::core::option::Option<::ic_base_types::PrincipalId>,
    /// The settings to update. Required.
    #[prost(message, optional, tag = "2")]
    pub settings: ::core::option::Option<update_canister_settings::CanisterSettings>,
}
/// Nested message and enum types in `UpdateCanisterSettings`.
pub mod update_canister_settings {
    /// The controllers of the canister. We use a message to wrap the repeated field because prost does
    /// not generate `Option<Vec<T>>` for repeated fields.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Controllers {
        /// The controllers of the canister.
        #[prost(message, repeated, tag = "1")]
        pub controllers: ::prost::alloc::vec::Vec<::ic_base_types::PrincipalId>,
    }
    /// The CanisterSettings struct as defined in the ic-interface-spec
    /// <https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-candid.>
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct CanisterSettings {
        #[prost(message, optional, tag = "1")]
        pub controllers: ::core::option::Option<Controllers>,
        #[prost(uint64, optional, tag = "2")]
        pub compute_allocation: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "3")]
        pub memory_allocation: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "4")]
        pub freezing_threshold: ::core::option::Option<u64>,
        #[prost(enumeration = "LogVisibility", optional, tag = "5")]
        pub log_visibility: ::core::option::Option<i32>,
        #[prost(uint64, optional, tag = "6")]
        pub wasm_memory_limit: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "7")]
        pub wasm_memory_threshold: ::core::option::Option<u64>,
    }
    /// Log visibility of a canister.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum LogVisibility {
        Unspecified = 0,
        /// The log is visible to the controllers of the dapp canister.
        Controllers = 1,
        /// The log is visible to the public.
        Public = 2,
    }
    impl LogVisibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOG_VISIBILITY_UNSPECIFIED",
                Self::Controllers => "LOG_VISIBILITY_CONTROLLERS",
                Self::Public => "LOG_VISIBILITY_PUBLIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOG_VISIBILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "LOG_VISIBILITY_CONTROLLERS" => Some(Self::Controllers),
                "LOG_VISIBILITY_PUBLIC" => Some(Self::Public),
                _ => None,
            }
        }
    }
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct FulfillSubnetRentalRequest {
    #[prost(message, optional, tag = "1")]
    pub user: ::core::option::Option<::ic_base_types::PrincipalId>,
    #[prost(message, repeated, tag = "3")]
    pub node_ids: ::prost::alloc::vec::Vec<::ic_base_types::PrincipalId>,
    #[prost(string, tag = "2")]
    pub replica_version_id: ::prost::alloc::string::String,
}
/// This represents the whole NNS governance system. It contains all
/// information about the NNS governance system that must be kept
/// across upgrades of the NNS governance system.
#[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable)]
#[compare_default]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Governance {
    /// Proposals.
    #[prost(btree_map = "uint64, message", tag = "2")]
    pub proposals: ::prost::alloc::collections::BTreeMap<u64, ProposalData>,
    /// The transfers that have been made to stake new neurons, but
    /// haven't been claimed by the user, yet.
    #[prost(message, repeated, tag = "3")]
    pub to_claim_transfers: ::prost::alloc::vec::Vec<NeuronStakeTransfer>,
    /// Also known as the 'normal voting period'. The maximum time a
    /// proposal (of a topic with "normal" voting period) is open for
    /// voting. If a proposal has not been decided (adopted or rejected)
    /// within this time since the proposal was made, the proposal is
    /// rejected.
    ///
    /// See also `short_voting_period_seconds`.
    #[prost(uint64, tag = "5")]
    pub wait_for_quiet_threshold_seconds: u64,
    /// The network economics configuration parameters.
    #[prost(message, optional, tag = "8")]
    pub economics: ::core::option::Option<NetworkEconomics>,
    /// The last reward event. Should never be missing.
    #[prost(message, optional, tag = "9")]
    pub latest_reward_event: ::core::option::Option<RewardEvent>,
    /// Set of in-flight neuron ledger commands.
    ///
    /// Whenever we issue a ledger transfer (for disburse, split, spawn etc)
    /// we store it in this map, keyed by the id of the neuron being changed
    /// and remove the entry when it completes.
    ///
    /// An entry being present in this map acts like a "lock" on the neuron
    /// and thus prevents concurrent changes that might happen due to the
    /// interleaving of user requests and callback execution.
    ///
    /// If there are no ongoing requests, this map should be empty.
    ///
    /// If something goes fundamentally wrong (say we trap at some point
    /// after issuing a transfer call) the neuron(s) involved are left in a
    /// "locked" state, meaning new operations can't be applied without
    /// reconciling the state.
    ///
    /// Because we know exactly what was going on, we should have the
    /// information necessary to reconcile the state, using custom code
    /// added on upgrade, if necessary.
    #[prost(map = "fixed64, message", tag = "10")]
    pub in_flight_commands: ::std::collections::HashMap<u64, governance::NeuronInFlightCommand>,
    /// The timestamp, in seconds since the unix epoch, at which `canister_init` was run for
    /// the governance canister, considered
    /// the genesis of the IC for reward purposes.
    #[prost(uint64, tag = "11")]
    pub genesis_timestamp_seconds: u64,
    /// The entities that own the nodes running the IC.
    #[prost(message, repeated, tag = "12")]
    pub node_providers: ::prost::alloc::vec::Vec<NodeProvider>,
    /// Default followees
    ///
    /// A map of Topic (as i32) to Neuron id that is set as the default
    /// following for all neurons created post-genesis.
    ///
    /// On initialization it's required that the Neurons present in this
    /// map are present in the initial set of neurons.
    ///
    /// Default following can be changed via proposal.
    #[prost(map = "int32, message", tag = "13")]
    pub default_followees: ::std::collections::HashMap<i32, Followees>,
    /// The maximum time a proposal of a topic with *short voting period*
    /// is open for voting. If a proposal on a topic with short voting
    /// period has not been decided (adopted or rejected) within this
    /// time since the proposal was made, the proposal is rejected.
    /// The short voting period is used for proposals that don't make sense to vote
    /// on if the proposal is "old". For example, proposals to set the exchange
    /// rate should not be voted on if they're days old because exchange rates
    /// fluctuate regularly. Currently, only proposals to set the exchange rate
    /// use the short voting period, and such proposals are deprecated.
    #[prost(uint64, tag = "14")]
    pub short_voting_period_seconds: u64,
    /// The maximum time a proposal of a topic with *private voting period*
    /// is open for voting. If a proposal on a topic with short voting
    /// period has not been decided (adopted or rejected) within this
    /// time since the proposal was made, the proposal is rejected.
    /// This is useful for proposals that are for "private matters" like
    /// NeuronManagement proposals. These proposals are not meant to be voted on
    /// by the general public and have limited impact, so a different voting period
    /// is appropriate.
    #[prost(uint64, optional, tag = "25")]
    pub neuron_management_voting_period_seconds: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "15")]
    pub metrics: ::core::option::Option<governance::GovernanceCachedMetrics>,
    #[prost(message, optional, tag = "16")]
    pub most_recent_monthly_node_provider_rewards:
        ::core::option::Option<MonthlyNodeProviderRewards>,
    /// Cached value for the maturity modulation as calculated each day.
    #[prost(int32, optional, tag = "17")]
    pub cached_daily_maturity_modulation_basis_points: ::core::option::Option<i32>,
    /// The last time that the maturity modulation value was updated.
    #[prost(uint64, optional, tag = "18")]
    pub maturity_modulation_last_updated_at_timestamp_seconds: ::core::option::Option<u64>,
    /// Whether the heartbeat function is currently spawning neurons, meaning
    /// that it should finish before being called again.
    #[prost(bool, optional, tag = "19")]
    pub spawning_neurons: ::core::option::Option<bool>,
    /// Local cache for XDR-related conversion rates (the source of truth is in the CMC canister).
    #[prost(message, optional, tag = "26")]
    pub xdr_conversion_rate: ::core::option::Option<XdrConversionRate>,
    /// The summary of restore aging event.
    #[prost(message, optional, tag = "27")]
    pub restore_aging_summary: ::core::option::Option<RestoreAgingSummary>,
    /// Used to initialize an internal pseudorandom number generator. This gets replaced periodically using a secure
    /// source of randomness (from the platform)
    #[prost(bytes = "vec", optional, tag = "28")]
    pub rng_seed: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Map of proposal IDs to their topics for those garbage collected.
    #[prost(map = "uint64, enumeration(Topic)", tag = "29")]
    pub topic_of_garbage_collected_proposals: ::std::collections::HashMap<u64, i32>,
}
/// Nested message and enum types in `Governance`.
pub mod governance {
    /// The possible commands that require interaction with the ledger.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct NeuronInFlightCommand {
        /// The timestamp at which the command was issued, for debugging
        /// purposes.
        #[prost(uint64, tag = "1")]
        pub timestamp: u64,
        #[prost(
            oneof = "neuron_in_flight_command::Command",
            tags = "2, 3, 5, 7, 8, 9, 10, 20, 21, 22"
        )]
        pub command: ::core::option::Option<neuron_in_flight_command::Command>,
    }
    /// Nested message and enum types in `NeuronInFlightCommand`.
    pub mod neuron_in_flight_command {
        /// A general place holder for sync commands. The neuron lock is
        /// never left holding a sync command (as it either succeeds to
        /// acquire the lock and releases it in the same call, or never
        /// acquires it in the first place), but it still must be acquired
        /// to prevent interleaving with another async command. Thus there's
        /// no value in actually storing the command itself, and this placeholder
        /// can generally be used in all sync cases.
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            Copy,
            PartialEq,
            ::prost::Message,
        )]
        pub struct SyncCommand {}
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            PartialEq,
            ::prost::Oneof,
        )]
        pub enum Command {
            #[prost(message, tag = "2")]
            Disburse(super::super::manage_neuron::Disburse),
            #[prost(message, tag = "3")]
            Split(super::super::manage_neuron::Split),
            #[prost(message, tag = "5")]
            DisburseToNeuron(super::super::manage_neuron::DisburseToNeuron),
            #[prost(message, tag = "7")]
            MergeMaturity(super::super::manage_neuron::MergeMaturity),
            #[prost(message, tag = "8")]
            ClaimOrRefreshNeuron(super::super::manage_neuron::ClaimOrRefresh),
            #[prost(message, tag = "9")]
            Configure(super::super::manage_neuron::Configure),
            #[prost(message, tag = "10")]
            Merge(super::super::manage_neuron::Merge),
            /// Below are not really `ManageNeuron` commands but determined by the context of where the
            /// neuron lock is needed. Ideally, we'd like to rename from `command` to `lock`
            #[prost(message, tag = "20")]
            Spawn(::ic_nns_common::pb::v1::NeuronId),
            #[prost(message, tag = "21")]
            SyncCommand(SyncCommand),
            #[prost(message, tag = "22")]
            FinalizeDisburseMaturity(super::super::FinalizeDisburseMaturity),
        }
    }
    /// Stores metrics that are too costly to compute each time metrics are
    /// requested. For bucketed metrics, keys are bucket IDs, i.e., number of full
    /// half-year dissolve delay intervals of neurons counted towards this bucket.
    #[derive(candid::CandidType, candid::Deserialize, serde::Serialize, comparable::Comparable)]
    #[compare_default]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GovernanceCachedMetrics {
        #[prost(uint64, tag = "1")]
        pub timestamp_seconds: u64,
        #[prost(uint64, tag = "2")]
        pub total_supply_icp: u64,
        #[prost(uint64, tag = "3")]
        pub dissolving_neurons_count: u64,
        #[prost(map = "uint64, double", tag = "4")]
        pub dissolving_neurons_e8s_buckets: ::std::collections::HashMap<u64, f64>,
        #[prost(map = "uint64, uint64", tag = "5")]
        pub dissolving_neurons_count_buckets: ::std::collections::HashMap<u64, u64>,
        #[prost(uint64, tag = "6")]
        pub not_dissolving_neurons_count: u64,
        #[prost(map = "uint64, double", tag = "7")]
        pub not_dissolving_neurons_e8s_buckets: ::std::collections::HashMap<u64, f64>,
        #[prost(map = "uint64, uint64", tag = "8")]
        pub not_dissolving_neurons_count_buckets: ::std::collections::HashMap<u64, u64>,
        #[prost(uint64, tag = "9")]
        pub dissolved_neurons_count: u64,
        #[prost(uint64, tag = "10")]
        pub dissolved_neurons_e8s: u64,
        #[prost(uint64, tag = "11")]
        pub garbage_collectable_neurons_count: u64,
        #[prost(uint64, tag = "12")]
        pub neurons_with_invalid_stake_count: u64,
        #[prost(uint64, tag = "13")]
        pub total_staked_e8s: u64,
        #[prost(uint64, tag = "14")]
        pub neurons_with_less_than_6_months_dissolve_delay_count: u64,
        #[prost(uint64, tag = "15")]
        pub neurons_with_less_than_6_months_dissolve_delay_e8s: u64,
        #[prost(uint64, tag = "16")]
        pub community_fund_total_staked_e8s: u64,
        #[prost(uint64, tag = "17")]
        pub community_fund_total_maturity_e8s_equivalent: u64,
        #[prost(uint64, tag = "25")]
        pub neurons_fund_total_active_neurons: u64,
        #[prost(uint64, tag = "18")]
        pub total_locked_e8s: u64,
        #[prost(uint64, tag = "19")]
        pub total_maturity_e8s_equivalent: u64,
        #[prost(uint64, tag = "20")]
        pub total_staked_maturity_e8s_equivalent: u64,
        #[prost(map = "uint64, double", tag = "21")]
        pub dissolving_neurons_staked_maturity_e8s_equivalent_buckets:
            ::std::collections::HashMap<u64, f64>,
        #[prost(uint64, tag = "22")]
        pub dissolving_neurons_staked_maturity_e8s_equivalent_sum: u64,
        #[prost(map = "uint64, double", tag = "23")]
        pub not_dissolving_neurons_staked_maturity_e8s_equivalent_buckets:
            ::std::collections::HashMap<u64, f64>,
        #[prost(uint64, tag = "24")]
        pub not_dissolving_neurons_staked_maturity_e8s_equivalent_sum: u64,
        #[prost(uint64, tag = "26")]
        pub seed_neuron_count: u64,
        #[prost(uint64, tag = "27")]
        pub ect_neuron_count: u64,
        #[prost(uint64, tag = "28")]
        pub total_staked_e8s_seed: u64,
        #[prost(uint64, tag = "29")]
        pub total_staked_e8s_ect: u64,
        #[prost(uint64, tag = "30")]
        pub total_staked_maturity_e8s_equivalent_seed: u64,
        #[prost(uint64, tag = "31")]
        pub total_staked_maturity_e8s_equivalent_ect: u64,
        #[prost(map = "uint64, double", tag = "32")]
        pub dissolving_neurons_e8s_buckets_seed: ::std::collections::HashMap<u64, f64>,
        #[prost(map = "uint64, double", tag = "33")]
        pub dissolving_neurons_e8s_buckets_ect: ::std::collections::HashMap<u64, f64>,
        #[prost(map = "uint64, double", tag = "34")]
        pub not_dissolving_neurons_e8s_buckets_seed: ::std::collections::HashMap<u64, f64>,
        #[prost(map = "uint64, double", tag = "35")]
        pub not_dissolving_neurons_e8s_buckets_ect: ::std::collections::HashMap<u64, f64>,
        #[prost(uint64, tag = "42")]
        pub spawning_neurons_count: u64,
        /// Deprecated. Use non_self_authenticating_controller_neuron_subset_metrics instead.
        #[prost(uint64, optional, tag = "36")]
        pub total_voting_power_non_self_authenticating_controller: ::core::option::Option<u64>,
        #[prost(uint64, optional, tag = "37")]
        pub total_staked_e8s_non_self_authenticating_controller: ::core::option::Option<u64>,
        #[prost(message, optional, tag = "38")]
        pub non_self_authenticating_controller_neuron_subset_metrics:
            ::core::option::Option<governance_cached_metrics::NeuronSubsetMetrics>,
        #[prost(message, optional, tag = "39")]
        pub public_neuron_subset_metrics:
            ::core::option::Option<governance_cached_metrics::NeuronSubsetMetrics>,
        #[prost(message, optional, tag = "40")]
        pub declining_voting_power_neuron_subset_metrics:
            ::core::option::Option<governance_cached_metrics::NeuronSubsetMetrics>,
        #[prost(message, optional, tag = "41")]
        pub fully_lost_voting_power_neuron_subset_metrics:
            ::core::option::Option<governance_cached_metrics::NeuronSubsetMetrics>,
    }
    /// Nested message and enum types in `GovernanceCachedMetrics`.
    pub mod governance_cached_metrics {
        /// Statistics about some subset (not necessarily a proper subset) of
        /// neurons. So far, these are mostly totals.
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            PartialEq,
            ::prost::Message,
        )]
        pub struct NeuronSubsetMetrics {
            /// The values in these fields can be derived from the value in the
            /// analogous fields (declared a little lower in this message). For
            /// example, count = count_buckets.values().sum().
            #[prost(uint64, optional, tag = "1")]
            pub count: ::core::option::Option<u64>,
            #[prost(uint64, optional, tag = "2")]
            pub total_staked_e8s: ::core::option::Option<u64>,
            #[prost(uint64, optional, tag = "3")]
            pub total_staked_maturity_e8s_equivalent: ::core::option::Option<u64>,
            #[prost(uint64, optional, tag = "4")]
            pub total_maturity_e8s_equivalent: ::core::option::Option<u64>,
            /// Deprecated. Use one of the following instead.
            #[prost(uint64, optional, tag = "5")]
            pub total_voting_power: ::core::option::Option<u64>,
            /// Used to decide proposals. If all neurons refresh their voting
            /// power/following frequently enough, this will be equal to potential
            /// voting power. If not, this will be less.
            #[prost(uint64, optional, tag = "11")]
            pub total_deciding_voting_power: ::core::option::Option<u64>,
            /// Used for voting rewards.
            #[prost(uint64, optional, tag = "12")]
            pub total_potential_voting_power: ::core::option::Option<u64>,
            /// These fields are keyed by floor(dissolve delay / 0.5 years). These are
            /// analogous to the (singular) fields above. Here, the usual definition of
            /// year for the IC is used: exactly 365.25 days.
            #[prost(map = "uint64, uint64", tag = "6")]
            pub count_buckets: ::std::collections::HashMap<u64, u64>,
            #[prost(map = "uint64, uint64", tag = "7")]
            pub staked_e8s_buckets: ::std::collections::HashMap<u64, u64>,
            #[prost(map = "uint64, uint64", tag = "8")]
            pub staked_maturity_e8s_equivalent_buckets: ::std::collections::HashMap<u64, u64>,
            #[prost(map = "uint64, uint64", tag = "9")]
            pub maturity_e8s_equivalent_buckets: ::std::collections::HashMap<u64, u64>,
            /// Deprecated. Use one of the following instead.
            #[prost(map = "uint64, uint64", tag = "10")]
            pub voting_power_buckets: ::std::collections::HashMap<u64, u64>,
            #[prost(map = "uint64, uint64", tag = "13")]
            pub deciding_voting_power_buckets: ::std::collections::HashMap<u64, u64>,
            #[prost(map = "uint64, uint64", tag = "14")]
            pub potential_voting_power_buckets: ::std::collections::HashMap<u64, u64>,
        }
    }
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct XdrConversionRate {
    /// / Time at which this rate has been fetched.
    #[prost(uint64, optional, tag = "1")]
    pub timestamp_seconds: ::core::option::Option<u64>,
    /// / One ICP is worth this number of 1/10,000ths parts of an XDR.
    #[prost(uint64, optional, tag = "2")]
    pub xdr_permyriad_per_icp: ::core::option::Option<u64>,
}
/// A response to "ListKnownNeurons"
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct ListKnownNeuronsResponse {
    /// List of known neurons.
    #[prost(message, repeated, tag = "1")]
    pub known_neurons: ::prost::alloc::vec::Vec<KnownNeuron>,
}
/// Response to list_node_providers
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct ListNodeProvidersResponse {
    /// List of all "NodeProviders"
    #[prost(message, repeated, tag = "1")]
    pub node_providers: ::prost::alloc::vec::Vec<NodeProvider>,
}
/// Date UTC used in NodeProviderRewards to define their validity boundaries
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct DateUtc {
    #[prost(uint32, tag = "1")]
    pub year: u32,
    #[prost(uint32, tag = "2")]
    pub month: u32,
    #[prost(uint32, tag = "3")]
    pub day: u32,
}
/// The monthly Node Provider rewards, representing the distribution of rewards for a specific time period.
///
/// Prior to the introduction of the performance-based reward algorithm, rewards were computed from a
/// single registry snapshot (identified by `registry_version`). After performance-based rewards were enabled,
/// rewards depend on node metrics collected over a date range, making `start_date` and `end_date` essential
/// for defining the covered period. In this case, `registry_version` is no longer set.
///
/// Summary of field usage:
/// - Before performance-based rewards: `registry_version` is Some; `start_date` and `end_date` are None.
/// - After performance-based rewards:  `start_date` and `end_date` are Some; `registry_version` is None.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct MonthlyNodeProviderRewards {
    /// The time when the rewards were calculated.
    #[prost(uint64, tag = "1")]
    pub timestamp: u64,
    /// The start date (included) that these rewards cover.
    #[prost(message, optional, tag = "8")]
    pub start_date: ::core::option::Option<DateUtc>,
    /// The end date (included) that these rewards cover.
    #[prost(message, optional, tag = "9")]
    pub end_date: ::core::option::Option<DateUtc>,
    /// The Rewards calculated and rewarded.
    #[prost(message, repeated, tag = "2")]
    pub rewards: ::prost::alloc::vec::Vec<RewardNodeProvider>,
    /// The XdrConversionRate used to calculate the rewards.  This comes from the CMC canister.
    /// This field snapshots the actual rate used by governance when the rewards were calculated.
    #[prost(message, optional, tag = "3")]
    pub xdr_conversion_rate: ::core::option::Option<XdrConversionRate>,
    /// The minimum xdr permyriad per icp at the time when the rewards were calculated.  This is useful for understanding
    /// why the rewards were what they were if the xdr_conversion_rate falls below this threshold.
    #[prost(uint64, optional, tag = "4")]
    pub minimum_xdr_permyriad_per_icp: ::core::option::Option<u64>,
    /// The maximum amount of ICP e8s that can be awarded to a single node provider in one event.  This is snapshotted
    /// from the value in network economics.
    #[prost(uint64, optional, tag = "5")]
    pub maximum_node_provider_rewards_e8s: ::core::option::Option<u64>,
    /// The registry version used to calculate these rewards at the time the rewards were calculated.
    #[prost(uint64, optional, tag = "6")]
    pub registry_version: ::core::option::Option<u64>,
    /// Rewards calculation algorithm version used to calculate rewards.
    #[prost(uint32, optional, tag = "10")]
    pub algorithm_version: ::core::option::Option<u32>,
    /// The list of node_provieders at the time when the rewards were calculated.
    #[prost(message, repeated, tag = "7")]
    pub node_providers: ::prost::alloc::vec::Vec<NodeProvider>,
}
/// TODO(NNS1-1589): Until the Jira ticket gets solved, changes here need to be
/// manually propagated to (sns) swap.proto.
/// This message is obsolete; please use SettleNeuronsFundParticipation instead.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct SettleCommunityFundParticipation {
    /// The caller's principal ID must match the value in the
    /// target_swap_canister_id field in the proposal (more precisely, in the
    /// OpenSnsTokenSwap).
    #[prost(uint64, optional, tag = "1")]
    pub open_sns_token_swap_proposal_id: ::core::option::Option<u64>,
    /// Each of the possibilities here corresponds to one of two ways that a swap
    /// can terminate. See also sns_swap_pb::Lifecycle::is_terminal.
    #[prost(oneof = "settle_community_fund_participation::Result", tags = "2, 3")]
    pub result: ::core::option::Option<settle_community_fund_participation::Result>,
}
/// Nested message and enum types in `SettleCommunityFundParticipation`.
pub mod settle_community_fund_participation {
    /// When this happens, ICP needs to be minted, and sent to the SNS governance
    /// canister's main account on the ICP Ledger. As with Aborted, the amount of
    /// ICP that needs to be minted can be deduced from the ProposalData's
    /// cf_participants field.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Committed {
        /// This is where the minted ICP will be sent. In principal, this could be
        /// fetched using the swap canister's get_state method.
        #[prost(message, optional, tag = "1")]
        pub sns_governance_canister_id: ::core::option::Option<::ic_base_types::PrincipalId>,
        /// Total contribution amount from direct swap participants.
        #[prost(uint64, optional, tag = "2")]
        pub total_direct_contribution_icp_e8s: ::core::option::Option<u64>,
        /// Total contribution amount from the Neuron's Fund.
        /// TODO\[NNS1-2570\]: Ensure this field is set.
        #[prost(uint64, optional, tag = "3")]
        pub total_neurons_fund_contribution_icp_e8s: ::core::option::Option<u64>,
    }
    /// When this happens, maturity needs to be restored to CF neurons. The amounts
    /// to be refunded can be found in the ProposalData's cf_participants field.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Aborted {}
    /// Each of the possibilities here corresponds to one of two ways that a swap
    /// can terminate. See also sns_swap_pb::Lifecycle::is_terminal.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Result {
        #[prost(message, tag = "2")]
        Committed(Committed),
        #[prost(message, tag = "3")]
        Aborted(Aborted),
    }
}
/// Request to settle the Neurons' Fund participation in this SNS Swap.
///
/// When a swap ends, the Swap canister notifies the Neurons' Fund of the swap's ultimate result,
/// which can be either `Committed` or `Aborted`. Note that currently, the Neurons' Fund is managed
/// by the NNS Governance canister.
/// * If the result is `Committed`:
///    - Neurons' Fund computes the "effective" participation amount for each of its neurons (as per
///      the Matched Funding rules). This computation is based on the total direct participation
///      amount, which is thus a field of `Committed`.
///    - Neurons' Fund converts the "effective" amount of maturity into ICP by:
///      - Requesting the ICP Ledger to mint an appropriate amount of ICP tokens and sending them
///        to the SNS treasury.
///      - Refunding whatever maturity is left over (the maximum possible maturity is reserved by
///        the Neurons' Fund before the swap begins).
///    - Neurons' Fund returns the Neurons' Fund participants back to the Swap canister
///      (see SettleNeuronsFundParticipationResponse).
///    - The Swap canister then creates SNS neurons for the Neurons' Fund participants.
/// * If the result is Aborted, the Neurons' Fund is refunded for all maturity reserved for this SNS.
///
/// This design assumes trust between the Neurons' Fund and the SNS Swap canisters. In the one hand,
/// the Swap trusts that the Neurons' Fund sends the correct amount of ICP to the SNS treasury,
/// and that the Neurons' Fund allocates its participants following the Matched Funding rules. On the
/// other hand, the Neurons' Fund trusts that the Swap will indeed create appropriate SNS neurons
/// for the Neurons' Fund participants.
///
/// The justification for this trust assumption is as follows. The Neurons' Fund can be trusted as
/// it is controlled by the NNS. The SNS Swap can be trusted as it is (1) deployed by SNS-W, which is
/// also part of the NNS and (2) upgraded via an NNS proposal (unlike all other SNS canisters).
///
/// This request may be submitted only by the Swap canister of an SNS instance created by
/// a CreateServiceNervousSystem proposal.
///
/// TODO(NNS1-1589): Until the Jira ticket gets solved, changes here need to be
/// manually propagated to (sns) swap.proto.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct SettleNeuronsFundParticipationRequest {
    /// Proposal ID of the CreateServiceNervousSystem proposal that created this SNS instance.
    #[prost(uint64, optional, tag = "1")]
    pub nns_proposal_id: ::core::option::Option<u64>,
    /// Each of the possibilities here corresponds to one of two ways that a swap can terminate.
    /// See also sns_swap_pb::Lifecycle::is_terminal.
    #[prost(
        oneof = "settle_neurons_fund_participation_request::Result",
        tags = "2, 3"
    )]
    pub result: ::core::option::Option<settle_neurons_fund_participation_request::Result>,
}
/// Nested message and enum types in `SettleNeuronsFundParticipationRequest`.
pub mod settle_neurons_fund_participation_request {
    /// When this happens, the NNS Governance needs to do several things:
    /// (1) Compute the effective amount of ICP per neuron of the Neurons' Fund as a function of
    ///      `total_direct_participation_icp_e8s`. The overall Neurons' Fund participation should
    ///      equal `total_neurons_fund_contribution_icp_e8s`.
    /// (2) Mint (via the ICP Ledger) and sent to the SNS governance the amount of
    ///      `total_neurons_fund_contribution_icp_e8s`.
    /// (3) Respond to this request with `SettleNeuronsFundParticipationResponse`, providing
    ///      the set of `NeuronsFundParticipant`s with the effective amount of ICP per neuron,
    ///      as computed in step (1).
    /// (4) Refund each neuron of the Neurons' Fund with (reserved - effective) amount of ICP.
    /// Effective amounts depend on `total_direct_participation_icp_e8s` and the participation limits
    /// of a particular SNS instance, namely, each participation must be between
    /// `min_participant_icp_e8s` and `max_participant_icp_e8s`.
    /// - If a neuron of the Neurons' Fund has less than `min_participant_icp_e8s` worth of maturity,
    ///    then it is ineligible to participate.
    /// - If a neuron of the Neurons' Fund has more than `max_participant_icp_e8s` worth of maturity,
    ///    then its participation amount is limited to `max_participant_icp_e8s`.
    /// Reserved amounts are computed as the minimal upper bound on the effective amounts, i.e., when
    /// the value `total_direct_participation_icp_e8s` reaches its theoretical maximum.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Committed {
        /// This is where the minted ICP will be sent.
        #[prost(message, optional, tag = "1")]
        pub sns_governance_canister_id: ::core::option::Option<::ic_base_types::PrincipalId>,
        /// Total amount of participation from direct swap participants.
        #[prost(uint64, optional, tag = "2")]
        pub total_direct_participation_icp_e8s: ::core::option::Option<u64>,
        /// Total amount of participation from the Neurons' Fund.
        /// TODO\[NNS1-2570\]: Ensure this field is set.
        #[prost(uint64, optional, tag = "3")]
        pub total_neurons_fund_participation_icp_e8s: ::core::option::Option<u64>,
    }
    /// When this happens, all priorly reserved maturity for this SNS instance needs to be restored to
    /// the Neurons' Fund neurons.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Aborted {}
    /// Each of the possibilities here corresponds to one of two ways that a swap can terminate.
    /// See also sns_swap_pb::Lifecycle::is_terminal.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Result {
        #[prost(message, tag = "2")]
        Committed(Committed),
        #[prost(message, tag = "3")]
        Aborted(Aborted),
    }
}
/// Handling the Neurons' Fund and transferring some of its maturity to an SNS treasury is
/// thus the responsibility of the NNS Governance. When a swap succeeds, a Swap canister should send
/// a `settle_neurons_fund_participation` request to the NNS Governance, specifying its `result`
/// field as `committed`. The NNS Governance then computes the ultimate distribution of maturity in
/// the Neurons' Fund. However, this distribution also needs to be made available to the SNS Swap
/// that will use this information to create SNS neurons of an appropriate size for each
/// Neurons' Fund (as well as direct) participant. That is why in the `committed` case,
/// the NNS Governance provides `neurons_fund_neuron_portions`, while in the `aborted`
/// case it does not.
///
/// TODO(NNS1-1589): Until the Jira ticket gets solved, changes here need to be
/// manually propagated to (sns) swap.proto.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct SettleNeuronsFundParticipationResponse {
    #[prost(
        oneof = "settle_neurons_fund_participation_response::Result",
        tags = "1, 2"
    )]
    pub result: ::core::option::Option<settle_neurons_fund_participation_response::Result>,
}
/// Nested message and enum types in `SettleNeuronsFundParticipationResponse`.
pub mod settle_neurons_fund_participation_response {
    /// Represents one NNS neuron from the Neurons' Fund participating in this swap.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct NeuronsFundNeuron {
        /// The NNS neuron ID of the participating neuron.
        #[prost(uint64, optional, tag = "1")]
        pub nns_neuron_id: ::core::option::Option<u64>,
        /// The amount of Neurons' Fund participation associated with this neuron.
        #[prost(uint64, optional, tag = "2")]
        pub amount_icp_e8s: ::core::option::Option<u64>,
        /// The principal that can manage the NNS neuron that participated in the Neurons' Fund.
        #[prost(message, optional, tag = "6")]
        pub controller: ::core::option::Option<::ic_base_types::PrincipalId>,
        /// The principals that can vote, propose, and follow on behalf of this neuron.
        #[prost(message, optional, tag = "7")]
        pub hotkeys: ::core::option::Option<::ic_nervous_system_proto::pb::v1::Principals>,
        /// Whether the amount maturity amount of Neurons' Fund participation associated with this neuron
        /// has been capped to reflect the maximum participation amount for this SNS swap.
        #[prost(bool, optional, tag = "4")]
        pub is_capped: ::core::option::Option<bool>,
    }
    /// Request was completed successfully.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct Ok {
        #[prost(message, repeated, tag = "1")]
        pub neurons_fund_neuron_portions: ::prost::alloc::vec::Vec<NeuronsFundNeuron>,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Result {
        #[prost(message, tag = "1")]
        Err(super::GovernanceError),
        #[prost(message, tag = "2")]
        Ok(Ok),
    }
}
/// Audit events in order to leave an audit trail for certain operations.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct AuditEvent {
    /// The timestamp of the event.
    #[prost(uint64, tag = "1")]
    pub timestamp_seconds: u64,
    #[prost(oneof = "audit_event::Payload", tags = "2, 3, 4")]
    pub payload: ::core::option::Option<audit_event::Payload>,
}
/// Nested message and enum types in `AuditEvent`.
pub mod audit_event {
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct ResetAging {
        /// The neuron id whose aging was reset.
        #[prost(fixed64, tag = "1")]
        pub neuron_id: u64,
        /// The aging_since_timestamp_seconds before reset.
        #[prost(uint64, tag = "2")]
        pub previous_aging_since_timestamp_seconds: u64,
        /// The aging_since_timestamp_seconds after reset.
        #[prost(uint64, tag = "3")]
        pub new_aging_since_timestamp_seconds: u64,
        /// Neuron's stake at the time of reset.
        #[prost(uint64, tag = "6")]
        pub neuron_stake_e8s: u64,
        /// Neuron's dissolve state at the time of reset.
        #[prost(oneof = "reset_aging::NeuronDissolveState", tags = "4, 5")]
        pub neuron_dissolve_state: ::core::option::Option<reset_aging::NeuronDissolveState>,
    }
    /// Nested message and enum types in `ResetAging`.
    pub mod reset_aging {
        /// Neuron's dissolve state at the time of reset.
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            Copy,
            PartialEq,
            ::prost::Oneof,
        )]
        pub enum NeuronDissolveState {
            #[prost(uint64, tag = "4")]
            WhenDissolvedTimestampSeconds(u64),
            #[prost(uint64, tag = "5")]
            DissolveDelaySeconds(u64),
        }
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct RestoreAging {
        /// The neuron id whose aging was restored.
        #[prost(uint64, optional, tag = "1")]
        pub neuron_id: ::core::option::Option<u64>,
        /// The aging_since_timestamp_seconds before restore.
        #[prost(uint64, optional, tag = "2")]
        pub previous_aging_since_timestamp_seconds: ::core::option::Option<u64>,
        /// The aging_since_timestamp_seconds after restore.
        #[prost(uint64, optional, tag = "3")]
        pub new_aging_since_timestamp_seconds: ::core::option::Option<u64>,
        /// Neuron's stake at the time of restore.
        #[prost(uint64, optional, tag = "6")]
        pub neuron_stake_e8s: ::core::option::Option<u64>,
        /// Neuron's dissolve state at the time of restore.
        #[prost(oneof = "restore_aging::NeuronDissolveState", tags = "4, 5")]
        pub neuron_dissolve_state: ::core::option::Option<restore_aging::NeuronDissolveState>,
    }
    /// Nested message and enum types in `RestoreAging`.
    pub mod restore_aging {
        /// Neuron's dissolve state at the time of restore.
        #[derive(
            candid::CandidType,
            candid::Deserialize,
            serde::Serialize,
            comparable::Comparable,
            Clone,
            Copy,
            PartialEq,
            ::prost::Oneof,
        )]
        pub enum NeuronDissolveState {
            #[prost(uint64, tag = "4")]
            WhenDissolvedTimestampSeconds(u64),
            #[prost(uint64, tag = "5")]
            DissolveDelaySeconds(u64),
        }
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct NormalizeDissolveStateAndAge {
        /// The neuron id whose dissolve state and age were normalized.
        #[prost(uint64, optional, tag = "1")]
        pub neuron_id: ::core::option::Option<u64>,
        /// Which legacy case the neuron falls into.
        #[prost(enumeration = "NeuronLegacyCase", tag = "2")]
        pub neuron_legacy_case: i32,
        /// Previous when_dissolved_timestamp_seconds if the neuron was dissolving or dissolved.
        #[prost(uint64, optional, tag = "3")]
        pub previous_when_dissolved_timestamp_seconds: ::core::option::Option<u64>,
        /// Previous aging_since_timestamp_seconds.
        #[prost(uint64, optional, tag = "4")]
        pub previous_aging_since_timestamp_seconds: ::core::option::Option<u64>,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum NeuronLegacyCase {
        Unspecified = 0,
        /// Neuron is dissolving or dissolved but with a non-zero age.
        DissolvingOrDissolved = 1,
        /// Neuron is dissolved with DissolveDelaySeconds(0).
        Dissolved = 2,
        /// Neuron has a None dissolve state.
        NoneDissolveState = 3,
    }
    impl NeuronLegacyCase {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "NEURON_LEGACY_CASE_UNSPECIFIED",
                Self::DissolvingOrDissolved => "NEURON_LEGACY_CASE_DISSOLVING_OR_DISSOLVED",
                Self::Dissolved => "NEURON_LEGACY_CASE_DISSOLVED",
                Self::NoneDissolveState => "NEURON_LEGACY_CASE_NONE_DISSOLVE_STATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NEURON_LEGACY_CASE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEURON_LEGACY_CASE_DISSOLVING_OR_DISSOLVED" => Some(Self::DissolvingOrDissolved),
                "NEURON_LEGACY_CASE_DISSOLVED" => Some(Self::Dissolved),
                "NEURON_LEGACY_CASE_NONE_DISSOLVE_STATE" => Some(Self::NoneDissolveState),
                _ => None,
            }
        }
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Payload {
        /// Reset aging timestamps (<https://forum.dfinity.org/t/icp-neuron-age-is-52-years/21261/26>).
        #[prost(message, tag = "2")]
        ResetAging(ResetAging),
        /// Restore aging timestamp that were incorrectly reset (<https://forum.dfinity.org/t/restore-neuron-age-in-proposal-129394/29840>).
        #[prost(message, tag = "3")]
        RestoreAging(RestoreAging),
        /// Normalize neuron dissolve state and age (<https://forum.dfinity.org/t/simplify-neuron-state-age/30527>)
        #[prost(message, tag = "4")]
        NormalizeDissolveStateAndAge(NormalizeDissolveStateAndAge),
    }
}
/// The summary of the restore aging event.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct RestoreAgingSummary {
    /// The timestamp of the restore aging event.
    #[prost(uint64, optional, tag = "1")]
    pub timestamp_seconds: ::core::option::Option<u64>,
    /// Groups of neurons that were considered for restoring their aging.
    #[prost(message, repeated, tag = "2")]
    pub groups: ::prost::alloc::vec::Vec<restore_aging_summary::RestoreAgingNeuronGroup>,
}
/// Nested message and enum types in `RestoreAgingSummary`.
pub mod restore_aging_summary {
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        PartialEq,
        ::prost::Message,
    )]
    pub struct RestoreAgingNeuronGroup {
        #[prost(enumeration = "NeuronGroupType", tag = "1")]
        pub group_type: i32,
        /// The number of neurons in this group.
        #[prost(uint64, optional, tag = "2")]
        pub count: ::core::option::Option<u64>,
        /// The previous total stake of neurons in this group when the aging was reset.
        #[prost(uint64, optional, tag = "3")]
        pub previous_total_stake_e8s: ::core::option::Option<u64>,
        /// The current total stake of neurons in this group when considering to restore aging.
        #[prost(uint64, optional, tag = "4")]
        pub current_total_stake_e8s: ::core::option::Option<u64>,
    }
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration,
    )]
    #[repr(i32)]
    pub enum NeuronGroupType {
        Unspecified = 0,
        /// The neurons in this group were not pre-aging. We don't restore their aging.
        NotPreAging = 1,
        /// The neurons in this group are dissolving or dissolved. We don't restore their aging because
        /// it's invalid for a dissolving/dissolved neuron to have age.
        DissolvingOrDissolved = 2,
        /// The neurons in this group have their stake changed. We restore them to be pre-aged.
        StakeChanged = 3,
        /// The neurons in this group have their stake remain the same and aging changed. We restore them
        /// to be pre-aged.
        StakeSameAgingChanged = 4,
        /// The neurons in this group have their stake remain the same and aging remain the same. We
        /// restore them to be pre-aged.
        StakeSameAgingSame = 5,
    }
    impl NeuronGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "NEURON_GROUP_TYPE_UNSPECIFIED",
                Self::NotPreAging => "NEURON_GROUP_TYPE_NOT_PRE_AGING",
                Self::DissolvingOrDissolved => "NEURON_GROUP_TYPE_DISSOLVING_OR_DISSOLVED",
                Self::StakeChanged => "NEURON_GROUP_TYPE_STAKE_CHANGED",
                Self::StakeSameAgingChanged => "NEURON_GROUP_TYPE_STAKE_SAME_AGING_CHANGED",
                Self::StakeSameAgingSame => "NEURON_GROUP_TYPE_STAKE_SAME_AGING_SAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NEURON_GROUP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEURON_GROUP_TYPE_NOT_PRE_AGING" => Some(Self::NotPreAging),
                "NEURON_GROUP_TYPE_DISSOLVING_OR_DISSOLVED" => Some(Self::DissolvingOrDissolved),
                "NEURON_GROUP_TYPE_STAKE_CHANGED" => Some(Self::StakeChanged),
                "NEURON_GROUP_TYPE_STAKE_SAME_AGING_CHANGED" => Some(Self::StakeSameAgingChanged),
                "NEURON_GROUP_TYPE_STAKE_SAME_AGING_SAME" => Some(Self::StakeSameAgingSame),
                _ => None,
            }
        }
    }
}
/// The historical rewards that were provided to node providers, along with the contextual data
/// needed to calculate it.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct ArchivedMonthlyNodeProviderRewards {
    /// The version of the rewards data.  These versions are added to accommodate changes to the
    /// rewards data structure over time.
    #[prost(oneof = "archived_monthly_node_provider_rewards::Version", tags = "1")]
    pub version: ::core::option::Option<archived_monthly_node_provider_rewards::Version>,
}
/// Nested message and enum types in `ArchivedMonthlyNodeProviderRewards`.
pub mod archived_monthly_node_provider_rewards {
    /// The first version of the stored rewards.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Message,
    )]
    pub struct V1 {
        #[prost(message, optional, tag = "1")]
        pub rewards: ::core::option::Option<super::MonthlyNodeProviderRewards>,
    }
    /// The version of the rewards data.  These versions are added to accommodate changes to the
    /// rewards data structure over time.
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Version {
        #[prost(message, tag = "1")]
        Version1(V1),
    }
}
/// Internal type to allow ProposalVotingStateMachine to be stored
/// in stable memory.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct ProposalVotingStateMachine {
    #[prost(message, optional, tag = "1")]
    pub proposal_id: ::core::option::Option<::ic_nns_common::pb::v1::ProposalId>,
    #[prost(enumeration = "Topic", tag = "2")]
    pub topic: i32,
    #[prost(message, repeated, tag = "3")]
    pub neurons_to_check_followers: ::prost::alloc::vec::Vec<::ic_nns_common::pb::v1::NeuronId>,
    #[prost(message, repeated, tag = "4")]
    pub followers_to_check: ::prost::alloc::vec::Vec<::ic_nns_common::pb::v1::NeuronId>,
    #[prost(map = "uint64, enumeration(Vote)", tag = "5")]
    pub recent_neuron_ballots_to_record: ::std::collections::HashMap<u64, i32>,
}
/// A Ledger subaccount.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct Subaccount {
    #[prost(bytes = "vec", tag = "1")]
    pub subaccount: ::prost::alloc::vec::Vec<u8>,
}
/// A Ledger account identified by the owner of the account `of` and
/// the `subaccount`. If the `subaccount` is not specified then the default
/// one is used.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct Account {
    /// The owner of the account.
    #[prost(message, optional, tag = "1")]
    pub owner: ::core::option::Option<::ic_base_types::PrincipalId>,
    /// The subaccount of the account. If not set then the default
    /// subaccount (all bytes set to 0) is used.
    #[prost(message, optional, tag = "2")]
    pub subaccount: ::core::option::Option<Subaccount>,
}
/// A reward disbribution that has been calculated but not fully disbursed.
/// This supports large reward distributions that may need to be split into multiple
/// messages.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct RewardsDistributionInProgress {
    #[prost(map = "uint64, uint64", tag = "1")]
    pub neuron_ids_to_e8_amounts: ::std::collections::HashMap<u64, u64>,
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct MaturityDisbursement {
    /// The amount of maturity being disbursed in e8s.
    #[prost(uint64, tag = "1")]
    pub amount_e8s: u64,
    /// The timestamp at which the maturity was disbursed.
    #[prost(uint64, tag = "2")]
    pub timestamp_of_disbursement_seconds: u64,
    /// The timestamp at which the maturity disbursement should be finalized.
    #[prost(uint64, tag = "4")]
    pub finalize_disbursement_timestamp_seconds: u64,
    #[prost(oneof = "maturity_disbursement::Destination", tags = "3, 5")]
    pub destination: ::core::option::Option<maturity_disbursement::Destination>,
}
/// Nested message and enum types in `MaturityDisbursement`.
pub mod maturity_disbursement {
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Destination {
        /// The icrc1 account to disburse the maturity to.
        #[prost(message, tag = "3")]
        AccountToDisburseTo(super::Account),
        /// The account identifier to disburse the maturity to.
        #[prost(message, tag = "5")]
        AccountIdentifierToDisburseTo(::icp_ledger::protobuf::AccountIdentifier),
    }
}
/// A map of neuron voting powers at a certain point in time. It can be used to initialize ballots of
/// a proposal.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct NeuronIdToVotingPowerMap {
    /// Map from neuron id to the voting power of the neuron.
    #[prost(map = "fixed64, uint64", tag = "1")]
    pub voting_power_map: ::std::collections::HashMap<u64, u64>,
}
/// Total voting power (deciding and potential) at a certain point in time. A history of the totals
/// can be used to detect voting power spikes. See `Neuron::deciding_voting_power` and
/// `Neuron::potential_voting_power` for more information.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    PartialEq,
    ::prost::Message,
)]
pub struct VotingPowerTotal {
    /// The total deciding voting power.
    #[prost(uint64, tag = "1")]
    pub total_deciding_voting_power: u64,
    /// The total potential voting power.
    #[prost(uint64, tag = "2")]
    pub total_potential_voting_power: u64,
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct FinalizeDisburseMaturity {
    /// The finalization timestamp of the disbursement.
    #[prost(uint64, tag = "1")]
    pub finalize_disbursement_timestamp_seconds: u64,
    /// The amount of ICPs to be disbursed in e8s.
    #[prost(uint64, tag = "2")]
    pub amount_to_mint_e8s: u64,
    /// The account to which to transfer the ICPs.
    #[prost(message, optional, tag = "3")]
    pub to_account: ::core::option::Option<Account>,
    /// The original amount of maturity to be disbursed (before maturity modulation).
    #[prost(uint64, tag = "4")]
    pub original_maturity_e8s_equivalent: u64,
    /// The account identifer to which to transfer the ICPs.
    #[prost(message, optional, tag = "5")]
    pub to_account_identifier: ::core::option::Option<::icp_ledger::protobuf::AccountIdentifier>,
}
/// An ICRC-3-like value.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct Value {
    #[prost(oneof = "value::Value", tags = "1, 2, 3, 4, 5, 6")]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(
        candid::CandidType,
        candid::Deserialize,
        serde::Serialize,
        comparable::Comparable,
        Clone,
        PartialEq,
        ::prost::Oneof,
    )]
    pub enum Value {
        #[prost(bytes, tag = "1")]
        Blob(::prost::alloc::vec::Vec<u8>),
        #[prost(string, tag = "2")]
        Text(::prost::alloc::string::String),
        /// nat/int are stored as bytes since candid Nat/Int does not have equivalent protobuf types.
        #[prost(bytes, tag = "3")]
        Nat(::prost::alloc::vec::Vec<u8>),
        #[prost(bytes, tag = "4")]
        Int(::prost::alloc::vec::Vec<u8>),
        #[prost(message, tag = "5")]
        Array(super::ValueArray),
        #[prost(message, tag = "6")]
        Map(super::ValueMap),
    }
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct ValueArray {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct ValueMap {
    #[prost(map = "string, message", tag = "1")]
    pub values: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
/// Proposal action that is self-describing. It can be understood without the schema of a specific
/// proposal type.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    PartialEq,
    ::prost::Message,
)]
pub struct SelfDescribingProposalAction {
    #[prost(string, tag = "1")]
    pub type_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub type_description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub value: ::core::option::Option<Value>,
}
/// Proposal types are organized into topics. Neurons can automatically
/// vote based on following other neurons, and these follow
/// relationships are defined per topic.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    strum_macros::EnumIter,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum Topic {
    /// The `Unspecified` topic is used as a fallback when
    /// following. That is, if no followees are specified for a given
    /// topic (other than the "Governance" and "SNS & Neurons' Fund" topics),
    /// the followees for this topic are used instead.
    Unspecified = 0,
    /// A special topic by means of which a neuron can be managed by the
    /// followees for this topic (in this case, there is no fallback to
    /// 'unspecified'). Votes on this topic are not included in the
    /// voting history of the neuron (cf., `recent_ballots` in `Neuron`).
    ///
    /// For proposals on this topic, only followees on the 'neuron
    /// management' topic of the neuron that the proposals pertains to
    /// are allowed to vote.
    ///
    /// As the set of eligible voters on this topic is restricted,
    /// proposals on this topic have a *short voting period*.
    NeuronManagement = 1,
    /// All proposals that provide “real time” information about the
    /// value of ICP, as measured by an IMF SDR, which allows the NNS to
    /// convert ICP to cycles (which power computation) at a rate which
    /// keeps their real world cost constant. Votes on this topic are not
    /// included in the voting history of the neuron (cf.,
    /// `recent_ballots` in `Neuron`).
    ///
    /// Proposals on this topic have a *short voting period* due to their
    /// frequency.
    ExchangeRate = 2,
    /// All proposals that administer network economics, for example,
    /// determining what rewards should be paid to node operators.
    NetworkEconomics = 3,
    /// All proposals that administer governance, for example to freeze
    /// malicious canisters that are harming the network.
    Governance = 4,
    /// All proposals that administer node machines, including, but not
    /// limited to, upgrading or configuring the OS, upgrading or
    /// configuring the virtual machine framework and upgrading or
    /// configuring the node replica software.
    NodeAdmin = 5,
    /// All proposals that administer network participants, for example,
    /// granting and revoking DCIDs (data center identities) or NOIDs
    /// (node operator identities).
    ParticipantManagement = 6,
    /// All proposals that administer network subnets, for example
    /// creating new subnets, adding and removing subnet nodes, and
    /// splitting subnets.
    SubnetManagement = 7,
    /// All proposals to manage NNS-controlled canisters not covered by other topics (Protocol Canister
    /// Management or Service Nervous System Management).
    ApplicationCanisterManagement = 8,
    /// Proposals that update KYC information for regulatory purposes,
    /// for example during the initial Genesis distribution of ICP in the
    /// form of neurons.
    Kyc = 9,
    /// Topic for proposals to reward node providers.
    NodeProviderRewards = 10,
    /// IC OS upgrade proposals
    /// -----------------------
    /// ICP runs on a distributed network of nodes grouped into subnets. Each node runs a stack of
    /// operating systems, including HostOS (runs on bare metal) and GuestOS (runs inside HostOS;
    /// contains, e.g., the ICP replica process). HostOS and GuestOS are distributed via separate disk
    /// images. The umbrella term IC OS refers to the whole stack.
    ///
    /// The IC OS upgrade process involves two phases, where the first phase is the election of a new
    /// IC OS version and the second phase is the deployment of a previously elected IC OS version on
    /// all nodes of a subnet or on some number of nodes (including nodes comprising subnets and
    /// unassigned nodes).
    ///
    /// A special case is for API boundary nodes, special nodes that route API requests to a replica
    /// of the right subnet. API boundary nodes run a different process than the replica, but their
    /// executable is distributed via the same disk image as GuestOS. Therefore, electing a new GuestOS
    /// version also results in a new version of boundary node software being elected.
    ///
    /// Proposals handling the deployment of IC OS to some nodes. It is possible to deploy only
    /// the versions of IC OS that are in the set of elected IC OS versions.
    IcOsVersionDeployment = 12,
    /// Proposals for changing the set of elected IC OS versions.
    IcOsVersionElection = 13,
    /// Proposals related to SNS and Community Fund.
    SnsAndCommunityFund = 14,
    /// Proposals related to the management of API Boundary Nodes
    ApiBoundaryNodeManagement = 15,
    /// Proposals related to subnet rental.
    SubnetRental = 16,
    /// All proposals to manage protocol canisters, which are considered part of the ICP protocol and
    /// are essential for its proper functioning.
    ProtocolCanisterManagement = 17,
    /// All proposals to manage the canisters of service nervous systems (SNS), including upgrading
    /// relevant canisters and managing SNS framework canister WASMs through SNS-W.
    ServiceNervousSystemManagement = 18,
}
impl Topic {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TOPIC_UNSPECIFIED",
            Self::NeuronManagement => "TOPIC_NEURON_MANAGEMENT",
            Self::ExchangeRate => "TOPIC_EXCHANGE_RATE",
            Self::NetworkEconomics => "TOPIC_NETWORK_ECONOMICS",
            Self::Governance => "TOPIC_GOVERNANCE",
            Self::NodeAdmin => "TOPIC_NODE_ADMIN",
            Self::ParticipantManagement => "TOPIC_PARTICIPANT_MANAGEMENT",
            Self::SubnetManagement => "TOPIC_SUBNET_MANAGEMENT",
            Self::ApplicationCanisterManagement => "TOPIC_APPLICATION_CANISTER_MANAGEMENT",
            Self::Kyc => "TOPIC_KYC",
            Self::NodeProviderRewards => "TOPIC_NODE_PROVIDER_REWARDS",
            Self::IcOsVersionDeployment => "TOPIC_IC_OS_VERSION_DEPLOYMENT",
            Self::IcOsVersionElection => "TOPIC_IC_OS_VERSION_ELECTION",
            Self::SnsAndCommunityFund => "TOPIC_SNS_AND_COMMUNITY_FUND",
            Self::ApiBoundaryNodeManagement => "TOPIC_API_BOUNDARY_NODE_MANAGEMENT",
            Self::SubnetRental => "TOPIC_SUBNET_RENTAL",
            Self::ProtocolCanisterManagement => "TOPIC_PROTOCOL_CANISTER_MANAGEMENT",
            Self::ServiceNervousSystemManagement => "TOPIC_SERVICE_NERVOUS_SYSTEM_MANAGEMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TOPIC_UNSPECIFIED" => Some(Self::Unspecified),
            "TOPIC_NEURON_MANAGEMENT" => Some(Self::NeuronManagement),
            "TOPIC_EXCHANGE_RATE" => Some(Self::ExchangeRate),
            "TOPIC_NETWORK_ECONOMICS" => Some(Self::NetworkEconomics),
            "TOPIC_GOVERNANCE" => Some(Self::Governance),
            "TOPIC_NODE_ADMIN" => Some(Self::NodeAdmin),
            "TOPIC_PARTICIPANT_MANAGEMENT" => Some(Self::ParticipantManagement),
            "TOPIC_SUBNET_MANAGEMENT" => Some(Self::SubnetManagement),
            "TOPIC_APPLICATION_CANISTER_MANAGEMENT" => Some(Self::ApplicationCanisterManagement),
            "TOPIC_KYC" => Some(Self::Kyc),
            "TOPIC_NODE_PROVIDER_REWARDS" => Some(Self::NodeProviderRewards),
            "TOPIC_IC_OS_VERSION_DEPLOYMENT" => Some(Self::IcOsVersionDeployment),
            "TOPIC_IC_OS_VERSION_ELECTION" => Some(Self::IcOsVersionElection),
            "TOPIC_SNS_AND_COMMUNITY_FUND" => Some(Self::SnsAndCommunityFund),
            "TOPIC_API_BOUNDARY_NODE_MANAGEMENT" => Some(Self::ApiBoundaryNodeManagement),
            "TOPIC_SUBNET_RENTAL" => Some(Self::SubnetRental),
            "TOPIC_PROTOCOL_CANISTER_MANAGEMENT" => Some(Self::ProtocolCanisterManagement),
            "TOPIC_SERVICE_NERVOUS_SYSTEM_MANAGEMENT" => Some(Self::ServiceNervousSystemManagement),
            _ => None,
        }
    }
}
/// Every neuron is in one of three states.
///
/// Note that `Disbursed` is not a state of a neuron, as the neuron is
/// consumed through the act of disbursement (using the method
/// \[Governance::disburse\]).
///
/// See \[neuron::DissolveState\] for detail on how the different states
/// are represented.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum NeuronState {
    /// Not a valid state. Required by Protobufs.
    Unspecified = 0,
    /// In this state, the neuron is not dissolving and has a specific
    /// `dissolve_delay`. It accrues `age` by the passage of time and it
    /// can vote if `dissolve_delay` is at least six months. The method
    /// \[Neuron::start_dissolving\] can be called to transfer the neuron
    /// to the `Dissolving` state. The method
    /// \[Neuron::increase_dissolve_delay\] can be used to increase the
    /// dissolve delay without affecting the state or the age of the
    /// neuron.
    NotDissolving = 1,
    /// In this state, the neuron's `dissolve_delay` decreases with the
    /// passage of time. While dissolving, the neuron's age is considered
    /// zero. Eventually it will reach the `Dissolved` state. The method
    /// \[Neuron::stop_dissolving\] can be called to transfer the neuron to
    /// the `NotDissolving` state, and the neuron will start aging again. The
    /// method \[Neuron::increase_dissolve_delay\] can be used to increase
    /// the dissolve delay, but this will not stop the timer or affect
    /// the age of the neuron.
    Dissolving = 2,
    /// In the dissolved state, the neuron's stake can be disbursed using
    /// the \[Governance::disburse\] method. It cannot vote as its
    /// `dissolve_delay` is considered to be zero.
    ///
    /// If the method \[Neuron::increase_dissolve_delay\] is called in this
    /// state, the neuron will no longer be dissolving, with the specified
    /// dissolve delay, and will start aging again.
    ///
    /// Neuron holders have an incentive not to keep neurons in the
    /// 'dissolved' state for a long time: if the holders wants to make
    /// their tokens liquid, they disburse the neuron's stake, and if
    /// they want to earn voting rewards, they increase the dissolve
    /// delay. If these incentives turn out to be insufficient, the NNS
    /// may decide to impose further restrictions on dissolved neurons.
    Dissolved = 3,
    /// The neuron is in spawning state, meaning it's maturity will be
    /// converted to ICP according to <https://wiki.internetcomputer.org/wiki/Maturity_modulation.>
    Spawning = 4,
}
impl NeuronState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NEURON_STATE_UNSPECIFIED",
            Self::NotDissolving => "NEURON_STATE_NOT_DISSOLVING",
            Self::Dissolving => "NEURON_STATE_DISSOLVING",
            Self::Dissolved => "NEURON_STATE_DISSOLVED",
            Self::Spawning => "NEURON_STATE_SPAWNING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NEURON_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "NEURON_STATE_NOT_DISSOLVING" => Some(Self::NotDissolving),
            "NEURON_STATE_DISSOLVING" => Some(Self::Dissolving),
            "NEURON_STATE_DISSOLVED" => Some(Self::Dissolved),
            "NEURON_STATE_SPAWNING" => Some(Self::Spawning),
            _ => None,
        }
    }
}
/// Controls how much information non-controller and non-hot-key principals can
/// see about this neuron. Currently, if a neuron is private, recent_ballots and
/// joined_community_fund_timestamp_seconds are redacted when being read by an
/// unprivileged principal.
///
/// <https://forum.dfinity.org/t/request-for-comments-api-changes-for-public-private-neurons/33360>
///
/// As of Jul 19, this is not yet enforced, but will be once the plan described
/// above is fully executed.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum Visibility {
    Unspecified = 0,
    Private = 1,
    Public = 2,
}
impl Visibility {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VISIBILITY_UNSPECIFIED",
            Self::Private => "VISIBILITY_PRIVATE",
            Self::Public => "VISIBILITY_PUBLIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VISIBILITY_UNSPECIFIED" => Some(Self::Unspecified),
            "VISIBILITY_PRIVATE" => Some(Self::Private),
            "VISIBILITY_PUBLIC" => Some(Self::Public),
            _ => None,
        }
    }
}
/// Types of a Neuron.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum NeuronType {
    /// Placeholder value due to the proto3 requirement for a zero default.
    /// This is an invalid type; neurons should not be assigned this value.
    Unspecified = 0,
    /// Represents neurons initially created for Seed accounts in the
    /// Genesis Token Canister, or those descended from such neurons.
    Seed = 1,
    /// Represents neurons initially created for Early Contributor Token (ECT)
    /// accounts in the Genesis Token Canister, or those descended from such neurons.
    Ect = 2,
}
impl NeuronType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NEURON_TYPE_UNSPECIFIED",
            Self::Seed => "NEURON_TYPE_SEED",
            Self::Ect => "NEURON_TYPE_ECT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NEURON_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NEURON_TYPE_SEED" => Some(Self::Seed),
            "NEURON_TYPE_ECT" => Some(Self::Ect),
            _ => None,
        }
    }
}
/// The types of votes the Neuron can issue.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum Vote {
    /// This exists because proto3 defaults to the 0 value on enums.
    /// This is not a valid choice, i.e., a vote with this choice will
    /// not be counted.
    Unspecified = 0,
    /// Vote for the proposal to be adopted.
    Yes = 1,
    /// Vote for the proposal to be rejected.
    No = 2,
}
impl Vote {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VOTE_UNSPECIFIED",
            Self::Yes => "VOTE_YES",
            Self::No => "VOTE_NO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VOTE_UNSPECIFIED" => Some(Self::Unspecified),
            "VOTE_YES" => Some(Self::Yes),
            "VOTE_NO" => Some(Self::No),
            _ => None,
        }
    }
}
/// List of NNS functions that can be called by proposals.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    strum_macros::EnumIter,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum NnsFunction {
    /// This exists because proto3 defaults to the 0 value on enums.
    Unspecified = 0,
    /// Combine a specified set of nodes, typically drawn from data centers and
    /// operators in such a way as to guarantee their independence, into a new
    /// decentralized subnet.
    /// The execution of this NNS function first initiates a new instance of
    /// the distributed key generation protocol. The transcript of that protocol
    /// is written to a new subnet record in the registry, together with initial
    /// configuration information for the subnet, from where the nodes comprising
    /// the subnet pick it up.
    CreateSubnet = 1,
    /// Add a new node to a subnet. The node cannot be currently assigned to a
    /// subnet.
    /// The execution of this proposal changes an existing subnet record to add
    /// a node. From the perspective of the NNS, this update is a simple update
    /// of the subnet record in the registry.
    AddNodeToSubnet = 2,
    /// A proposal to add a new canister to be installed and executed in the
    /// NNS subnetwork.
    /// The root canister, which controls all canisters on the NNS except for
    /// itself, handles this proposal type. The call also expects the Wasm module
    /// that shall be installed.
    NnsCanisterInstall = 3,
    /// A proposal to upgrade an existing canister in the NNS subnetwork.
    /// This proposal type is executed by the root canister. Beyond upgrading
    /// the Wasm module of the target canister, the proposal can also set the
    /// authorization information and the allocations.
    NnsCanisterUpgrade = 4,
    /// A proposal to bless a new version to which the replicas can be
    /// upgraded.
    /// The proposal registers a replica version (identified by the hash of the
    /// installation image) in the registry. Besides creating a record for that
    /// version, the proposal also appends that version to the list of "blessed
    /// versions" that can be installed on a subnet. By itself, this proposal
    /// does not effect any upgrade.
    BlessReplicaVersion = 5,
    /// Update a subnet's recovery CUP (used to recover subnets that have stalled).
    /// Nodes that find a recovery CUP for their subnet will load that CUP from
    /// the registry and restart the replica from that CUP.
    RecoverSubnet = 6,
    /// Update a subnet's configuration.
    /// This proposal updates the subnet record in the registry, with the changes
    /// being picked up by the nodes on the subnet when they reference the
    /// respective registry version. Subnet configuration comprises protocol
    /// parameters that must be consistent across the subnet (e.g. message sizes).
    UpdateConfigOfSubnet = 7,
    /// Assign an identity to a node operator, such as a funding partner,
    /// associating key information regarding its ownership, the jurisdiction
    /// in which it is located, and other information.
    /// The node operator is stored as a record in the registry. It contains
    /// the remaining node allowance for that node operator, that is the number
    /// of nodes the node operator can still add to the IC. When an additional
    /// node is added by the node operator, the remaining allowance is decreased.
    AssignNoid = 8,
    /// A proposal to upgrade the root canister in the NNS subnetwork.
    /// The proposal is processed by the Lifeline canister, which controls the
    /// root canister. The proposal updates the Wasm module as well as the
    /// authorization settings.
    NnsRootUpgrade = 9,
    /// Update the ICP/XDR conversion rate.
    /// Changes the ICP-to-XDR conversion rate in the governance canister. This
    /// setting affects cycles pricing (as the value of cycles shall be constant
    /// with respect to IMF SDRs) as well as the rewards paid for nodes, which
    /// are expected to be specified in terms of IMF SDRs as well.
    IcpXdrConversionRate = 10,
    /// Deploy a GuestOS version to a given subnet. The proposal changes the GuestOS version that is
    /// used on the specified subnet. The version must be contained in the list of elected GuestOS
    /// versions. The upgrade is completed when the subnet creates the next regular CUP.
    DeployGuestosToAllSubnetNodes = 11,
    /// Clear the provisional whitelist.
    /// The proposal changes the provisional whitelist to the empty list.
    ClearProvisionalWhitelist = 12,
    /// Removes a node from a subnet. The node must be currently assigned to a
    /// subnet.
    /// The execution of this proposal changes an existing subnet record to remove
    /// a node. From the perspective of the NNS, this update is a simple update
    /// of the subnet record in the registry.
    RemoveNodesFromSubnet = 13,
    /// Informs the cycles minting canister that a certain principal is
    /// authorized to use certain subnetworks (from a list). Can also be
    /// used to set the "default" list of subnetworks that principals
    /// without special authorization are allowed to use.
    SetAuthorizedSubnetworks = 14,
    /// Change the Firewall configuration in the registry. (TODO: Remove when IC-1026 is fully integrated)
    SetFirewallConfig = 15,
    /// Change a Node Operator's allowance in the registry.
    UpdateNodeOperatorConfig = 16,
    /// Stop or start an NNS canister.
    StopOrStartNnsCanister = 17,
    /// Remove unassigned nodes from the registry.
    RemoveNodes = 18,
    /// Uninstall code of a canister.
    UninstallCode = 19,
    /// Update the node rewards table.
    UpdateNodeRewardsTable = 20,
    /// Add or remove Data Center records.
    AddOrRemoveDataCenters = 21,
    /// (obsolete) Update the config for all unassigned nodes.
    UpdateUnassignedNodesConfig = 22,
    /// Remove Node Operator from the registry.
    RemoveNodeOperators = 23,
    /// Update the routing table in the registry.
    RerouteCanisterRanges = 24,
    /// Add firewall rules in the registry
    AddFirewallRules = 25,
    /// Remove firewall rules in the registry
    RemoveFirewallRules = 26,
    /// Update firewall rules in the registry
    UpdateFirewallRules = 27,
    /// Insert or update `canister_migrations` entries.
    PrepareCanisterMigration = 28,
    /// Remove `canister_migrations` entries.
    CompleteCanisterMigration = 29,
    /// Add a new SNS canister WASM
    AddSnsWasm = 30,
    /// Change the subnet node membership. In a way, this function combines the separate
    /// functions for adding and removing nodes from the subnet record, but adds the property
    /// of atomic node replacement (node swap) on top.
    ///
    /// The nodes that are being added to the subnet must be currently unassigned.
    /// The nodes that are being removed from the subnet must be currently assigned to the subnet.
    ChangeSubnetMembership = 31,
    /// Updates the available subnet types in the cycles minting canister.
    UpdateSubnetType = 32,
    /// Changes the assignment of subnets to subnet types in the cycles minting
    /// canister.
    ChangeSubnetTypeAssignment = 33,
    /// Update the list of SNS subnet IDs that SNS WASM will deploy SNS instances to.
    UpdateSnsWasmSnsSubnetIds = 34,
    /// Update the SNS-wasm canister's list of allowed principals. This list guards which principals can deploy an SNS.
    UpdateAllowedPrincipals = 35,
    /// A proposal to retire previously elected and unused replica versions.
    /// The specified versions are removed from the registry and the "blessed versions" record.
    /// This ensures that the replica cannot upgrade to these versions anymore.
    RetireReplicaVersion = 36,
    /// Insert custom upgrade path entries into SNS-W for all SNSes, or for an SNS specified by its governance canister ID.
    InsertSnsWasmUpgradePathEntries = 37,
    /// A proposal to change the set of elected GuestOS versions. The version to elect (identified by
    /// the hash of the installation image) is added to the registry. Besides creating a record for
    /// that version, the proposal also appends that version to the list of elected versions that can
    /// be installed on nodes of a subnet. Only elected GuestOS versions can be deployed.
    ReviseElectedGuestosVersions = 38,
    BitcoinSetConfig = 39,
    /// OBSOLETE: use NNS_FUNCTION_REVISE_ELECTED_HOSTOS_VERSIONS instead
    UpdateElectedHostosVersions = 40,
    /// OBSOLETE: use NNS_FUNCTION_UPGRADE_HOSTOS_FOR_SOME_NODES instead
    UpdateNodesHostosVersion = 41,
    /// Uninstall and Install Root with the WASM provided in the function.  If InitArgs are provided
    /// They will be passed to the canister_init function of the WASM provided.
    /// This function is meant as a Break Glass mechanism for when an open call context in
    /// the Root canister is preventing root or another canister from upgrading (in the case of proxied calls).
    HardResetNnsRootToVersion = 42,
    /// A proposal to add a set of new API Boundary Nodes using unassigned nodes
    AddApiBoundaryNodes = 43,
    /// A proposal to remove a set of API Boundary Nodes, which will designate them as unassigned nodes
    RemoveApiBoundaryNodes = 44,
    /// (obsolete) A proposal to update the version of a set of API Boundary Nodes
    UpdateApiBoundaryNodesVersion = 46,
    /// A proposal to update the version of a set of API Boundary Nodes
    DeployGuestosToSomeApiBoundaryNodes = 47,
    /// A proposal to update the version of all unassigned nodes
    DeployGuestosToAllUnassignedNodes = 48,
    /// A proposal to update SSH readonly access for all unassigned nodes
    UpdateSshReadonlyAccessForAllUnassignedNodes = 49,
    /// A proposal to change the set of currently elected HostOS versions, by electing a new version,
    /// and/or unelecting some priorly elected versions. HostOS versions are identified by the hash
    /// of the installation image. The version to elect is added to the Registry, and the versions
    /// to unelect are removed from the Registry, ensuring that HostOS cannot upgrade to these versions
    /// anymore. This proposal does not actually perform the upgrade; for deployment of an elected
    /// version, please refer to `NNS_FUNCTION_DEPLOY_HOSTOS_TO_SOME_NODES`.
    ReviseElectedHostosVersions = 50,
    /// Deploy a HostOS version to a given set of nodes. The proposal changes the HostOS version that
    /// is used on the specified nodes.
    DeployHostosToSomeNodes = 51,
    /// The proposal requests a subnet rental.
    SubnetRentalRequest = 52,
    /// Instruct the migration canister to not accept any more migration requests.
    PauseCanisterMigrations = 53,
    /// Instruct the migration canister to accept migration requests again.
    UnpauseCanisterMigrations = 54,
    /// Take subnet offline or bring back online. Used as part of subnet recovery.
    SetSubnetOperationalLevel = 55,
}
impl NnsFunction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NNS_FUNCTION_UNSPECIFIED",
            Self::CreateSubnet => "NNS_FUNCTION_CREATE_SUBNET",
            Self::AddNodeToSubnet => "NNS_FUNCTION_ADD_NODE_TO_SUBNET",
            Self::NnsCanisterInstall => "NNS_FUNCTION_NNS_CANISTER_INSTALL",
            Self::NnsCanisterUpgrade => "NNS_FUNCTION_NNS_CANISTER_UPGRADE",
            Self::BlessReplicaVersion => "NNS_FUNCTION_BLESS_REPLICA_VERSION",
            Self::RecoverSubnet => "NNS_FUNCTION_RECOVER_SUBNET",
            Self::UpdateConfigOfSubnet => "NNS_FUNCTION_UPDATE_CONFIG_OF_SUBNET",
            Self::AssignNoid => "NNS_FUNCTION_ASSIGN_NOID",
            Self::NnsRootUpgrade => "NNS_FUNCTION_NNS_ROOT_UPGRADE",
            Self::IcpXdrConversionRate => "NNS_FUNCTION_ICP_XDR_CONVERSION_RATE",
            Self::DeployGuestosToAllSubnetNodes => {
                "NNS_FUNCTION_DEPLOY_GUESTOS_TO_ALL_SUBNET_NODES"
            }
            Self::ClearProvisionalWhitelist => "NNS_FUNCTION_CLEAR_PROVISIONAL_WHITELIST",
            Self::RemoveNodesFromSubnet => "NNS_FUNCTION_REMOVE_NODES_FROM_SUBNET",
            Self::SetAuthorizedSubnetworks => "NNS_FUNCTION_SET_AUTHORIZED_SUBNETWORKS",
            Self::SetFirewallConfig => "NNS_FUNCTION_SET_FIREWALL_CONFIG",
            Self::UpdateNodeOperatorConfig => "NNS_FUNCTION_UPDATE_NODE_OPERATOR_CONFIG",
            Self::StopOrStartNnsCanister => "NNS_FUNCTION_STOP_OR_START_NNS_CANISTER",
            Self::RemoveNodes => "NNS_FUNCTION_REMOVE_NODES",
            Self::UninstallCode => "NNS_FUNCTION_UNINSTALL_CODE",
            Self::UpdateNodeRewardsTable => "NNS_FUNCTION_UPDATE_NODE_REWARDS_TABLE",
            Self::AddOrRemoveDataCenters => "NNS_FUNCTION_ADD_OR_REMOVE_DATA_CENTERS",
            Self::UpdateUnassignedNodesConfig => "NNS_FUNCTION_UPDATE_UNASSIGNED_NODES_CONFIG",
            Self::RemoveNodeOperators => "NNS_FUNCTION_REMOVE_NODE_OPERATORS",
            Self::RerouteCanisterRanges => "NNS_FUNCTION_REROUTE_CANISTER_RANGES",
            Self::AddFirewallRules => "NNS_FUNCTION_ADD_FIREWALL_RULES",
            Self::RemoveFirewallRules => "NNS_FUNCTION_REMOVE_FIREWALL_RULES",
            Self::UpdateFirewallRules => "NNS_FUNCTION_UPDATE_FIREWALL_RULES",
            Self::PrepareCanisterMigration => "NNS_FUNCTION_PREPARE_CANISTER_MIGRATION",
            Self::CompleteCanisterMigration => "NNS_FUNCTION_COMPLETE_CANISTER_MIGRATION",
            Self::AddSnsWasm => "NNS_FUNCTION_ADD_SNS_WASM",
            Self::ChangeSubnetMembership => "NNS_FUNCTION_CHANGE_SUBNET_MEMBERSHIP",
            Self::UpdateSubnetType => "NNS_FUNCTION_UPDATE_SUBNET_TYPE",
            Self::ChangeSubnetTypeAssignment => "NNS_FUNCTION_CHANGE_SUBNET_TYPE_ASSIGNMENT",
            Self::UpdateSnsWasmSnsSubnetIds => "NNS_FUNCTION_UPDATE_SNS_WASM_SNS_SUBNET_IDS",
            Self::UpdateAllowedPrincipals => "NNS_FUNCTION_UPDATE_ALLOWED_PRINCIPALS",
            Self::RetireReplicaVersion => "NNS_FUNCTION_RETIRE_REPLICA_VERSION",
            Self::InsertSnsWasmUpgradePathEntries => {
                "NNS_FUNCTION_INSERT_SNS_WASM_UPGRADE_PATH_ENTRIES"
            }
            Self::ReviseElectedGuestosVersions => "NNS_FUNCTION_REVISE_ELECTED_GUESTOS_VERSIONS",
            Self::BitcoinSetConfig => "NNS_FUNCTION_BITCOIN_SET_CONFIG",
            Self::UpdateElectedHostosVersions => "NNS_FUNCTION_UPDATE_ELECTED_HOSTOS_VERSIONS",
            Self::UpdateNodesHostosVersion => "NNS_FUNCTION_UPDATE_NODES_HOSTOS_VERSION",
            Self::HardResetNnsRootToVersion => "NNS_FUNCTION_HARD_RESET_NNS_ROOT_TO_VERSION",
            Self::AddApiBoundaryNodes => "NNS_FUNCTION_ADD_API_BOUNDARY_NODES",
            Self::RemoveApiBoundaryNodes => "NNS_FUNCTION_REMOVE_API_BOUNDARY_NODES",
            Self::UpdateApiBoundaryNodesVersion => "NNS_FUNCTION_UPDATE_API_BOUNDARY_NODES_VERSION",
            Self::DeployGuestosToSomeApiBoundaryNodes => {
                "NNS_FUNCTION_DEPLOY_GUESTOS_TO_SOME_API_BOUNDARY_NODES"
            }
            Self::DeployGuestosToAllUnassignedNodes => {
                "NNS_FUNCTION_DEPLOY_GUESTOS_TO_ALL_UNASSIGNED_NODES"
            }
            Self::UpdateSshReadonlyAccessForAllUnassignedNodes => {
                "NNS_FUNCTION_UPDATE_SSH_READONLY_ACCESS_FOR_ALL_UNASSIGNED_NODES"
            }
            Self::ReviseElectedHostosVersions => "NNS_FUNCTION_REVISE_ELECTED_HOSTOS_VERSIONS",
            Self::DeployHostosToSomeNodes => "NNS_FUNCTION_DEPLOY_HOSTOS_TO_SOME_NODES",
            Self::SubnetRentalRequest => "NNS_FUNCTION_SUBNET_RENTAL_REQUEST",
            Self::PauseCanisterMigrations => "NNS_FUNCTION_PAUSE_CANISTER_MIGRATIONS",
            Self::UnpauseCanisterMigrations => "NNS_FUNCTION_UNPAUSE_CANISTER_MIGRATIONS",
            Self::SetSubnetOperationalLevel => "NNS_FUNCTION_SET_SUBNET_OPERATIONAL_LEVEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NNS_FUNCTION_UNSPECIFIED" => Some(Self::Unspecified),
            "NNS_FUNCTION_CREATE_SUBNET" => Some(Self::CreateSubnet),
            "NNS_FUNCTION_ADD_NODE_TO_SUBNET" => Some(Self::AddNodeToSubnet),
            "NNS_FUNCTION_NNS_CANISTER_INSTALL" => Some(Self::NnsCanisterInstall),
            "NNS_FUNCTION_NNS_CANISTER_UPGRADE" => Some(Self::NnsCanisterUpgrade),
            "NNS_FUNCTION_BLESS_REPLICA_VERSION" => Some(Self::BlessReplicaVersion),
            "NNS_FUNCTION_RECOVER_SUBNET" => Some(Self::RecoverSubnet),
            "NNS_FUNCTION_UPDATE_CONFIG_OF_SUBNET" => Some(Self::UpdateConfigOfSubnet),
            "NNS_FUNCTION_ASSIGN_NOID" => Some(Self::AssignNoid),
            "NNS_FUNCTION_NNS_ROOT_UPGRADE" => Some(Self::NnsRootUpgrade),
            "NNS_FUNCTION_ICP_XDR_CONVERSION_RATE" => Some(Self::IcpXdrConversionRate),
            "NNS_FUNCTION_DEPLOY_GUESTOS_TO_ALL_SUBNET_NODES" => {
                Some(Self::DeployGuestosToAllSubnetNodes)
            }
            "NNS_FUNCTION_CLEAR_PROVISIONAL_WHITELIST" => Some(Self::ClearProvisionalWhitelist),
            "NNS_FUNCTION_REMOVE_NODES_FROM_SUBNET" => Some(Self::RemoveNodesFromSubnet),
            "NNS_FUNCTION_SET_AUTHORIZED_SUBNETWORKS" => Some(Self::SetAuthorizedSubnetworks),
            "NNS_FUNCTION_SET_FIREWALL_CONFIG" => Some(Self::SetFirewallConfig),
            "NNS_FUNCTION_UPDATE_NODE_OPERATOR_CONFIG" => Some(Self::UpdateNodeOperatorConfig),
            "NNS_FUNCTION_STOP_OR_START_NNS_CANISTER" => Some(Self::StopOrStartNnsCanister),
            "NNS_FUNCTION_REMOVE_NODES" => Some(Self::RemoveNodes),
            "NNS_FUNCTION_UNINSTALL_CODE" => Some(Self::UninstallCode),
            "NNS_FUNCTION_UPDATE_NODE_REWARDS_TABLE" => Some(Self::UpdateNodeRewardsTable),
            "NNS_FUNCTION_ADD_OR_REMOVE_DATA_CENTERS" => Some(Self::AddOrRemoveDataCenters),
            "NNS_FUNCTION_UPDATE_UNASSIGNED_NODES_CONFIG" => {
                Some(Self::UpdateUnassignedNodesConfig)
            }
            "NNS_FUNCTION_REMOVE_NODE_OPERATORS" => Some(Self::RemoveNodeOperators),
            "NNS_FUNCTION_REROUTE_CANISTER_RANGES" => Some(Self::RerouteCanisterRanges),
            "NNS_FUNCTION_ADD_FIREWALL_RULES" => Some(Self::AddFirewallRules),
            "NNS_FUNCTION_REMOVE_FIREWALL_RULES" => Some(Self::RemoveFirewallRules),
            "NNS_FUNCTION_UPDATE_FIREWALL_RULES" => Some(Self::UpdateFirewallRules),
            "NNS_FUNCTION_PREPARE_CANISTER_MIGRATION" => Some(Self::PrepareCanisterMigration),
            "NNS_FUNCTION_COMPLETE_CANISTER_MIGRATION" => Some(Self::CompleteCanisterMigration),
            "NNS_FUNCTION_ADD_SNS_WASM" => Some(Self::AddSnsWasm),
            "NNS_FUNCTION_CHANGE_SUBNET_MEMBERSHIP" => Some(Self::ChangeSubnetMembership),
            "NNS_FUNCTION_UPDATE_SUBNET_TYPE" => Some(Self::UpdateSubnetType),
            "NNS_FUNCTION_CHANGE_SUBNET_TYPE_ASSIGNMENT" => Some(Self::ChangeSubnetTypeAssignment),
            "NNS_FUNCTION_UPDATE_SNS_WASM_SNS_SUBNET_IDS" => Some(Self::UpdateSnsWasmSnsSubnetIds),
            "NNS_FUNCTION_UPDATE_ALLOWED_PRINCIPALS" => Some(Self::UpdateAllowedPrincipals),
            "NNS_FUNCTION_RETIRE_REPLICA_VERSION" => Some(Self::RetireReplicaVersion),
            "NNS_FUNCTION_INSERT_SNS_WASM_UPGRADE_PATH_ENTRIES" => {
                Some(Self::InsertSnsWasmUpgradePathEntries)
            }
            "NNS_FUNCTION_REVISE_ELECTED_GUESTOS_VERSIONS" => {
                Some(Self::ReviseElectedGuestosVersions)
            }
            "NNS_FUNCTION_BITCOIN_SET_CONFIG" => Some(Self::BitcoinSetConfig),
            "NNS_FUNCTION_UPDATE_ELECTED_HOSTOS_VERSIONS" => {
                Some(Self::UpdateElectedHostosVersions)
            }
            "NNS_FUNCTION_UPDATE_NODES_HOSTOS_VERSION" => Some(Self::UpdateNodesHostosVersion),
            "NNS_FUNCTION_HARD_RESET_NNS_ROOT_TO_VERSION" => Some(Self::HardResetNnsRootToVersion),
            "NNS_FUNCTION_ADD_API_BOUNDARY_NODES" => Some(Self::AddApiBoundaryNodes),
            "NNS_FUNCTION_REMOVE_API_BOUNDARY_NODES" => Some(Self::RemoveApiBoundaryNodes),
            "NNS_FUNCTION_UPDATE_API_BOUNDARY_NODES_VERSION" => {
                Some(Self::UpdateApiBoundaryNodesVersion)
            }
            "NNS_FUNCTION_DEPLOY_GUESTOS_TO_SOME_API_BOUNDARY_NODES" => {
                Some(Self::DeployGuestosToSomeApiBoundaryNodes)
            }
            "NNS_FUNCTION_DEPLOY_GUESTOS_TO_ALL_UNASSIGNED_NODES" => {
                Some(Self::DeployGuestosToAllUnassignedNodes)
            }
            "NNS_FUNCTION_UPDATE_SSH_READONLY_ACCESS_FOR_ALL_UNASSIGNED_NODES" => {
                Some(Self::UpdateSshReadonlyAccessForAllUnassignedNodes)
            }
            "NNS_FUNCTION_REVISE_ELECTED_HOSTOS_VERSIONS" => {
                Some(Self::ReviseElectedHostosVersions)
            }
            "NNS_FUNCTION_DEPLOY_HOSTOS_TO_SOME_NODES" => Some(Self::DeployHostosToSomeNodes),
            "NNS_FUNCTION_SUBNET_RENTAL_REQUEST" => Some(Self::SubnetRentalRequest),
            "NNS_FUNCTION_PAUSE_CANISTER_MIGRATIONS" => Some(Self::PauseCanisterMigrations),
            "NNS_FUNCTION_UNPAUSE_CANISTER_MIGRATIONS" => Some(Self::UnpauseCanisterMigrations),
            "NNS_FUNCTION_SET_SUBNET_OPERATIONAL_LEVEL" => Some(Self::SetSubnetOperationalLevel),
            _ => None,
        }
    }
}
/// The proposal status, with respect to decision making and execution.
/// See also ProposalRewardStatus.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ProposalStatus {
    Unspecified = 0,
    /// A decision (adopt/reject) has yet to be made.
    Open = 1,
    /// The proposal has been rejected.
    Rejected = 2,
    /// The proposal has been adopted (sometimes also called
    /// "accepted"). At this time, either execution as not yet started,
    /// or it has but the outcome is not yet known.
    Adopted = 3,
    /// The proposal was adopted and successfully executed.
    Executed = 4,
    /// The proposal was adopted, but execution failed.
    Failed = 5,
}
impl ProposalStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROPOSAL_STATUS_UNSPECIFIED",
            Self::Open => "PROPOSAL_STATUS_OPEN",
            Self::Rejected => "PROPOSAL_STATUS_REJECTED",
            Self::Adopted => "PROPOSAL_STATUS_ADOPTED",
            Self::Executed => "PROPOSAL_STATUS_EXECUTED",
            Self::Failed => "PROPOSAL_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROPOSAL_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "PROPOSAL_STATUS_OPEN" => Some(Self::Open),
            "PROPOSAL_STATUS_REJECTED" => Some(Self::Rejected),
            "PROPOSAL_STATUS_ADOPTED" => Some(Self::Adopted),
            "PROPOSAL_STATUS_EXECUTED" => Some(Self::Executed),
            "PROPOSAL_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// The proposal status, with respect to reward distribution.
/// See also ProposalStatus.
#[derive(
    candid::CandidType,
    candid::Deserialize,
    serde::Serialize,
    comparable::Comparable,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    ::prost::Enumeration,
)]
#[repr(i32)]
pub enum ProposalRewardStatus {
    Unspecified = 0,
    /// The proposal still accept votes, for the purpose of
    /// vote rewards. This implies nothing on the ProposalStatus.
    AcceptVotes = 1,
    /// The proposal no longer accepts votes. It is due to settle
    /// at the next reward event.
    ReadyToSettle = 2,
    /// The proposal has been taken into account in a reward event.
    Settled = 3,
    /// The proposal is not eligible to be taken into account in a reward event.
    Ineligible = 4,
}
impl ProposalRewardStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROPOSAL_REWARD_STATUS_UNSPECIFIED",
            Self::AcceptVotes => "PROPOSAL_REWARD_STATUS_ACCEPT_VOTES",
            Self::ReadyToSettle => "PROPOSAL_REWARD_STATUS_READY_TO_SETTLE",
            Self::Settled => "PROPOSAL_REWARD_STATUS_SETTLED",
            Self::Ineligible => "PROPOSAL_REWARD_STATUS_INELIGIBLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROPOSAL_REWARD_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "PROPOSAL_REWARD_STATUS_ACCEPT_VOTES" => Some(Self::AcceptVotes),
            "PROPOSAL_REWARD_STATUS_READY_TO_SETTLE" => Some(Self::ReadyToSettle),
            "PROPOSAL_REWARD_STATUS_SETTLED" => Some(Self::Settled),
            "PROPOSAL_REWARD_STATUS_INELIGIBLE" => Some(Self::Ineligible),
            _ => None,
        }
    }
}
