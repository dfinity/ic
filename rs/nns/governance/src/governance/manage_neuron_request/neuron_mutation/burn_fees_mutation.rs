use crate::{
    governance::{
        governance_minting_account,
        manage_neuron_request::neuron_mutation::{
            GovernanceMutationProxy, GovernanceNeuronMutation, NeuronDeltas,
        },
    },
    pb::v1::{governance_error::ErrorType, GovernanceError},
};
use async_trait::async_trait;
use ic_nns_common::pb::v1::NeuronId;
use maplit::btreemap;
use std::{collections::BTreeMap, ops::Neg};

pub struct BurnFeesMutation {
    neuron_id: NeuronId,
}

impl BurnFeesMutation {
    pub fn new(neuron_id: NeuronId) -> Self {
        Self { neuron_id }
    }
}

#[async_trait]
impl GovernanceNeuronMutation for BurnFeesMutation {
    fn calculate_neuron_deltas_to_apply(
        &self,
        gov: &GovernanceMutationProxy,
    ) -> Result<BTreeMap<NeuronId, NeuronDeltas>, GovernanceError> {
        let neuron_fees_e8s = gov.with_neuron(&self.neuron_id, |neuron| neuron.neuron_fees_e8s)?;

        let transaction_fees = gov.transaction_fee();

        if neuron_fees_e8s <= transaction_fees {
            return Ok(btreemap! {});
        }

        Ok(btreemap! {
            self.neuron_id => NeuronDeltas {
            neuron_fees_e8s: (neuron_fees_e8s as i128).neg(),
            cached_neuron_stake_e8s: (neuron_fees_e8s as i128).neg(),
            aging_since_timestamp_seconds: 0,
            dissolve_delay: 0,
            maturity_e8s_equivalent: 0,
            staked_maturity_e8s_equivalent: 0,
        }})
    }

    async fn apply_external_mutation(
        &self,
        gov_proxy: &mut GovernanceMutationProxy,
        deltas: &mut BTreeMap<NeuronId, NeuronDeltas>,
    ) -> Result<(), GovernanceError> {
        let gov = match gov_proxy {
            GovernanceMutationProxy::Committing(governance) => governance,
            GovernanceMutationProxy::Simulating(_) => {
                panic!("Cannot run external operations without Committing Governance")
            }
        };

        if deltas.is_empty() {
            return Ok(());
        }

        if deltas.len() > 1 {
            return Err(GovernanceError::new_with_message(
                ErrorType::PreconditionFailed,
                "Unable to apply BurnFeesMutation because Deltas were not generated by this mutation.",
            ));
        }

        let Some(delta) = deltas.get(&self.neuron_id) else {
            return Err(GovernanceError::new_with_message(
                ErrorType::PreconditionFailed,
                "Unable to apply BurnFeesMutation because Deltas were not generated by this mutation.",
            ));
        };

        let change_amount = delta.neuron_fees_e8s;
        if change_amount >= 0 {
            return Err(GovernanceError::new_with_message(ErrorType::PreconditionFailed,
                "This mutation can only make a negative change to neuron_fees_e8s and cached_neuron_stake_e8s, but 0 or positive change was given"
            ));
        }

        let amount_to_subtract = change_amount.saturating_abs();

        let from_subaccount = gov
            .neuron_store
            .with_neuron(&self.neuron_id, |n| n.subaccount())?;

        let _result = gov
            .ledger
            .transfer_funds(
                amount_to_subtract
                    .try_into()
                    .expect("Absolute value i128 should be a u64"),
                0, // Burning transfers don't pay a fee.
                Some(from_subaccount),
                governance_minting_account(),
                gov.env.now(),
            )
            .await?;

        Ok(())
    }
}
