/* tag::catalog[]
Title:: Salt-sharing canister integration with API boundary nodes

Goal:: Ensure API boundary nodes can retrieve shared salt generated by the canister.

Runbook:
1. Set up an Internet Computer (IC) with a system-subnet and an API boundary node
2. Install the salt-sharing canister at a specified mainnet ID
3. Retrieve the `last_salt_id` metric from the ic-boundary and assert that it is greater than zero

end::catalog[] */

use anyhow::{bail, Result};
use candid::{Encode, Principal};
use ic_base_types::PrincipalId;
use ic_nns_test_utils::itest_helpers::install_rust_canister_from_path;
use salt_sharing_api::InitArg;
use slog::info;
use std::{env, net::SocketAddr, str::FromStr, time::Duration};
use tokio::runtime::Runtime;

use ic_agent::export::reqwest::Client;
use ic_registry_subnet_type::SubnetType;
use ic_system_test_driver::{
    driver::test_env_api::NnsInstallationBuilder,
    driver::{
        group::SystemTestGroup,
        ic::InternetComputer,
        test_env::TestEnv,
        test_env_api::{
            get_dependency_path, GetFirstHealthyNodeSnapshot, HasPublicApiUrl, HasTopologySnapshot,
            IcNodeContainer,
        },
    },
    retry_with_msg_async, systest,
    util::runtime_from_url,
};

const SALT_SHARING_CANISTER_ID: &str = "uz2z3-qyaaa-aaaaq-qaacq-cai";
const IC_BOUNDARY_SALT_METRIC: &str = "ic_boundary_anonymization_salt_last_salt_id";

pub fn setup(env: TestEnv) {
    info!(
        &env.logger(),
        "Step 1. Set up an Internet Computer (IC) with a system-subnet and an API boundary node"
    );
    InternetComputer::new()
        .add_fast_single_node_subnet(SubnetType::System)
        .use_specified_ids_allocation_range()
        .with_api_boundary_nodes(1)
        .setup_and_start(&env)
        .expect("failed to setup IC under test");
    let nns_node = env
        .topology_snapshot()
        .root_subnet()
        .nodes()
        .next()
        .unwrap();
    NnsInstallationBuilder::new()
        .at_ids()
        .install(&nns_node, &env)
        .expect("could not install NNS canisters");
    info!(&env.logger(), "Checking readiness of all replica nodes ...");
    env.topology_snapshot().subnets().for_each(|subnet| {
        subnet
            .nodes()
            .for_each(|node| node.await_status_is_healthy().unwrap())
    });
}

async fn test_async(env: TestEnv) {
    let logger = env.logger();

    let nns_node = env.get_first_healthy_system_node_snapshot();
    let nns = runtime_from_url(nns_node.get_public_url(), nns_node.effective_canister_id());

    let salt_sharing_canister_id = Principal::from_text(SALT_SHARING_CANISTER_ID).unwrap();

    info!(
        &logger,
        "Step 2. Install the salt-sharing canister at a specified mainnet ID {salt_sharing_canister_id}"
    );

    let mut salt_sharing_canister = nns
        .create_canister_at_id(PrincipalId(salt_sharing_canister_id))
        .await
        .unwrap();

    let path_to_wasm = get_dependency_path(
        env::var("SALT_SHARING_CANISTER_WASM_PATH")
            .expect("SALT_SHARING_CANISTER_WASM_PATH not set"),
    );

    let args = Encode!(&InitArg {
        regenerate_now: true,
        salt_generation_strategy: salt_sharing_api::SaltGenerationStrategy::StartOfMonth,
        registry_polling_interval_secs: 5,
    })
    .unwrap();

    info!(&logger, "Installing salt-sharing canister wasm ...");

    install_rust_canister_from_path(&mut salt_sharing_canister, path_to_wasm, Some(args)).await;

    info!(
        &logger,
        "Salt-sharing canister with id={salt_sharing_canister_id} installed successfully"
    );

    let url = {
        let api_bn = env.topology_snapshot().api_boundary_nodes().next().unwrap();
        let ipv6 = SocketAddr::new(api_bn.get_ip_addr(), 9324);
        format!("http://{ipv6}/metrics")
    };

    info!(&logger, "Step 3. Verify that API boundary node retrieves the salt and exposes the corresponding metric");

    let metrics_extractor = MetricsExtractor { url };

    retry_with_msg_async!(
        "check_last_salt_id_metric_is_set".to_string(),
        &logger,
        Duration::from_secs(180),
        Duration::from_secs(5),
        || async {
            match metrics_extractor
                .try_get_metric::<u64>(IC_BOUNDARY_SALT_METRIC)
                .await
            {
                Ok(last_salt_id) if last_salt_id > 0 => Ok(()),
                _ => {
                    bail!("last_salt_id hasn't been set yet");
                }
            }
        }
    )
    .await
    .expect("shared salt was not received by API boundary node");
}

fn test(env: TestEnv) {
    let rt = Runtime::new().expect("Could not create tokio runtime");
    rt.block_on(test_async(env));
}

fn main() -> Result<()> {
    SystemTestGroup::new()
        .with_setup(setup)
        .add_test(systest!(test))
        .execute_from_args()?;
    Ok(())
}

struct MetricsExtractor {
    url: String,
}

impl MetricsExtractor {
    pub async fn try_get_metric<T>(&self, pattern: &str) -> Result<T, String>
    where
        T: FromStr,
    {
        let client = Client::builder()
            .danger_accept_invalid_certs(true)
            .build()
            .map_err(|err| format!("failed to build a client: {err:?}"))?;

        let response = client
            .get(self.url.clone())
            .send()
            .await
            .map_err(|err| format!("http request failed: {err:?}"))?;

        let body = response
            .text()
            .await
            .map_err(|err| format!("failed to decode response body: {err:?}"))?;

        let metrics = body.lines().map(str::to_string).collect::<Vec<_>>();

        metrics
            .into_iter()
            .find(|metric| metric.starts_with(pattern))
            .and_then(|metric| metric.split_whitespace().nth(1)?.parse().ok())
            .ok_or_else(|| "metric not found".to_string())
    }
}
